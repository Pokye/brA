Index: conf/battle/battleground.conf
===================================================================
diff --git a/conf/battle/battleground.conf b/conf/battle/battleground.conf
--- a/conf/battle/battleground.conf	05537ea85ff
+++ b/conf/battle/battleground.conf	9468696494d
@@ -31,6 +31,62 @@
 // Interval before updating the bg-member map mini-dots (milliseconds)
 bg_update_interval: 1000
 
-// Before a player is warped into a Battleground from the Battleground Queue,
-// check to see if the player's current map has MF_NOWARP.
-bgqueue_nowarp_mapflag: no
+//========================================
+// Battleground eAmod
+//========================================
+
+// Enable/Disable Extended BG
+bg_eAmod_mode: 1
+
+// Only allow to join queues from maps with Town mapflag. If not, players can join the BG queue everywhere, except from Battlegrounds maps. Note 1.
+bg_queue_onlytowns: 1
+
+// Time in seconds to consider a idle character on BG. Characters on Idle mode can be kicked out of BG with @reportafk. Set 0 to disable.
+bg_idle_announce: 30
+
+// Time in seconds to kick a idle character from BG if idle. They will be warped to their respawn positions. Set 0 to disable.
+bg_idle_autokick: 60
+
+// Does the @reportafk command to kick AFK players from your BG team are limited to the Team Leader only? Note 1.
+bg_reportafk_leaderonly: 1
+
+// @order command behavior
+// 0 - Display "Team Leader" as source
+// 1 - Display "Character's Name" as source
+bg_order_behavior: 1
+
+// Balance the team.
+bg_queue2team_balanced: 1
+
+// Rates as BG rewards (badges) are given. Note 3
+bg_reward_rates: 100
+
+// Reserved Char ID for battleground Items. Default value is 999996
+bg_reserved_char_id: 999996
+
+// Reserved Char ID for items usables only on WoE or GvG maps.
+woe_reserved_char_id: 999997
+
+// Allow/Deny trade BG consumables between players, gstorage (Note 1)
+bg_can_trade: 1
+
+// Deny Double Login on Battleground (IP Based)) (Note 1)
+bg_double_login: 0
+
+// Battleground Team Color Clothes (Note 1)
+bg_team_color: 0
+
+// Palette color number for teams (currently using kamishi pals)
+bg_team_ccolor_blue: 376
+bg_team_ccolor_red: 409
+bg_team_ccolor_green: 390
+
+// Switch Party Skills to BG Team in Battleground (Note 1)
+bg_party_skills: 1
+
+// Warp players to join location when arena ends. If join map is MF_NOWARP returns to bat_room (Note 1)
+bg_join_location: 1
+
+// Extended Check Equipment Info (Note 1)
+bg_extended_check_equip: 0
+bg_queue_interface: 0
Index: conf/battle/feature.conf
===================================================================
diff --git a/conf/battle/feature.conf b/conf/battle/feature.conf
--- a/conf/battle/feature.conf	a39eb39a816
+++ b/conf/battle/feature.conf	2747fe53800
@@ -59,10 +59,6 @@
 // Delay in miliseconds to open vending/buyingsotre after player logged in.
 feature.autotrade_open_delay: 5000
 
-// Battlegrounds queue interface. Makes it possible to queue for a battleground anywhere using the battle menu.
-// Requires: 2012-04-10aRagexe or later
-feature.bgqueue: on
-
 // Roulette (Note 1)
 // Requires: 2014-10-22bRagexe or later
 feature.roulette: on
Index: src/char/char.cpp
===================================================================
diff --git a/src/char/char.cpp b/src/char/char.cpp
--- a/src/char/char.cpp	4711a15ba11
+++ b/src/char/char.cpp	d3bb57a11ca
@@ -46,10 +46,14 @@
 int fame_list_size_chemist = MAX_FAME_LIST;
 int fame_list_size_smith = MAX_FAME_LIST;
 int fame_list_size_taekwon = MAX_FAME_LIST;
+int fame_list_size_bg = MAX_FAME_LIST;
+int fame_list_size_woe = MAX_FAME_LIST;
 // Char-server-side stored fame lists [DracoRPG]
 struct fame_list smith_fame_list[MAX_FAME_LIST];
 struct fame_list chemist_fame_list[MAX_FAME_LIST];
 struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+struct fame_list bg_fame_list[MAX_FAME_LIST];
+struct fame_list woe_fame_list[MAX_FAME_LIST];
 
 #define CHAR_MAX_MSG 300	//max number of msg_conf
 static char* msg_table[CHAR_MAX_MSG]; // Login Server messages_conf
@@ -370,6 +374,84 @@
 			errors++;
 	}
 
+	/* Player Battleground Stadistics */
+	if( memcmp(&p->bgstats, &cp->bgstats, sizeof(struct s_battleground_stats)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "REPLACE INTO `char_bg` ("
+			"`char_id`, "
+			"`top_damage`, `damage_done`, `damage_received`, "
+			"`skulls`, `ti_wins`, `ti_lost`, `ti_tie`, "
+			"`eos_flags`, `eos_bases`, `eos_wins`, `eos_lost`, `eos_tie`, "
+			"`boss_killed`, `boss_damage`, `boss_flags`, `boss_wins`, `boss_lost`, `boss_tie`, "
+			"`dom_bases`, `dom_off_kills`, `dom_def_kills`, `dom_wins`, `dom_lost`, `dom_tie`, "
+			"`td_kills`, `td_deaths`, `td_wins`, `td_lost`, `td_tie`, "
+			"`sc_stole`, `sc_captured`, `sc_droped`, `sc_wins`, `sc_lost`, `sc_tie`, "
+			"`ctf_taken`, `ctf_captured`, `ctf_droped`, `ctf_wins`, `ctf_lost`, `ctf_tie`, "
+			"`emperium_kill`, `barricade_kill`, `gstone_kill`, `cq_wins`, `cq_lost`, "
+			"`ru_captures`, `ru_wins`, `ru_lost`, "
+			"`kill_count`, `death_count`, `win`, `lost`, `tie`, `leader_win`, `leader_lost`, `leader_tie`, `deserter`, `score`, `points`, `rank_points`, `rank_games`,"
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `showstats`)"
+			" VALUES "
+			"('%d',"
+			"'%u','%u','%u',"
+			"'%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%u','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d',"
+			"'%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d','%d','%d','%d',"
+			"'%d','%d','%d','%d',"
+			"'%d','%d','%d','%d','%d')",
+			p->char_id,
+			p->bgstats.top_damage, p->bgstats.damage_done, p->bgstats.damage_received,
+			p->bgstats.skulls,p->bgstats.ti_wins,p->bgstats.ti_lost,p->bgstats.ti_tie,
+			p->bgstats.eos_flags,p->bgstats.eos_bases,p->bgstats.eos_wins,p->bgstats.eos_lost,p->bgstats.eos_tie,
+			p->bgstats.boss_killed,p->bgstats.boss_damage,p->bgstats.boss_flags,p->bgstats.boss_wins,p->bgstats.boss_lost,p->bgstats.boss_tie,
+			p->bgstats.dom_bases,p->bgstats.dom_off_kills,p->bgstats.dom_def_kills,p->bgstats.dom_wins,p->bgstats.dom_lost,p->bgstats.dom_tie,
+			p->bgstats.td_kills,p->bgstats.td_deaths,p->bgstats.td_wins,p->bgstats.td_lost,p->bgstats.td_tie,
+			p->bgstats.sc_stole,p->bgstats.sc_captured,p->bgstats.sc_droped,p->bgstats.sc_wins,p->bgstats.sc_lost,p->bgstats.sc_tie,
+			p->bgstats.ctf_taken,p->bgstats.ctf_captured,p->bgstats.ctf_droped,p->bgstats.ctf_wins,p->bgstats.ctf_lost,p->bgstats.ctf_tie,
+			p->bgstats.emperium_kill,p->bgstats.barricade_kill,p->bgstats.gstone_kill,p->bgstats.cq_wins,p->bgstats.cq_lost,
+			p->bgstats.ru_captures,p->bgstats.ru_wins,p->bgstats.ru_lost,
+			p->bgstats.kill_count,p->bgstats.death_count,p->bgstats.win,p->bgstats.lost,p->bgstats.tie,p->bgstats.leader_win,p->bgstats.leader_lost,p->bgstats.leader_tie,p->bgstats.deserter,p->bgstats.score,p->bgstats.points,p->bgstats.rank_points,p->bgstats.rank_games,
+			p->bgstats.sp_heal_potions, p->bgstats.hp_heal_potions, p->bgstats.yellow_gemstones, p->bgstats.red_gemstones, p->bgstats.blue_gemstones, p->bgstats.poison_bottles, p->bgstats.acid_demostration, p->bgstats.acid_demostration_fail,
+			p->bgstats.support_skills_used, p->bgstats.healing_done, p->bgstats.wrong_support_skills_used, p->bgstats.wrong_healing_done,
+			p->bgstats.sp_used, p->bgstats.zeny_used, p->bgstats.spiritb_used, p->bgstats.ammo_used, p->bgstats.showstats) )
+		{
+			Sql_ShowDebug(sql_handle);
+			errors++;
+		} else
+			strcat(save_status, " bgstats");
+	}
+
+	/* WoE Stadistics */
+	if( memcmp(&p->wstats, &cp->wstats, sizeof(struct s_woestats)) )
+	{
+		if( SQL_ERROR == Sql_Query(sql_handle, "REPLACE INTO `char_wstats` (`char_id`, `kill_count`, `death_count`, `score`, `top_damage`, `damage_done`, `damage_received`, `emperium_damage`, `guardian_damage`, `barricade_damage`, `gstone_damage`, "
+			"`emperium_kill`, `guardian_kill`, `barricade_kill`, `gstone_kill`, "
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `points`, `showstats`) "
+			"VALUES ('%d', '%d', '%d', '%d', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%d', '%d', '%d', '%d', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%u', '%d', '%d')",
+			p->char_id, p->wstats.kill_count, p->wstats.death_count, p->wstats.score, p->wstats.top_damage, p->wstats.damage_done, p->wstats.damage_received, p->wstats.emperium_damage, p->wstats.guardian_damage, p->wstats.barricade_damage, p->wstats.gstone_damage,
+			p->wstats.emperium_kill, p->wstats.guardian_kill, p->wstats.barricade_kill, p->wstats.gstone_kill,
+			p->wstats.sp_heal_potions, p->wstats.hp_heal_potions, p->wstats.yellow_gemstones, p->wstats.red_gemstones, p->wstats.blue_gemstones, p->wstats.poison_bottles, p->wstats.acid_demostration, p->wstats.acid_demostration_fail,
+			p->wstats.support_skills_used, p->wstats.healing_done, p->wstats.wrong_support_skills_used, p->wstats.wrong_healing_done,
+			p->wstats.sp_used, p->wstats.zeny_used, p->wstats.spiritb_used, p->wstats.ammo_used, p->wstats.points, p->wstats.showstats) )
+		{
+			Sql_ShowDebug(sql_handle);
+			errors++;
+		} else
+			strcat(save_status, " woestats");
+	}
+	
 	//memo points
 	if( memcmp(p->memo_point, cp->memo_point, sizeof(p->memo_point)) )
 	{
@@ -1221,6 +1303,137 @@
 	StringBuf_AppendStr(&msg_buf, " hotkeys");
 #endif
 
+	/* Character Battleground Standings */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `top_damage`,`damage_done`,`damage_received`,`skulls`,`ti_wins`,`ti_lost`,`ti_tie`,`eos_flags`,`eos_bases`,`eos_wins`,`eos_lost`,`eos_tie`,`boss_killed`,`boss_damage`,`boss_flags`,`boss_wins`,`boss_lost`,`boss_tie`,`td_kills`,`td_deaths`,`td_wins`,`td_lost`,`td_tie`,`dom_bases`,`dom_off_kills`,`dom_def_kills`,`dom_wins`,`dom_lost`,`dom_tie`,`sc_stole`,`sc_captured`,`sc_droped`,`sc_wins`,`sc_lost`,`sc_tie`,`ctf_taken`,`ctf_captured`,`ctf_droped`,`ctf_wins`,`ctf_lost`,`ctf_tie`,`emperium_kill`,`barricade_kill`,`gstone_kill`,`cq_wins`,`cq_lost`,`ru_wins`,`ru_lost`,`ru_captures`,`kill_count`,`death_count`,`win`,`lost`,`tie`,`leader_win`,`leader_lost`,`leader_tie`,`deserter`,`score`,`points`,`rank_points`,`rank_games`,`sp_heal_potions`,`hp_heal_potions`,`yellow_gemstones`,`red_gemstones`,`blue_gemstones`,`poison_bottles`,`acid_demostration`,`acid_demostration_fail`,`support_skills_used`,`healing_done`,`wrong_support_skills_used`,`wrong_healing_done`,`sp_used`,`zeny_used`,`spiritb_used`,`ammo_used`,`showstats` FROM `char_bg` WHERE `char_id` = ?")
+		|| SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+		|| SQL_ERROR == SqlStmt_Execute(stmt)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  0, SQLDT_UINT,   &p->bgstats.top_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  1, SQLDT_UINT,   &p->bgstats.damage_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  2, SQLDT_UINT,   &p->bgstats.damage_received, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  3, SQLDT_USHORT, &p->bgstats.skulls, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  4, SQLDT_USHORT, &p->bgstats.ti_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  5, SQLDT_USHORT, &p->bgstats.ti_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  6, SQLDT_USHORT, &p->bgstats.ti_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  7, SQLDT_USHORT, &p->bgstats.eos_flags, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  8, SQLDT_USHORT, &p->bgstats.eos_bases, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  9, SQLDT_USHORT, &p->bgstats.eos_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 10, SQLDT_USHORT, &p->bgstats.eos_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 11, SQLDT_USHORT, &p->bgstats.eos_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 12, SQLDT_USHORT, &p->bgstats.boss_killed, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 13, SQLDT_UINT,   &p->bgstats.boss_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 14, SQLDT_USHORT, &p->bgstats.boss_flags, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 15, SQLDT_USHORT, &p->bgstats.boss_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 16, SQLDT_USHORT, &p->bgstats.boss_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 17, SQLDT_USHORT, &p->bgstats.boss_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 18, SQLDT_USHORT, &p->bgstats.td_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 19, SQLDT_USHORT, &p->bgstats.td_deaths, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 20, SQLDT_USHORT, &p->bgstats.td_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 21, SQLDT_USHORT, &p->bgstats.td_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 22, SQLDT_USHORT, &p->bgstats.td_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 23, SQLDT_USHORT, &p->bgstats.dom_bases, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 24, SQLDT_USHORT, &p->bgstats.dom_off_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 25, SQLDT_USHORT, &p->bgstats.dom_def_kills, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 26, SQLDT_USHORT, &p->bgstats.dom_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 27, SQLDT_USHORT, &p->bgstats.dom_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 28, SQLDT_USHORT, &p->bgstats.dom_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 29, SQLDT_USHORT, &p->bgstats.sc_stole, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 30, SQLDT_USHORT, &p->bgstats.sc_captured, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 31, SQLDT_USHORT, &p->bgstats.sc_droped, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 32, SQLDT_USHORT, &p->bgstats.sc_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 33, SQLDT_USHORT, &p->bgstats.sc_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 34, SQLDT_USHORT, &p->bgstats.sc_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 35, SQLDT_USHORT, &p->bgstats.ctf_taken, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 36, SQLDT_USHORT, &p->bgstats.ctf_captured, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 37, SQLDT_USHORT, &p->bgstats.ctf_droped, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 38, SQLDT_USHORT, &p->bgstats.ctf_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 39, SQLDT_USHORT, &p->bgstats.ctf_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 40, SQLDT_USHORT, &p->bgstats.ctf_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 41, SQLDT_USHORT, &p->bgstats.emperium_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 42, SQLDT_USHORT, &p->bgstats.barricade_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 43, SQLDT_USHORT, &p->bgstats.gstone_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 44, SQLDT_USHORT, &p->bgstats.cq_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 45, SQLDT_USHORT, &p->bgstats.cq_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 46, SQLDT_USHORT, &p->bgstats.ru_wins, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 47, SQLDT_USHORT, &p->bgstats.ru_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 48, SQLDT_USHORT, &p->bgstats.ru_captures, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 49, SQLDT_USHORT, &p->bgstats.kill_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 50, SQLDT_USHORT, &p->bgstats.death_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 51, SQLDT_USHORT, &p->bgstats.win, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 52, SQLDT_USHORT, &p->bgstats.lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 53, SQLDT_USHORT, &p->bgstats.tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 54, SQLDT_USHORT, &p->bgstats.leader_win, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 55, SQLDT_USHORT, &p->bgstats.leader_lost, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 56, SQLDT_USHORT, &p->bgstats.leader_tie, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 57, SQLDT_USHORT, &p->bgstats.deserter, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 58, SQLDT_USHORT, &p->bgstats.score, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 59, SQLDT_USHORT, &p->bgstats.points, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 60, SQLDT_USHORT, &p->bgstats.rank_points, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 61, SQLDT_USHORT, &p->bgstats.rank_games, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 62, SQLDT_UINT,   &p->bgstats.sp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 63, SQLDT_UINT,   &p->bgstats.hp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 64, SQLDT_UINT,   &p->bgstats.yellow_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 65, SQLDT_UINT,   &p->bgstats.red_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 66, SQLDT_UINT,   &p->bgstats.blue_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 67, SQLDT_UINT,   &p->bgstats.poison_bottles, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 68, SQLDT_UINT,   &p->bgstats.acid_demostration, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 69, SQLDT_UINT,   &p->bgstats.acid_demostration_fail, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 70, SQLDT_UINT,   &p->bgstats.support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 71, SQLDT_UINT,   &p->bgstats.healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 72, SQLDT_UINT,   &p->bgstats.wrong_support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 73, SQLDT_UINT,   &p->bgstats.wrong_healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 74, SQLDT_UINT,   &p->bgstats.sp_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 75, SQLDT_UINT,   &p->bgstats.zeny_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 76, SQLDT_UINT,   &p->bgstats.spiritb_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 77, SQLDT_UINT,   &p->bgstats.ammo_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 78, SQLDT_USHORT, &p->bgstats.showstats, 0, NULL, NULL)
+		|| SQL_SUCCESS != SqlStmt_NextRow(stmt) )
+	{
+		p->bgstats.score = 2000;
+	}
+	StringBuf_AppendStr(&msg_buf, " bgstats");
+
+	/* Character WoE Standings */
+	if( SQL_ERROR == SqlStmt_Prepare(stmt, "SELECT `top_damage`, `damage_done`, `damage_received`, `emperium_damage`, `guardian_damage`, `barricade_damage`, `gstone_damage`, `emperium_kill`, `guardian_kill`, `barricade_kill`, `gstone_kill`, `sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, `support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, `sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `kill_count`, `death_count`, `score`, `points`, `showstats` FROM `char_wstats` WHERE `char_id` = ?")
+		|| SQL_ERROR == SqlStmt_BindParam(stmt, 0, SQLDT_INT, &char_id, 0)
+		|| SQL_ERROR == SqlStmt_Execute(stmt)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  0, SQLDT_UINT, &p->wstats.top_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  1, SQLDT_UINT, &p->wstats.damage_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  2, SQLDT_UINT, &p->wstats.damage_received, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  3, SQLDT_UINT, &p->wstats.emperium_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  4, SQLDT_UINT, &p->wstats.guardian_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  5, SQLDT_UINT, &p->wstats.barricade_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  6, SQLDT_UINT, &p->wstats.gstone_damage, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  7, SQLDT_USHORT, &p->wstats.emperium_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  8, SQLDT_USHORT, &p->wstats.guardian_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt,  9, SQLDT_USHORT, &p->wstats.barricade_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 10, SQLDT_USHORT, &p->wstats.gstone_kill, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 11, SQLDT_UINT, &p->wstats.sp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 12, SQLDT_UINT, &p->wstats.hp_heal_potions, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 13, SQLDT_UINT, &p->wstats.yellow_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 14, SQLDT_UINT, &p->wstats.red_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 15, SQLDT_UINT, &p->wstats.blue_gemstones, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 16, SQLDT_UINT, &p->wstats.poison_bottles, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 17, SQLDT_UINT, &p->wstats.acid_demostration, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 18, SQLDT_UINT, &p->wstats.acid_demostration_fail, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 19, SQLDT_UINT, &p->wstats.support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 20, SQLDT_UINT, &p->wstats.healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 21, SQLDT_UINT, &p->wstats.wrong_support_skills_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 22, SQLDT_UINT, &p->wstats.wrong_healing_done, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 23, SQLDT_UINT, &p->wstats.sp_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 24, SQLDT_UINT, &p->wstats.zeny_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 25, SQLDT_UINT, &p->wstats.spiritb_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 26, SQLDT_UINT, &p->wstats.ammo_used, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 27, SQLDT_USHORT, &p->wstats.kill_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 28, SQLDT_USHORT, &p->wstats.death_count, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 29, SQLDT_USHORT, &p->wstats.score, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 30, SQLDT_USHORT, &p->wstats.points, 0, NULL, NULL)
+		|| SQL_ERROR == SqlStmt_BindColumn(stmt, 31, SQLDT_USHORT, &p->wstats.showstats, 0, NULL, NULL)
+		|| SQL_SUCCESS != SqlStmt_NextRow(stmt) )
+	{
+		p->wstats.score = 2000;
+	}
+	StringBuf_AppendStr(&msg_buf, " woestats");
+
 	/* Mercenary Owner DataBase */
 	mercenary_owner_fromsql(char_id, p);
 	StringBuf_AppendStr(&msg_buf, " mercenary");
@@ -1511,6 +1724,63 @@
 			Sql_ShowDebug(sql_handle);
 	}
 
+	// Extended Features BG [Easycore]
+	// Create a new entry in char_bg table
+	if( SQL_ERROR == Sql_Query(sql_handle, "INSERT INTO `char_bg` ("
+			"`char_id`, "
+			"`top_damage`, `damage_done`, `damage_received`, "
+			"`skulls`, `ti_wins`, `ti_lost`, `ti_tie`, "
+			"`eos_flags`, `eos_bases`, `eos_wins`, `eos_lost`, `eos_tie`, "
+			"`boss_killed`, `boss_damage`, `boss_flags`, `boss_wins`, `boss_lost`, `boss_tie`, "
+			"`dom_bases`, `dom_off_kills`, `dom_def_kills`, `dom_wins`, `dom_lost`, `dom_tie`, "
+			"`td_kills`, `td_deaths`, `td_wins`, `td_lost`, `td_tie`, "
+			"`sc_stole`, `sc_captured`, `sc_droped`, `sc_wins`, `sc_lost`, `sc_tie`, "
+			"`ctf_taken`, `ctf_captured`, `ctf_droped`, `ctf_wins`, `ctf_lost`, `ctf_tie`, "
+			"`emperium_kill`, `barricade_kill`, `gstone_kill`, `cq_wins`, `cq_lost`, "
+			"`ru_captures`, `ru_wins`, `ru_lost`, "
+			"`kill_count`, `death_count`, `win`, `lost`, `tie`, `leader_win`, `leader_lost`, `leader_tie`, `deserter`, `score`, `points`, `rank_points`, `rank_games`,"
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `showstats`)"
+			" VALUES "
+			"('%d',"
+			"'0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0','0',"
+			"'0','0','0','0','0','0',"
+			"'0','0','0','0','0','0',"
+			"'0','0','0','0','0',"
+			"'0','0','0','0','0','0',"
+			"'0','0','0','0','0','0',"
+			"'0','0','0','0','0',"
+			"'0','0','0',"
+			"'0','0','0','0','0','0','0','0','0','0','0','0','0',"
+			"'0','0','0','0','0','0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0','0')",
+			char_id) )
+			Sql_ShowDebug(sql_handle);
+
+	// Create a new entry in char_wstats table
+	if( SQL_ERROR == Sql_Query(sql_handle, "INSERT INTO `char_wstats` ("
+			"`char_id`, "
+			"`top_damage`, `damage_done`, `damage_received`, "
+			"`emperium_damage`, `guardian_damage`, `barricade_damage`, `gstone_damage`, "
+			"`emperium_kill`, `guardian_kill`, `barricade_kill`, `gstone_kill`, "
+			"`sp_heal_potions`, `hp_heal_potions`, `yellow_gemstones`, `red_gemstones`, `blue_gemstones`, `poison_bottles`, `acid_demostration`, `acid_demostration_fail`, "
+			"`support_skills_used`, `healing_done`, `wrong_support_skills_used`, `wrong_healing_done`, "
+			"`sp_used`, `zeny_used`, `spiritb_used`, `ammo_used`, `kill_count`, `death_count`, `score`, `points`, `showstats`)"
+			" VALUES "
+			"('%d',"
+			"'0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0','0','0','0','0',"
+			"'0','0','0','0',"
+			"'0','0','0','0','0','0','0','0','0')",
+			char_id) )
+			Sql_ShowDebug(sql_handle);
+	
 	ShowInfo("Created char: account: %d, char: %d, slot: %d, name: %s\n", sd->account_id, char_id, slot, name);
 	return char_id;
 }
@@ -1719,6 +1989,14 @@
 			Sql_ShowDebug(sql_handle);
 	}
 
+	// Delete records in char_bg table
+	if (SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `char_bg` WHERE `char_id` = '%d'", char_id))
+		Sql_ShowDebug(sql_handle);
+	
+	// Delete records in char_wstats table
+	if (SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `char_wstats` WHERE `char_id` = '%d'", char_id))
+		Sql_ShowDebug(sql_handle);
+	
 	/* delete character */
 	if( SQL_ERROR == Sql_Query(sql_handle, "DELETE FROM `%s` WHERE `char_id`='%d'", schema_config.char_db, char_id) )
 		Sql_ShowDebug(sql_handle);
@@ -2016,6 +2294,8 @@
 	memset(smith_fame_list, 0, sizeof(smith_fame_list));
 	memset(chemist_fame_list, 0, sizeof(chemist_fame_list));
 	memset(taekwon_fame_list, 0, sizeof(taekwon_fame_list));
+	memset(bg_fame_list, 0, sizeof(bg_fame_list));
+	memset(woe_fame_list, 0, sizeof(woe_fame_list));
 	// Build Blacksmith ranking list
 	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_id`,`fame`,`name` FROM `%s` WHERE `fame`>0 AND (`class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d' OR `class`='%d') ORDER BY `fame` DESC LIMIT 0,%d", schema_config.char_db, JOB_BLACKSMITH, JOB_WHITESMITH, JOB_BABY_BLACKSMITH, JOB_MECHANIC, JOB_MECHANIC_T, JOB_BABY_MECHANIC, fame_list_size_smith) )
 		Sql_ShowDebug(sql_handle);
@@ -2061,6 +2341,36 @@
 		Sql_GetData(sql_handle, 2, &data, &len);
 		memcpy(taekwon_fame_list[i].name, data, zmin(len, NAME_LENGTH));
 	}
+	// Build BG ranking list
+	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_bg`.`char_id`, `char_bg`.`points`, `%s`.`name` FROM `char_bg` LEFT JOIN `%s` ON `%s`.`char_id` = `char_bg`.`char_id` WHERE `char_bg`.`points` > '0' ORDER BY `char_bg`.`points` DESC LIMIT 0,%d", schema_config.char_db, schema_config.char_db, schema_config.char_db, fame_list_size_bg) )
+		Sql_ShowDebug(sql_handle);
+	for( i = 0; i < fame_list_size_bg && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i )
+	{
+		// char_id
+		Sql_GetData(sql_handle, 0, &data, NULL);
+		bg_fame_list[i].id = atoi(data);
+		// fame
+		Sql_GetData(sql_handle, 1, &data, &len);
+		bg_fame_list[i].fame = atoi(data);
+		// name
+		Sql_GetData(sql_handle, 2, &data, &len);
+		memcpy(bg_fame_list[i].name, data, min(len, NAME_LENGTH));
+	}
+	// Build WoE ranking list
+	if( SQL_ERROR == Sql_Query(sql_handle, "SELECT `char_wstats`.`char_id`, `char_wstats`.`points`, `%s`.`name` FROM `char_wstats` LEFT JOIN `%s` ON `%s`.`char_id` = `char_wstats`.`char_id` WHERE `char_wstats`.`points` > '0' ORDER BY `char_wstats`.`points` DESC LIMIT 0,%d", schema_config.char_db, schema_config.char_db, schema_config.char_db, fame_list_size_bg) )
+		Sql_ShowDebug(sql_handle);
+	for( i = 0; i < fame_list_size_bg && SQL_SUCCESS == Sql_NextRow(sql_handle); ++i )
+	{
+		// char_id
+		Sql_GetData(sql_handle, 0, &data, NULL);
+		woe_fame_list[i].id = atoi(data);
+		// fame
+		Sql_GetData(sql_handle, 1, &data, &len);
+		woe_fame_list[i].fame = atoi(data);
+		// name
+		Sql_GetData(sql_handle, 2, &data, &len);
+		memcpy(woe_fame_list[i].name, data, min(len, NAME_LENGTH));
+	}
 	Sql_FreeResult(sql_handle);
 }
 
Index: src/char/char.hpp
===================================================================
diff --git a/src/char/char.hpp b/src/char/char.hpp
--- a/src/char/char.hpp	6db2ea75f1d
+++ b/src/char/char.hpp	761693a587b
@@ -263,10 +263,14 @@
 extern int fame_list_size_chemist;
 extern int fame_list_size_smith;
 extern int fame_list_size_taekwon;
+extern int fame_list_size_bg;
+extern int fame_list_size_woe;
 // Char-server-side stored fame lists [DracoRPG]
 extern struct fame_list smith_fame_list[MAX_FAME_LIST];
 extern struct fame_list chemist_fame_list[MAX_FAME_LIST];
 extern struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+extern struct fame_list bg_fame_list[MAX_FAME_LIST];
+extern struct fame_list woe_fame_list[MAX_FAME_LIST];
 
 #define DEFAULT_AUTOSAVE_INTERVAL 300*1000
 #define MAX_CHAR_BUF 150 //Max size (for WFIFOHEAD calls)
Index: src/char/char_mapif.cpp
===================================================================
diff --git a/src/char/char_mapif.cpp b/src/char/char_mapif.cpp
--- a/src/char/char_mapif.cpp	2e451fed8fc
+++ b/src/char/char_mapif.cpp	0bc2d204df1
@@ -96,11 +96,25 @@
  * @return : 0 success
  */
 int chmapif_send_fame_list(int fd){
-	int i, len = 8;
+	int i, len = 12;
 	unsigned char buf[32000];
 
 	WBUFW(buf,0) = 0x2b1b;
 
+	for( i = 0; i < fame_list_size_woe && woe_fame_list[i].id; i++ )
+	{
+		memcpy(WBUFP(buf,len),&woe_fame_list[i],sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+	WBUFW(buf, 10) = len;
+
+	for( i = 0; i < fame_list_size_bg && bg_fame_list[i].id; i++ )
+	{
+		memcpy(WBUFP(buf,len),&bg_fame_list[i],sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+	WBUFW(buf, 8) = len;
+	
 	for(i = 0; i < fame_list_size_smith && smith_fame_list[i].id; i++) {
 		memcpy(WBUFP(buf, len), &smith_fame_list[i], sizeof(struct fame_list));
 		len += sizeof(struct fame_list);
@@ -1107,6 +1121,8 @@
 				case RANK_BLACKSMITH:	size = fame_list_size_smith;	list = smith_fame_list;		break;
 				case RANK_ALCHEMIST:	size = fame_list_size_chemist;	list = chemist_fame_list;	break;
 				case RANK_TAEKWON:		size = fame_list_size_taekwon;	list = taekwon_fame_list;	break;
+				case RANK_BG:			size = fame_list_size_bg;		list = bg_fame_list;		break;
+				case RANK_WOE:			size = fame_list_size_woe;		list = woe_fame_list;		break;
 				default:				size = 0;						list = NULL;				break;
             }
 
Index: src/common/mmo.hpp
===================================================================
diff --git a/src/common/mmo.hpp b/src/common/mmo.hpp
--- a/src/common/mmo.hpp	179304015db
+++ b/src/common/mmo.hpp	91025cbae6f
@@ -492,6 +492,118 @@
 };
 #endif
 
+struct s_battleground_stats {
+	unsigned int
+		top_damage,
+		damage_done,
+		damage_received,
+		boss_damage;
+	unsigned short
+		// Triple Inferno
+		skulls,
+		ti_wins, ti_lost, ti_tie,
+		// Tierra EoS
+		eos_flags,
+		eos_bases,
+		eos_wins, eos_lost, eos_tie,
+		// Tierra Bossnia
+		boss_killed,
+		boss_flags,
+		boss_wins, boss_lost, boss_tie,
+		// Tierra Domination
+		dom_bases,
+		dom_off_kills,
+		dom_def_kills,
+		dom_wins, dom_lost, dom_tie,
+		// Flavius TD
+		td_kills,
+		td_deaths,
+		td_wins, td_lost, td_tie,
+		// Flavius SC
+		sc_stole,
+		sc_captured,
+		sc_droped,
+		sc_wins, sc_lost, sc_tie,
+		// Flavius CTF
+		ctf_taken,
+		ctf_captured,
+		ctf_droped,
+		ctf_wins, ctf_lost, ctf_tie,
+		// Conquest
+		emperium_kill,
+		barricade_kill,
+		gstone_kill,
+		cq_wins, cq_lost,
+		// Rush
+		ru_captures,
+		ru_wins, ru_lost;
+
+	unsigned int // Ammo
+		sp_heal_potions,
+		hp_heal_potions,
+		yellow_gemstones,
+		red_gemstones,
+		blue_gemstones,
+		poison_bottles,
+		acid_demostration,
+		acid_demostration_fail,
+		support_skills_used,
+		healing_done,
+		wrong_support_skills_used,
+		wrong_healing_done,
+		sp_used,
+		zeny_used,
+		spiritb_used,
+		ammo_used;
+	unsigned short
+		kill_count,
+		death_count,
+		win, lost, tie,
+		leader_win, leader_lost, leader_tie,
+		deserter, rank_games;
+
+	int score, points, rank_points, showstats;
+};
+
+struct s_woestats {
+	int score;
+	unsigned short
+		kill_count,
+		death_count;
+	unsigned int
+		top_damage,
+		damage_done,
+		damage_received;
+	unsigned int
+		emperium_damage,
+		guardian_damage,
+		barricade_damage,
+		gstone_damage;
+	unsigned short
+		emperium_kill,
+		guardian_kill,
+		barricade_kill,
+		gstone_kill;
+	unsigned int // Ammo
+		sp_heal_potions,
+		hp_heal_potions,
+		yellow_gemstones,
+		red_gemstones,
+		blue_gemstones,
+		poison_bottles,
+		acid_demostration,
+		acid_demostration_fail,
+		support_skills_used,
+		healing_done,
+		wrong_support_skills_used,
+		wrong_healing_done,
+		sp_used,
+		zeny_used,
+		spiritb_used,
+		ammo_used;
+	int points, showstats;
+};
+
 struct mmo_charstatus {
 	uint32 char_id;
 	uint32 account_id;
@@ -531,6 +643,9 @@
 	uint32 mapip;
 	uint16 mapport;
 
+	struct s_battleground_stats bgstats;
+	struct s_woestats wstats;
+	
 	struct point last_point,save_point,memo_point[MAX_MEMOPOINTS];
 	struct s_skill skill[MAX_SKILL];
 
@@ -691,6 +806,8 @@
 	struct guild_alliance alliance[MAX_GUILDALLIANCE];
 	struct guild_expulsion expulsion[MAX_GUILDEXPULSION];
 	struct guild_skill skill[MAX_GUILDSKILL];
+	int skill_block_timer[MAX_GUILDSKILL]; // BG eAmod
+	int ccolor;
 	struct Channel *channel;
 	int instance_id;
 	time_t last_leader_change;
@@ -1024,7 +1141,9 @@
 	RANK_BLACKSMITH = 0,
 	RANK_ALCHEMIST = 1,
 	RANK_TAEKWON = 2,
-	RANK_KILLER = 3
+	RANK_KILLER = 3,
+	RANK_BG = 4,
+	RANK_WOE = 5
 };
 
 struct clan_alliance {
Index: src/common/utils.hpp
===================================================================
diff --git a/src/common/utils.hpp b/src/common/utils.hpp
--- a/src/common/utils.hpp	5fedcf0138c
+++ b/src/common/utils.hpp	c531afd7812
@@ -25,6 +25,15 @@
 /// Apply rate for val, divided by per
 #define apply_rate2(val, rate, per) (((rate) == (per)) ? (val) : ((val) > 100000) ? ((val) / (per) * (rate)) : ((val) * (rate) / (per)))
 
+#define add2limit(a, b, max) \
+	do { \
+		if( (max - a) < b ) { \
+			a = max; \
+		} else { \
+			a += b; \
+		} \
+	} while(0)
+
 /// calculates the value of A / B, in percent (rounded down)
 unsigned int get_percentage(const unsigned int A, const unsigned int B);
 uint32 get_percentage_exp(const uint64 a, const uint64 b);
Index: src/custom/atcommand.inc
===================================================================
diff --git a/src/custom/atcommand.inc b/src/custom/atcommand.inc
--- a/src/custom/atcommand.inc	9dd4a3856ce
+++ b/src/custom/atcommand.inc	1178dd04297
@@ -17,3 +17,258 @@
 //	clif_specialeffect(&sd->bl, EF_HEARTCASTING, AREA);
 //	return 0;
 //}
+
+/*==========================================
+* Battleground Leader Commands
+*------------------------------------------*/
+ACMD_FUNC(order)
+{
+	nullpo_retr(-1,sd);
+	memset(atcmd_output, '\0', sizeof(atcmd_output));
+	if( !message || !*message )
+	{
+		clif_displaymessage(fd, "Please, enter a message (usage: @order <message>).");
+		return -1;
+	}
+ 
+	if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) )
+	{
+		if( !sd->bmaster_flag )
+		{
+			clif_displaymessage(fd, "This command is reserved for Team Leaders Only.");
+			return -1;
+		}
+		if (battle_config.bg_order_behavior)
+			sprintf(atcmd_output, "%s: %s", sd->status.name, message);
+		else
+			sprintf(atcmd_output, "Team Leader: %s", message);
+		clif_broadcast2(&sd->bl, atcmd_output, (int)strlen(atcmd_output)+1, sd->bmaster_flag->color, 0x190, 20, 0, 0, BG);
+	}
+	else
+	{
+		if( !sd->state.gmaster_flag )
+		{
+			clif_displaymessage(fd, "This command is reserved for Guild Leaders Only.");
+			return -1;
+		}
+		clif_broadcast2(&sd->bl, message, (int)strlen(message)+1, 0xFF0000, 0x190, 20, 0, 0, GUILD);
+	}
+
+	return 0;
+}
+
+ACMD_FUNC(leader)
+{
+	struct map_session_data *pl_sd = NULL;
+	nullpo_retr(-1,sd);
+	memset(atcmd_player_name, '\0', sizeof(atcmd_player_name));
+	
+	if (!message || !*message || sscanf(message, "%23[^\n]", atcmd_player_name) < 1) {
+		clif_displaymessage(fd,"Please enter a player name (usage: @leader <char name/ID>).");
+		return -1;
+	}
+
+	if( !sd->bmaster_flag )
+		clif_displaymessage(fd, "This command is reserved for Team Leaders Only.");
+	else if( sd->ud.skilltimer != INVALID_TIMER )
+		clif_displaymessage(fd, "Command not allow while casting a skill.");
+	else if( !message || !*message )
+		clif_displaymessage(fd, "Please, enter the new Leader name (usage: @leader <name>).");
+	else if((pl_sd=map_nick2sd(atcmd_player_name,true)) == NULL && (pl_sd=map_charid2sd(atoi(atcmd_player_name))) == NULL)
+		clif_displaymessage(fd, "Character not found.");
+	else if( sd->bg_id != pl_sd->bg_id )
+		clif_displaymessage(fd, "Destination Player is not in your Team.");
+	else if( sd == pl_sd )
+		clif_displaymessage(fd, "You are already the Team Leader.");
+	else
+	{ // Everytest OK!
+		sprintf(atcmd_output, "Team Leader transfered to [%s]", pl_sd->status.name);
+		clif_broadcast2(&sd->bl, atcmd_output, (int)strlen(atcmd_output)+1, sd->bmaster_flag->color, 0x190, 20, 0, 0, BG);
+
+		sd->bmaster_flag->leader_char_id = pl_sd->status.char_id;
+		pl_sd->bmaster_flag = sd->bmaster_flag;
+		sd->bmaster_flag = NULL;
+
+		clif_name_area(&sd->bl);
+		clif_name_area(&pl_sd->bl);
+		return 0;
+	}
+	return -1;
+}
+
+ACMD_FUNC(reportafk)
+{
+	struct map_session_data *pl_sd = NULL;
+	nullpo_retr(-1,sd);
+	memset(atcmd_player_name, '\0', sizeof(atcmd_player_name));
+	
+	if (!message || !*message || sscanf(message, "%23[^\n]", atcmd_player_name) < 1) {
+		clif_displaymessage(fd,"Please enter a player name (usage: @reportafk <char name/ID>).");
+		return -1;
+	}
+	if( !sd->bg_id )
+		clif_displaymessage(fd, "This command is reserved for Battleground Only.");
+	else if( !sd->bmaster_flag && battle_config.bg_reportafk_leaderonly )
+		clif_displaymessage(fd, "This command is reserved for Team Leaders Only.");
+	else if( !message || !*message )
+		clif_displaymessage(fd, "Please, enter the character name (usage: @reportafk <name>).");
+	else if((pl_sd=map_nick2sd(atcmd_player_name,true)) == NULL && (pl_sd=map_charid2sd(atoi(atcmd_player_name))) == NULL)
+		clif_displaymessage(fd, "Character not found");
+	else if( sd->bg_id != pl_sd->bg_id )
+		clif_displaymessage(fd, "Destination Player is not in your Team.");
+	else if( sd == pl_sd )
+		clif_displaymessage(fd, "You cannot kick yourself.");
+	else if( pl_sd->state.bg_afk == 0 )
+		clif_displaymessage(fd, "The player is not AFK on this Battleground.");
+	else
+	{ // Everytest OK!
+		struct battleground_data *bgd;
+		if( (bgd = bg_team_search(sd->bg_id)) == NULL )
+			return -1;
+
+		bg_team_leave(pl_sd,2);
+		clif_displaymessage(pl_sd->fd, "You have been kicked from Battleground because of your AFK status.");
+		pc_setpos(pl_sd,pl_sd->status.save_point.map,pl_sd->status.save_point.x,pl_sd->status.save_point.y,CLR_TELEPORT);
+
+		sprintf(atcmd_output, "- AFK [%s] Kicked by @reportafk command-", pl_sd->status.name);
+		clif_broadcast2(&sd->bl, atcmd_output, (int)strlen(atcmd_output)+1, bgd->color, 0x190, 20, 0, 0, BG);
+		return 0;
+	}
+	return -1;
+}
+
+ACMD_FUNC(listenbg)
+{
+	if (sd->state.bg_listen)
+	{
+		sd->state.bg_listen = 0;
+		clif_displaymessage(fd, "You will receive Battleground announcements");
+	}
+	else
+	{
+		sd->state.bg_listen = 1;
+		clif_displaymessage(fd, "You will not receive Battleground announcements.");
+	}
+
+	return 0;
+}
+
+/*==========================================
+* Guild Skill Usage for Guild Masters
+*------------------------------------------*/
+ACMD_FUNC(guildskill)
+{
+	int i, skillnum = 0, skilllv = 1;
+	t_tick tick = gettick();
+	struct guild *g;
+	char output[128];
+	
+	const struct { char skillstr[3]; int id; } skills[] = {
+		{ "BO",	10010 },
+		{ "RG",	10011 },
+		{ "RS",	10012 },
+		{ "EC",	10013 },
+	};
+	
+	for( i = 0; i < ARRAYLENGTH(skills); i++ )
+	{
+		if( strncmpi(message, skills[i].skillstr, 3) == 0 )
+		{
+			skillnum = skills[i].id;
+			break;
+		}
+	}
+	if( !skillnum )
+	{
+		clif_displaymessage(fd, "Invalid Skill string. Use @guildskill EC/RS/RG/BO");
+		return -1;
+	}
+	
+	if( map_getmapflag(sd->bl.m, MF_GVG_CASTLE) ||map_getmapflag(sd->bl.m, MF_BATTLEGROUND) ){
+		if( sd->state.gmaster_flag && (g = sd->guild) != NULL ){
+			if(guild_checkskill(g, skillnum) < 1){
+				skilllv = 0;
+				sprintf(output, "The guild does not have the skill %s.", skill_get_desc(skillnum));
+				clif_displaymessage(sd->fd, output);
+			}
+		} else {
+			clif_displaymessage(fd, "This command is reserved for Guild Leaders Only.");
+			return -1;
+		}	
+	}
+	else
+	{
+		clif_displaymessage(fd, "This command is only available for Castles.");
+		return -1;		
+	}
+	
+	if( pc_cant_act(sd) || pc_issit(sd) || skill_isNotOk(skillnum, sd) || sd->ud.skilltimer != -1 || sd->sc.option&(OPTION_WEDDING|OPTION_XMAS|OPTION_SUMMER) || sd->sc.data[SC_BASILICA] )
+		return -1;
+	
+	if( DIFF_TICK(tick, sd->ud.canact_tick) < 0 )
+		return -1;
+
+	if( sd->menuskill_id )
+	{
+		if( sd->menuskill_id == SA_TAMINGMONSTER )
+			sd->menuskill_id = sd->menuskill_val = 0; //Cancel pet capture.
+		else if( sd->menuskill_id != SA_AUTOSPELL )
+			return -1; //Can't use skills while a menu is open.
+	}
+	
+	sd->skillitem = sd->skillitemlv = 0;
+	if( skilllv ) unit_skilluse_id(&sd->bl, sd->bl.id, skillnum, skilllv);
+	return 0;
+}
+
+ACMD_FUNC(bgrank)
+{
+	int i;
+
+	clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "============ BATTLEGROUND RANK ============", false, SELF);
+	for( i = 0; i < MAX_FAME_LIST; i++ )
+	{
+		if (!bg_fame_list[i].id)
+			sprintf(atcmd_output,"[ %d ] None        :    0 POINT",i+1);
+		else
+			sprintf(atcmd_output,"[ %d ] %s        :    %d POINT",i+1,bg_fame_list[i].name,bg_fame_list[i].fame);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], atcmd_output, false, SELF);
+	}
+	sprintf(atcmd_output,"MY POINT    :    %d POINT",sd->status.bgstats.points);
+	clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "===========================================", false, SELF);
+	clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], atcmd_output, false, SELF);
+	clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "===========================================", false, SELF);
+	return 0;
+}
+
+ACMD_FUNC(woerank)
+{
+	int i;
+
+	clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], "============ WAR OF EMPERIUM RANK ============", false, SELF);
+	for( i = 0; i < MAX_FAME_LIST; i++ )
+	{
+		if (!woe_fame_list[i].id)
+			sprintf(atcmd_output,"[ %d ] None        :    0 POINT",i+1);
+		else
+			sprintf(atcmd_output,"[ %d ] %s        :    %d POINT",i+1,woe_fame_list[i].name,woe_fame_list[i].fame);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], atcmd_output, false, SELF);
+	}
+	sprintf(atcmd_output,"MY POINT    :    %d POINT",sd->status.wstats.points);
+	clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], "===========================================", false, SELF);
+	clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], atcmd_output, false, SELF);
+	clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], "===========================================", false, SELF);
+	return 0;
+}
+
+ACMD_FUNC(bgstats)
+{
+	pc_battle_stats(sd,sd,1);
+	return 0;
+}
+
+ACMD_FUNC(woestats)
+{
+	pc_battle_stats(sd,sd,2);
+	return 0;
+}
Index: src/custom/atcommand_def.inc
===================================================================
diff --git a/src/custom/atcommand_def.inc b/src/custom/atcommand_def.inc
--- a/src/custom/atcommand_def.inc	54d9e74ba57
+++ b/src/custom/atcommand_def.inc	faae8d1ac85
@@ -9,3 +9,12 @@
  **/
 
 //ACMD_DEF(newcommand),
+	ACMD_DEF(listenbg),
+	ACMD_DEF(order),
+	ACMD_DEF(leader),
+	ACMD_DEF(reportafk),
+	ACMD_DEF(guildskill),
+	ACMD_DEF(bgrank),
+	ACMD_DEF(woerank),
+	ACMD_DEF(bgstats),
+	ACMD_DEF(woestats),
\ No newline at end of file
Index: src/custom/battle_config_init.inc
===================================================================
diff --git a/src/custom/battle_config_init.inc b/src/custom/battle_config_init.inc
--- a/src/custom/battle_config_init.inc	e47aca9be3b
+++ b/src/custom/battle_config_init.inc	392a067305e
@@ -11,3 +11,23 @@
  *	 { "name", &battle_config.<variable name>, <default value>, <minimum value>, <maximum value> },
  **/
 
+	{ "bg_eAmod_mode",                      &battle_config.bg_eAmod_mode,                   1,      0,      1,              },
+	{ "bg_idle_announce",                   &battle_config.bg_idle_announce,                0,      0,      INT_MAX,        },
+	{ "bg_idle_autokick",                   &battle_config.bg_idle_autokick,                0,      0,      INT_MAX,        },
+	{ "bg_reward_rates",                    &battle_config.bg_reward_rates,                 100,    0,      INT_MAX,        },
+	{ "bg_reportafk_leaderonly",            &battle_config.bg_reportafk_leaderonly,         1,      0,      1,              },
+	{ "bg_queue2team_balanced",             &battle_config.bg_queue2team_balanced,          1,      0,      1,              },
+	{ "bg_queue_onlytowns",                 &battle_config.bg_queue_onlytowns,              1,      0,      1,              },
+	{ "bg_order_behavior",                  &battle_config.bg_order_behavior,               1,      0,      1,              },
+	{ "bg_reserved_char_id",                &battle_config.bg_reserved_char_id,             999996, 0,      INT_MAX,        },
+	{ "woe_reserved_char_id",				&battle_config.woe_reserved_char_id,            999997, 0,      INT_MAX,        },
+	{ "bg_can_trade",				        &battle_config.bg_can_trade,                    1,      0,      1,              },
+	{ "bg_double_login",				    &battle_config.bg_double_login,                 1,      0,      1,              },
+	{ "bg_team_color",				        &battle_config.bg_team_color,                   1,      0,      1,              },
+	{ "bg_party_skills",				    &battle_config.bg_party_skills,                 1,      0,      1,              },
+	{ "bg_join_location",				    &battle_config.bg_join_location,                1,      0,      1,              },
+	{ "bg_team_ccolor_blue",				&battle_config.bg_team_ccolor_blue,           376,      0,      INT_MAX,        },
+	{ "bg_team_ccolor_red",				    &battle_config.bg_team_ccolor_red,            409,      0,      INT_MAX,        },
+	{ "bg_team_ccolor_green",				&battle_config.bg_team_ccolor_green,          390,      0,      INT_MAX,        },
+	{ "bg_extended_check_equip",			&battle_config.bg_extended_check_equip,         1,      0,      1,              },
+	{ "bg_queue_interface",					&battle_config.bg_queue_interface,              1,      0,      1,              },
Index: src/custom/battle_config_struct.inc
===================================================================
diff --git a/src/custom/battle_config_struct.inc b/src/custom/battle_config_struct.inc
--- a/src/custom/battle_config_struct.inc	017d99d07a7
+++ b/src/custom/battle_config_struct.inc	0bb5b6400f5
@@ -12,3 +12,23 @@
  *	 <datatype> name;
  **/
 
+	int bg_idle_announce;
+	int bg_idle_autokick;
+	int bg_reportafk_leaderonly;
+	int bg_queue2team_balanced;
+	int bg_reward_rates;
+	int bg_queue_onlytowns;
+	int bg_order_behavior;
+	int bg_eAmod_mode;
+	int bg_reserved_char_id;
+	int woe_reserved_char_id;
+	int bg_can_trade;
+	int bg_double_login;
+	int bg_team_color;
+	int bg_party_skills;
+	int bg_join_location;
+	int bg_team_ccolor_blue;
+	int bg_team_ccolor_red;
+	int bg_team_ccolor_green;
+	int bg_extended_check_equip;
+	int bg_queue_interface;
Index: src/map/achievement.cpp
===================================================================
diff --git a/src/map/achievement.cpp b/src/map/achievement.cpp
--- a/src/map/achievement.cpp	766414b012b
+++ b/src/map/achievement.cpp	b7c0f895aad
@@ -979,6 +979,27 @@
 			changed = true;
 			complete = true;
 			break;
+		case AG_BG_WIN:
+		case AG_BG_LOSE:
+		case AG_BG_TIE:
+		case AG_BG_KILL:
+		case AG_BG_DIE:
+		case AG_BG_DAMAGE:
+		case AG_BG_HEAL:
+		case AG_WOE_KILL:
+		case AG_WOE_DIE:
+		case AG_WOE_DAMAGE:
+		case AG_WOE_HEAL:
+			if (group == AG_BG_DAMAGE || group == AG_WOE_DAMAGE)
+				current_count[0] = update_count[0];
+			else
+				current_count[0] += update_count[0];
+			changed = true;			
+			for (const auto &it : ad->targets) {
+				if (current_count[it.first] >= it.second->count)
+					complete = true;
+			}
+			break;
 		case AG_SPEND_ZENY:
 			if (ad->targets.empty() || !ad->condition)
 				return false;
Index: src/map/achievement.hpp
===================================================================
diff --git a/src/map/achievement.hpp b/src/map/achievement.hpp
--- a/src/map/achievement.hpp	cd0a4b1bb2c
+++ b/src/map/achievement.hpp	c66f81abc3c
@@ -41,6 +41,17 @@
 	AG_ENCHANT_SUCCESS,
 	AG_SPEND_ZENY,
 	AG_TAMING,
+	AG_BG_WIN,
+	AG_BG_LOSE,
+	AG_BG_TIE,
+	AG_BG_KILL,
+	AG_BG_DIE,
+	AG_BG_DAMAGE,
+	AG_BG_HEAL,
+	AG_WOE_KILL,
+	AG_WOE_DIE,
+	AG_WOE_DAMAGE,
+	AG_WOE_HEAL,
 	AG_MAX
 };
 
Index: src/map/atcommand.cpp
===================================================================
diff --git a/src/map/atcommand.cpp b/src/map/atcommand.cpp
--- a/src/map/atcommand.cpp	9cf116c34ac
+++ b/src/map/atcommand.cpp	b686078b108
@@ -26,6 +26,7 @@
 
 #include "achievement.hpp"
 #include "battle.hpp"
+#include "battleground.hpp"
 #include "channel.hpp"
 #include "chat.hpp"
 #include "chrif.hpp"
@@ -4035,18 +4036,10 @@
 			pc_close_npc(pl_sd,1);
 			clif_cutin(pl_sd, "", 255);
 			pl_sd->state.block_action &= ~(PCBLOCK_ALL ^ PCBLOCK_IMMUNE);
-			bg_queue_leave(pl_sd);
 		}
+		
 		mapit_free(iter);
 
-		for (auto &bg : bg_queues) {
-				for (auto &bg_sd : bg->teama_members)
-					bg_team_leave(bg_sd, false, false); // Kick Team A from battlegrounds
-				for (auto &bg_sd : bg->teamb_members)
-					bg_team_leave(bg_sd, false, false); // Kick Team B from battlegrounds
-				bg_queue_clear(bg, true);
-		}
-
 		flush_fifos();
 		map_reloadnpc(true); // reload config files seeking for npcs
 		script_reload();
Index: src/map/battle.cpp
===================================================================
diff --git a/src/map/battle.cpp b/src/map/battle.cpp
--- a/src/map/battle.cpp	d7738fa543d
+++ b/src/map/battle.cpp	ab9eb821ee5
@@ -1807,34 +1807,6 @@
 	return damage;
 }
 
-/**
- * Determines whether battleground target can be hit
- * @param src: Source of attack
- * @param bl: Target of attack
- * @param skill_id: Skill ID used
- * @param flag: Special flags
- * @return Can be hit (true) or can't be hit (false)
- */
-bool battle_can_hit_bg_target(struct block_list *src, struct block_list *bl, uint16 skill_id, int flag)
-{
-	struct mob_data* md = BL_CAST(BL_MOB, bl);
-	struct unit_data *ud = unit_bl2ud(bl);
-
-	if (ud && ud->immune_attack)
-		return false;
-	if (md && md->bg_id) {
-		if (status_bl_has_mode(bl, MD_SKILLIMMUNE) && flag&BF_SKILL) //Skill immunity.
-			return false;
-		if (src->type == BL_PC) {
-			struct map_session_data *sd = map_id2sd(src->id);
-
-			if (sd && sd->bg_id == md->bg_id)
-				return false;
-		}
-	}
-	return true;
-}
-
 /**
  * Calculates BG related damage adjustments.
  * @param src
@@ -1853,9 +1825,6 @@
 	if( !damage )
 		return 0;
 
-	if (!battle_can_hit_bg_target(src, bl, skill_id, flag))
-		return 0;
-
 	if(skill_get_inf2(skill_id, INF2_IGNOREBGREDUCTION))
 		return damage; //skill that ignore bg map reduction
 
@@ -2518,10 +2487,13 @@
 
 	int members = 0;
 
-	if (!sd || !sd->status.party_id)
+	if (!sd || (!sd->status.party_id && !sd->bg_id))
 		return 0;
 
-	members = party_foreachsamemap(party_sub_count_class, sd, 0, MAPID_THIRDMASK, MAPID_MINSTRELWANDERER);
+	if (battle_config.bg_party_skills && sd->bg_id)
+		members = bg_team_foreachsamemap(party_sub_count_class, sd, 0, MAPID_THIRDMASK, MAPID_MINSTRELWANDERER);
+	else
+		members = party_foreachsamemap(party_sub_count_class, sd, 0, MAPID_THIRDMASK, MAPID_MINSTRELWANDERER);
 
 	if (members < 3)
 		return 0; // Bonus remains 0 unless 3 or more Minstrels/Wanderers are in the party.
@@ -8498,6 +8470,8 @@
 		{
 			sbg_id = bg_team_get_id(s_bl);
 			tbg_id = bg_team_get_id(t_bl);
+			if (battle_config.bg_party_skills && flag&(BCT_PARTY) && sbg_id == tbg_id)
+				state |= BCT_PARTY;
 		}
 		if( flag&(BCT_PARTY|BCT_ENEMY) )
 		{
@@ -9144,8 +9118,6 @@
 	{ "hom_idle_no_share",                  &battle_config.hom_idle_no_share,               0,      0,      INT_MAX,        },
 	{ "idletime_hom_option",                &battle_config.idletime_hom_option,             0x1F,   0x1,    0xFFF,          },
 	{ "devotion_standup_fix",               &battle_config.devotion_standup_fix,            1,      0,      1,              },
-	{ "feature.bgqueue",                    &battle_config.feature_bgqueue,                 1,      0,      1,              },
-	{ "bgqueue_nowarp_mapflag",             &battle_config.bgqueue_nowarp_mapflag,          0,      0,      1,              },
 	{ "homunculus_exp_gain",                &battle_config.homunculus_exp_gain,             10,     0,      100,            },
 	{ "rental_item_novalue",                &battle_config.rental_item_novalue,             1,      0,      1,              },
 	{ "ping_timer_inverval",                &battle_config.ping_timer_interval,             30,     0,      99999999,       },
@@ -9250,13 +9222,6 @@
 	}
 #endif
 
-#if PACKETVER < 20120101
-	if (battle_config.feature_bgqueue) {
-		ShowWarning("conf/battle/feature.conf:bgqueue is enabled but it requires PACKETVER 2012-01-01 or newer, disabling...\n");
-		battle_config.feature_bgqueue = 0;
-	}
-#endif
-
 #if PACKETVER > 20120000 && PACKETVER < 20130515 /* Exact date (when it started) not known */
 	if (battle_config.feature_auction) {
 		ShowWarning("conf/battle/feature.conf:feature.auction is enabled but it is not stable on PACKETVER " EXPAND_AND_QUOTE(PACKETVER) ", disabling...\n");
Index: src/map/battle.hpp
===================================================================
diff --git a/src/map/battle.hpp b/src/map/battle.hpp
--- a/src/map/battle.hpp	7031eecf656
+++ b/src/map/battle.hpp	1a414d722cf
@@ -675,8 +675,6 @@
 	int hom_idle_no_share;
 	int idletime_hom_option;
 	int devotion_standup_fix;
-	int feature_bgqueue;
-	int bgqueue_nowarp_mapflag;
 	int homunculus_exp_gain;
 	int rental_item_novalue;
 	int ping_timer_interval;
Index: src/map/battleground.cpp
===================================================================
diff --git a/src/map/battleground.cpp b/src/map/battleground.cpp
--- a/src/map/battleground.cpp	fb17f588460
+++ b/src/map/battleground.cpp	0b4180140b3
@@ -3,644 +3,599 @@
 
 #include "battleground.hpp"
 
-#include <unordered_map>
-#include <yaml-cpp/yaml.h>
-
 #include "../common/cbasetypes.hpp"
 #include "../common/malloc.hpp"
 #include "../common/nullpo.hpp"
-#include "../common/random.hpp"
 #include "../common/showmsg.hpp"
 #include "../common/strlib.hpp"
+#include "../common/socket.hpp"
 #include "../common/timer.hpp"
-#include "../common/utilities.hpp"
+#include "../common/utils.hpp"
 
+#include "achievement.hpp"
 #include "battle.hpp"
 #include "clif.hpp"
+#include "elemental.hpp"
 #include "guild.hpp"
 #include "homunculus.hpp"
-#include "mapreg.hpp"
+#include "log.hpp"
 #include "mercenary.hpp"
 #include "mob.hpp"
 #include "npc.hpp"
-#include "party.hpp"
 #include "pc.hpp"
 #include "pet.hpp"
+#include "quest.hpp"
+#include "skill.hpp"
+
+static DBMap* bg_team_db; // int bg_id -> struct battleground_data
+static DBMap* bg_queue_db;
+static unsigned int bg_team_counter = 0; // Next bg_id
+
+struct guild bg_guild[13]; // Temporal fake guild information
+const unsigned int bg_colors[13] = { 0x0000FF, 0xFF0000, 0x00FF00, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF, 0xFFFFFF };
+static unsigned int queue_counter = 0; // Next q_id
+ 
+#define BLUE_SKULL 8965
+#define RED_SKULL 8966
+#define GREEN_SKULL 8967
+
+int bg_member_removeskulls(struct map_session_data *sd)
+{
+	int n;
+	nullpo_ret(sd);
+	if( (n = pc_search_inventory(sd,BLUE_SKULL)) >= 0 )
+		pc_delitem(sd,n,sd->inventory.u.items_inventory[n].amount,0,2,LOG_TYPE_OTHER);
+	if( (n = pc_search_inventory(sd,RED_SKULL)) >= 0 )
+		pc_delitem(sd,n,sd->inventory.u.items_inventory[n].amount,0,2,LOG_TYPE_OTHER);
+	if( (n = pc_search_inventory(sd,GREEN_SKULL)) >= 0 )
+		pc_delitem(sd,n,sd->inventory.u.items_inventory[n].amount,0,2,LOG_TYPE_OTHER);
 
-using namespace rathena;
+	return 1;
+}
 
-BattlegroundDatabase battleground_db;
-std::unordered_map<int, std::shared_ptr<s_battleground_data>> bg_team_db;
-std::vector<std::shared_ptr<s_battleground_queue>> bg_queues;
-int bg_queue_count = 1;
+struct battleground_data* bg_team_search(int bg_id)
+{ // Search a BG Team using bg_id
+	if( !bg_id )
+		return NULL;
 
-const std::string BattlegroundDatabase::getDefaultLocation() {
-	return std::string(db_path) + "/battleground_db.yml";
+	return (struct battleground_data *)idb_get(bg_team_db, bg_id);
 }
 
-/**
- * Reads and parses an entry from the battleground_db
- * @param node: The YAML node containing the entry
- * @return count of successfully parsed rows
- */
-uint64 BattlegroundDatabase::parseBodyNode(const YAML::Node &node) {
-	uint32 id;
+int bg_countlogin(struct map_session_data *sd, bool check_bat_room)
+{
+	int c = 0, m = map_mapname2mapid("bat_room");
+	struct map_session_data* pl_sd;
+	struct s_mapiterator* iter;
+	nullpo_ret(sd);
+
+	iter = mapit_getallusers();
+	for (pl_sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); pl_sd = (TBL_PC*)mapit_next(iter))
+	{
+		if (!(pl_sd->qd || map_getmapflag(pl_sd->bl.m, MF_BATTLEGROUND) || (check_bat_room && pl_sd->bl.m == m)))
+			continue;
+		if( session[sd->fd]->client_addr == session[pl_sd->fd]->client_addr )
+			c++;
+	}
+	mapit_free(iter);
+	return c;
+}
 
-	if (!this->asUInt32(node, "Id", id))
+int bg_checkskill(struct battleground_data *bg, int id)
+{
+	int idx = id - GD_SKILLBASE;
+	if( idx < 0 || idx >= MAX_GUILDSKILL-1 || !bg->g )
 		return 0;
+	return bg->g->skill[idx].lv;
+}
 
-	std::shared_ptr<s_battleground_type> bg = this->find(id);
-	bool exists = bg != nullptr;
+TIMER_FUNC(bg_block_skill_end)
+{
+	struct battleground_data *bg;
+	char output[128];
+	int idx = (int)data - GD_SKILLBASE;
 
-	if (!exists) {
-		if (!this->nodesExist(node, { "Name", "Locations" }))
-			return 0;
+	if( (bg = bg_team_search(id)) == NULL )
+		return 1;
 
-		bg = std::make_shared<s_battleground_type>();
-		bg->id = id;
+	if( idx < 0 || idx >= MAX_GUILDSKILL-1 )
+	{
+		ShowError("bg_block_skill_end invalid skillnum %d.\n", (int)data);
+		return 0;
 	}
 
-	if (this->nodeExists(node, "Name")) {
-		std::string name;
-
-		if (!this->asString(node, "Name", name))
-			return 0;
-
-		name.resize(NAME_LENGTH);
-		bg->name = name;
+	if( tid != bg->skill_block_timer[idx] )
+	{
+		ShowError("bg_block_skill_end %d != %d.\n", bg->skill_block_timer[idx], tid);
+		return 0;
 	}
 
-	if (this->nodeExists(node, "MinPlayers")) {
-		int min;
-
-		if (!this->asInt32(node, "MinPlayers", min))
-			return 0;
-
-		if (min < 1) {
-			this->invalidWarning(node["MinPlayers"], "Minimum players %d cannot be less than 1, capping to 1.\n", min);
-			min = 1;
-		}
-
-		if (min * 2 > MAX_BG_MEMBERS) {
-			this->invalidWarning(node["MinPlayers"], "Minimum players %d exceeds MAX_BG_MEMBERS, capping to %d.\n", min, MAX_BG_MEMBERS / 2);
-			min = MAX_BG_MEMBERS / 2;
-		}
+	sprintf(output, "%s : Guild Skill %s Ready!!", bg->g->name, skill_get_desc((int)data));
+	clif_bg_message(bg, bg->bg_id, bg->g->name, output, strlen(output) + 1);
+	bg->skill_block_timer[idx] = INVALID_TIMER;
 
-		bg->required_players = min;
-	} else {
-		if (!exists)
-			bg->required_players = 1;
-	}
+	return 1;
+}
 
-	if (this->nodeExists(node, "MaxPlayers")) {
-		int max;
+void bg_block_skill_status(struct battleground_data *bg, int skillnum)
+{
+	const struct TimerData * td;
+	char output[128];
+	int idx;
+	t_tick seconds;
 
-		if (!this->asInt32(node, "MaxPlayers", max))
-			return 0;
+	idx = skillnum - GD_SKILLBASE;
+	if( bg == NULL || bg->g == NULL || idx < 0 || idx >= MAX_GUILDSKILL-1 || bg->skill_block_timer[idx] == INVALID_TIMER )
+		return;
 
-		if (max < 1) {
-			this->invalidWarning(node["MaxPlayers"], "Maximum players %d cannot be less than 1, capping to 1.\n", max);
-			max = 1;
-		}
+	if( (td = get_timer(bg->skill_block_timer[idx])) == NULL )
+		return;
 
-		if (max * 2 > MAX_BG_MEMBERS) {
-			this->invalidWarning(node["MaxPlayers"], "Maximum players %d exceeds MAX_BG_MEMBERS, capping to %d.\n", max, MAX_BG_MEMBERS / 2);
-			max = MAX_BG_MEMBERS / 2;
-		}
+	seconds = DIFF_TICK(td->tick,gettick())/1000;
+	sprintf(output, "%s : Cannot use team skill %s. %I64i seconds remaining................", bg->g->name, skill_get_desc(skillnum), seconds);
+	clif_bg_message(bg, bg->bg_id, bg->g->name, output, strlen(output) + 1);
+}
 
-		bg->max_players = max;
-	} else {
-		if (!exists)
-			bg->max_players = MAX_BG_MEMBERS / 2;
-	}
+void bg_block_skill_start(struct battleground_data *bgd, int skillnum, t_tick time)
+{
+	int idx = skillnum - GD_SKILLBASE;
+	if( bgd == NULL || idx < 0 || idx >= MAX_GUILDSKILL-1 )
+		return;
 
-	if (this->nodeExists(node, "MinLevel")) {
-		int min;
+	if( bgd->skill_block_timer[idx] != INVALID_TIMER )
+		delete_timer(bgd->skill_block_timer[idx], bg_block_skill_end);
 
-		if (!this->asInt32(node, "MinLevel", min))
-			return 0;
+	bgd->skill_block_timer[idx] = add_timer(gettick() + time, bg_block_skill_end, bgd->bg_id, skillnum);
+}
 
-		if (min > MAX_LEVEL) {
-			this->invalidWarning(node["MinLevel"], "Minimum level %d exceeds MAX_LEVEL, capping to %d.\n", min, MAX_LEVEL);
-			min = MAX_LEVEL;
-		}
+struct map_session_data* bg_getavailablesd(struct battleground_data *bg)
+{
+	int i;
 
-		bg->min_lvl = min;
-	} else {
-		if (!exists)
-			bg->min_lvl = 1;
-	}
+	nullpo_retr(NULL, bg);
 
-	if (this->nodeExists(node, "MaxLevel")) {
-		int max;
+	ARR_FIND(0, MAX_BG_MEMBERS, i, bg->members[i].sd != NULL);
 
-		if (!this->asInt32(node, "MaxLevel", max))
-			return 0;
+	return ( i < MAX_BG_MEMBERS ) ? bg->members[i].sd : NULL;
+}
 
-		if (max > MAX_LEVEL) {
-			this->invalidWarning(node["MaxLevel"], "Maximum level %d exceeds MAX_LEVEL, capping to %d.\n", max, MAX_LEVEL);
-			max = MAX_LEVEL;
+int bg_team_clean(int bg_id, bool remove)
+{ // Deletes BG Team from db
+ 	int i;
+	struct map_session_data *sd;
+ 	struct battleground_data *bgd = bg_team_search(bg_id);
+	struct guild *g;
+ 
+	if( bgd == NULL ) return 0;
+	for( i = 0; i < MAX_BG_MEMBERS; i++ )
+	{
+		if( (sd = bgd->members[i].sd) == NULL )
+ 			continue;
+ 
+ 		bg_send_dot_remove(sd);
+ 		sd->bg_id = 0;
+		sd->state.bg_afk = 0;
+		sd->bmaster_flag = NULL;
+		bg_member_removeskulls(sd);
+		
+		if (battle_config.bg_team_color && sd->bg_color)
+			pc_changelook(sd,LOOK_CLOTHES_COLOR,sd->bg_color-1);
+		
+		// Remove Guild Skill Buffs
+		status_change_end(&sd->bl,SC_GUILDAURA,INVALID_TIMER);
+		status_change_end(&sd->bl,SC_BATTLEORDERS,INVALID_TIMER);
+		status_change_end(&sd->bl,SC_REGENERATION,INVALID_TIMER);
+
+		if( !battle_config.bg_eAmod_mode )
+			continue; // No need to touch Guild stuff
+
+		if( sd->status.guild_id && (g = guild_search(sd->status.guild_id)) != NULL )
+		{
+			clif_guild_belonginfo(sd);
+			clif_guild_basicinfo(sd);
+			clif_guild_allianceinfo(sd);
+			clif_guild_memberlist(sd);
+			clif_guild_skillinfo(sd);
+			clif_guild_emblem(sd, g);
 		}
+		else
+			clif_bg_leave_single(sd, sd->status.name, "Leaving Battleground...");
 
-		bg->max_lvl = max;
-	} else {
-		if (!exists)
-			bg->max_lvl = MAX_LEVEL;
-	}
-
-	if (this->nodeExists(node, "Deserter")) {
-		uint32 deserter;
-
-		if (!this->asUInt32(node, "Deserter", deserter))
-			return 0;
+		clif_name_area(&sd->bl);
+		clif_guild_emblem_area(&sd->bl);
+ 	}
 
-		bg->deserter_time = deserter;
-	} else {
-		if (!exists)
-			bg->deserter_time = 600;
+	for( i = 0; i < MAX_GUILDSKILL-1; i++ )
+	{
+		if( bgd->skill_block_timer[i] == INVALID_TIMER )
+			continue;
+		delete_timer(bgd->skill_block_timer[i], bg_block_skill_end);
 	}
 
-	if (this->nodeExists(node, "StartDelay")) {
-		uint32 delay;
-
-		if (!this->asUInt32(node, "StartDelay", delay))
-			return 0;
-
-		bg->start_delay = delay;
-	} else {
-		if (!exists)
-			bg->start_delay = 0;
+	if( remove )
+		idb_remove(bg_team_db, bg_id);
+	else
+	{
+		bgd->count = 0;
+		bgd->leader_char_id = 0;
+		bgd->team_score = 0;
+		bgd->creation_tick = 0;
+		memset(&bgd->members, 0, sizeof(bgd->members));
 	}
 
-	if (this->nodeExists(node, "Join")) {
-		const YAML::Node &joinNode = node["Join"];
-
-		if (this->nodeExists(joinNode, "Solo")) {
-			bool active;
-
-			if (!this->asBool(joinNode, "Solo", active))
-				return 0;
-
-			bg->solo = active;
-		} else {
-			if (!exists)
-				bg->solo = true;
-		}
-
-		if (this->nodeExists(joinNode, "Party")) {
-			bool active;
+	return 1;
+}
 
-			if (!this->asBool(joinNode, "Party", active))
-				return 0;
+int bg_team_delete(int bg_id)
+{ // Deletes BG Team from db
+	int i;
+	struct battleground_data *bg = bg_team_search(bg_id);
 
-			bg->party = active;
-		} else {
-			if (!exists)
-				bg->party = true;
-		}
+	if( bg == NULL )
+		return 0;
 
-		if (this->nodeExists(joinNode, "Guild")) {
-			bool active;
+	for( i = 0; i < MAX_BG_MEMBERS; i++ ) {
+		struct map_session_data *sd;
 
-			if (!this->asBool(joinNode, "Guild", active))
-				return 0;
+		if( (sd = bg->members[i].sd) == NULL )
+			continue;
 
-			bg->guild = active;
-		} else {
-			if (!exists)
-				bg->guild = true;
-		}
-	} else {
-		if (!exists) {
-			bg->solo = true;
-			bg->party = true;
-			bg->guild = true;
-		}
+		bg_send_dot_remove(sd);
+		sd->bg_id = 0;
 	}
 
-	if (this->nodeExists(node, "JobRestrictions")) {
-		const YAML::Node &jobsNode = node["JobRestrictions"];
+	idb_remove(bg_team_db, bg_id);
 
-		for (const auto &jobit : jobsNode) {
-			std::string job_name = jobit.first.as<std::string>(), job_name_constant = "JOB_" + job_name;
-			int64 constant;
-
-			if (!script_get_constant(job_name_constant.c_str(), &constant)) {
-				this->invalidWarning(node["JobRestrictions"], "Job %s does not exist.\n", job_name.c_str());
-				continue;
-			}
+	return 1;
+}
 
-			bool active;
+int bg_team_warp(int bg_id, unsigned short mapindex, short x, short y)
+{ // Warps a Team
+	int i;
+	struct battleground_data *bg = bg_team_search(bg_id);
+	struct map_session_data *sd;
+	unsigned short m = mapindex_name2idx("bat_room", nullptr);
 
-			if (!this->asBool(jobsNode, job_name, active))
-				return 0;
+	if( bg == NULL )
+		return 0;
 
-			if (active)
-				bg->job_restrictions.push_back(static_cast<int32>(constant));
+	if( mapindex == 0 ) {
+		mapindex = bg->mapindex;
+		x = bg->x;
+		y = bg->y;
+	}
+	
+	for( i = 0; i < MAX_BG_MEMBERS; i++ ) {
+		if( (sd = bg->members[i].sd) == NULL )
+ 			continue;
+		if (mapindex == 2000) {
+			if (sd->bgentry.mapid)
+				pc_setpos(sd, sd->bgentry.mapid, sd->bgentry.x, sd->bgentry.y, CLR_TELEPORT);
 			else
-				util::vector_erase_if_exists(bg->job_restrictions, static_cast<int32>(constant));
+				pc_setpos(sd, m, 155, 150, CLR_TELEPORT);
+			continue;
 		}
+		pc_setpos(sd, mapindex, x, y, CLR_TELEPORT);
 	}
+	return 1;
+}
 
-	if (this->nodeExists(node, "Locations")) {
-		int count = 0;
-
-		for (const auto &locationit : node["Locations"]) {
-			const YAML::Node &location = locationit;
-			s_battleground_map map_entry;
-
-			if (this->nodeExists(location, "Map")) {
-				std::string map_name;
-
-				if (!this->asString(location, "Map", map_name))
-					return 0;
-
-				map_entry.mapindex = mapindex_name2id(map_name.c_str());
-
-				if (map_entry.mapindex == 0) {
-					this->invalidWarning(location["Map"], "Invalid battleground map name %s, skipping.\n", map_name.c_str());
-					return 0;
-				}
-			}
-
-			if (this->nodeExists(location, "StartEvent")) {
-				if (!this->asString(location, "StartEvent", map_entry.bgcallscript))
-					return 0;
-
-				map_entry.bgcallscript.resize(EVENT_NAME_LENGTH);
-
-				if (map_entry.bgcallscript.find("::On") == std::string::npos) {
-					this->invalidWarning(location["StartEvent"], "Battleground StartEvent label %s should begin with '::On', skipping.\n", map_entry.bgcallscript.c_str());
-					return 0;
-				}
-			}
-
-			std::vector<std::string> team_list = { "TeamA", "TeamB" };
-
-			for (const auto &it : team_list) {
-				const YAML::Node &team = location;
+int bg_reveal_pos(struct block_list *bl, va_list ap)
+{
+	struct map_session_data *pl_sd, *sd = NULL;
+	int flag, color;
 
-				if (this->nodeExists(team, it)) {
-					s_battleground_team *team_ptr;
+	pl_sd = (struct map_session_data *)bl;
+	sd = va_arg(ap,struct map_session_data *); // Source
+	flag = va_arg(ap,int);
+	color = va_arg(ap,int);
 
-					if (it.find("TeamA") != std::string::npos)
-						team_ptr = &map_entry.team1;
-					else if (it.find("TeamB") != std::string::npos)
-						team_ptr = &map_entry.team2;
-					else {
-						this->invalidWarning(team[it], "An invalid Team is defined.\n");
-						return 0;
-					}
+	if( pl_sd->bg_id == sd->bg_id )
+		return 0; // Same Team
 
-					if (this->nodeExists(team[it], "RespawnX")) {
-						if (!this->asInt16(team[it], "RespawnX", team_ptr->warp_x))
-							return 0;
-					}
+	clif_viewpoint(pl_sd,sd->bl.id,flag,sd->bl.x,sd->bl.y,sd->bl.id,color);
+	return 0;
+}
 
-					if (this->nodeExists(team[it], "RespawnY")) {
-						if (!this->asInt16(team[it], "RespawnY", team_ptr->warp_y))
-							return 0;
-					}
+int bg_team_sub_count(struct block_list *bl, va_list ap)
+{
+	struct map_session_data *sd = (TBL_PC *)bl;
 
-					if (this->nodeExists(team[it], "DeathEvent")) {
-						if (!this->asString(team[it], "DeathEvent", team_ptr->death_event))
-							return 0;
+	if (sd->state.autotrade)
+		return 0;
 
-						team_ptr->death_event.resize(EVENT_NAME_LENGTH);
+	return 1;
+}
 
-						if (team_ptr->death_event.find("::On") == std::string::npos) {
-							this->invalidWarning(team["DeathEvent"], "Battleground DeathEvent label %s should begin with '::On', skipping.\n", team_ptr->death_event.c_str());
-							return 0;
-						}
-					}
+/// Executes 'func' for each party member on the same map and in range (0:whole map)
+int bg_team_foreachsamemap(int (*func)(struct block_list*,va_list),struct map_session_data *sd,int range,...)
+{
+	struct battleground_data *bg;
+	int i;
+	int x0,y0,x1,y1;
+	struct block_list *list[MAX_BG_MEMBERS];
+	int blockcount=0;
+	int total = 0; //Return value.
 
-					if (this->nodeExists(team[it], "QuitEvent")) {
-						if (!this->asString(team[it], "QuitEvent", team_ptr->quit_event))
-							return 0;
+	nullpo_ret(sd);
 
-						team_ptr->quit_event.resize(EVENT_NAME_LENGTH);
+	if((bg = bg_team_search(sd->bg_id)) == NULL)
+		return 0;
 
-						if (team_ptr->quit_event.find("::On") == std::string::npos) {
-							this->invalidWarning(team["QuitEvent"], "Battleground QuitEvent label %s should begin with '::On', skipping.\n", team_ptr->quit_event.c_str());
-							return 0;
-						}
-					}
+	x0 = sd->bl.x-range;
+	y0 = sd->bl.y-range;
+	x1 = sd->bl.x+range;
+	y1 = sd->bl.y+range;
 
-					if (this->nodeExists(team[it], "ActiveEvent")) {
-						if (!this->asString(team[it], "ActiveEvent", team_ptr->active_event))
-							return 0;
+	for(i = 0; i < MAX_BG_MEMBERS; i++) {
+		struct map_session_data *pl_sd = bg->members[i].sd;
 
-						team_ptr->active_event.resize(EVENT_NAME_LENGTH);
+		if(!pl_sd)
+			continue;
 
-						if (team_ptr->active_event.find("::On") == std::string::npos) {
-							this->invalidWarning(team["ActiveEvent"], "Battleground ActiveEvent label %s should begin with '::On', skipping.\n", team_ptr->active_event.c_str());
-							return 0;
-						}
-					}
+		if(pl_sd->bl.m!=sd->bl.m || !pl_sd->bl.prev)
+			continue;
 
-					if (this->nodeExists(team[it], "Variable")) {
-						if (!this->asString(team[it], "Variable", team_ptr->bg_id_var))
-							return 0;
+		if(range &&
+			(pl_sd->bl.x<x0 || pl_sd->bl.y<y0 ||
+			 pl_sd->bl.x>x1 || pl_sd->bl.y>y1 ) )
+			continue;
 
-						team_ptr->bg_id_var.resize(NAME_LENGTH);
-					}
+		list[blockcount++]=&pl_sd->bl;
+	}
 
-					map_entry.id = count++;
-					map_entry.isReserved = false;
-				}
-			}
+	map_freeblock_lock();
 
-			bg->maps.push_back(map_entry);
-		}
+	for(i = 0; i < blockcount; i++) {
+		va_list ap;
+		va_start(ap, range);
+		total += func(list[i], ap);
+		va_end(ap);
 	}
 
-	if (!exists)
-		this->put(id, bg);
+	map_freeblock_unlock();
 
-	return 1;
+	return total;
 }
 
-/**
- * Search for a battleground based on the given name
- * @param name: Battleground name
- * @return s_battleground_type on success or nullptr on failure
- */
-std::shared_ptr<s_battleground_type> bg_search_name(const char *name)
-{
-	for (const auto &entry : battleground_db) {
-		auto bg = entry.second;
+int bg_send_dot_remove(struct map_session_data *sd) {
+	struct battleground_data *bgd;
+	int m;
 
-		if (!stricmp(bg->name.c_str(), name))
-			return bg;
+	if (sd && sd->bg_id && (bgd = bg_team_search(sd->bg_id)) != NULL)
+	{
+		clif_bg_xy_remove(sd);
+		if (bgd->reveal_pos && (m = map_mapindex2mapid(bgd->mapindex)) == sd->bl.m)
+			map_foreachinmap(bg_reveal_pos, m, BL_PC, sd, 2, 0xFFFFFF);
 	}
-
-	return nullptr;
+		clif_bg_xy_remove(sd);
+	return 0;
 }
 
-/**
- * Search for a Battleground queue based on the given queue ID
- * @param queue_id: Queue ID
- * @return s_battleground_queue on success or nullptr on failure
- */
-std::shared_ptr<s_battleground_queue> bg_search_queue(int queue_id)
-{
-	for (const auto &queue : bg_queues) {
-		if (queue_id == queue->queue_id)
-			return queue;
-	}
-
-	return nullptr;
-}
+int bg_team_join(int bg_id, struct map_session_data *sd)
+{ // Player joins team
+	int i;
+	struct battleground_data *bgd = bg_team_search(bg_id);
+	struct map_session_data *pl_sd;
 
-/**
- * Search for an available player in Battleground
- * @param bg: Battleground data
- * @return map_session_data
- */
-struct map_session_data* bg_getavailablesd(s_battleground_data *bg)
-{
-	nullpo_retr(nullptr, bg);
+	if( bgd == NULL || sd == NULL || sd->bg_id )
+		return 0;
 
-	for (const auto &member : bg->members) {
-		if (member.sd != nullptr)
-			return member.sd;
+	ARR_FIND(0, MAX_BG_MEMBERS, i, bgd->members[i].sd == NULL);
+	if( i == MAX_BG_MEMBERS )
+		return 0; // No free slots
+
+	pc_update_last_action(sd); // Start count from here...
+ 	sd->bg_id = bg_id;
+	sd->bg_kills = 0;
+	sd->state.bg_afk = 0;
+	sd->bgentry.mapid = 0;
+	sd->bgentry.x = 0;
+	sd->bgentry.y = 0;
+	bgd->members[i].sd = sd;
+	bgd->members[i].x = sd->bl.x;
+	bgd->members[i].y = sd->bl.y;
+	bgd->count++;
+
+	guild_send_dot_remove(sd);
+	if (bgd->creation_tick == 0) bgd->creation_tick = last_tick; // Creation Tick = First member joined.
+	
+	if( bgd->leader_char_id == 0 ) { // First Join = Team Leader
+		bgd->leader_char_id = sd->status.char_id;
+		sd->bmaster_flag = bgd;
 	}
 
-	return nullptr;
-}
-
-/**
- * Delete a Battleground team from the db
- * @param bg_id: Battleground ID
- * @return True on success or false otherwise
- */
-bool bg_team_delete(int bg_id)
-{
-	std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, bg_id);
-
-	if (bgteam) {
-		for (const auto &pl_sd : bgteam->members) {
-			bg_send_dot_remove(pl_sd.sd);
-			pl_sd.sd->bg_id = 0;
-		}
-
-		bg_team_db.erase(bg_id);
+	guild_send_dot_remove(sd);
+	
+	if( battle_config.bg_eAmod_mode )
+	{
+		clif_bg_belonginfo(sd);
+		clif_name_area(&sd->bl);
+		skill_blockpc_clear(sd);
+ 	}
+	
+	if (battle_config.bg_team_color && bgd->g->ccolor) {
+		sd->bg_color = sd->status.clothes_color+1;
+		pc_changelook(sd,LOOK_CLOTHES_COLOR,bgd->g->ccolor);
+	}
 
-		return true;
+	if (battle_config.bg_join_location && !map_getmapflag(sd->bl.m, MF_NOWARP)) {
+		sd->bgentry.mapid = sd->mapindex;
+		sd->bgentry.x = sd->bl.x;
+		sd->bgentry.y = sd->bl.y;
 	}
 	
-	return false;
-}
-
-/**
- * Warps a Battleground team
- * @param bg_id: Battleground ID
- * @param mapindex: Map Index
- * @param x: X coordinate
- * @param y: Y coordinate
- * @return True on success or false otherwise
- */
-bool bg_team_warp(int bg_id, unsigned short mapindex, short x, short y)
-{
-	std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, bg_id);
-
-	if (bgteam) {
-		for (const auto &pl_sd : bgteam->members)
-			pc_setpos(pl_sd.sd, mapindex, x, y, CLR_TELEPORT);
+	for (i = 0; i < MAX_BG_MEMBERS; i++)
+	{
+		if ((pl_sd = bgd->members[i].sd) == NULL)
+			continue;
 
-		return true;
-	}
+		if (battle_config.bg_eAmod_mode)
+		{ // Simulate Guild Information
+			clif_guild_basicinfo(pl_sd);
+			clif_bg_emblem(pl_sd, bgd->g);
+			clif_bg_memberlist(pl_sd);
+		}
 
-	return false;
-}
+		if ((pl_sd = bgd->members[i].sd) != NULL && pl_sd != sd)
+ 			clif_hpmeter_single(sd->fd, pl_sd->bl.id, pl_sd->battle_status.hp, pl_sd->battle_status.max_hp);
+ 	}
 
-/**
- * Remove a player's Battleground map marker
- * @param sd: Player data
- */
-void bg_send_dot_remove(struct map_session_data *sd)
-{
-	nullpo_retv(sd);
+	if (battle_config.bg_eAmod_mode) clif_guild_emblem_area(&sd->bl);
 
-	if( sd && sd->bg_id )
-		clif_bg_xy_remove(sd);
-	return;
+	clif_bg_hp(sd);
+	clif_bg_xy(sd);
+	if (battle_config.bg_queue_interface)
+		clif_bg_queue_entry_init(sd);
+	return 1;
 }
 
-/**
- * Join a player to a Battleground team
- * @param bg_id: Battleground ID
- * @param sd: Player data
- * @param is_queue: Joined from queue
- * @return True on success or false otherwise
- */
-bool bg_team_join(int bg_id, struct map_session_data *sd, bool is_queue)
-{
-	if (!sd || sd->bg_id)
-		return false;
-
-	std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, bg_id);
+int bg_team_leave(struct map_session_data *sd, int flag)
+{ // Single Player leaves team
+	int i;
+	struct battleground_data *bgd;
+	struct map_session_data *pl_sd;
+	struct guild *g;
+	char output[128];
 
-	if (bgteam) {
-		if (bgteam->members.size() == MAX_BG_MEMBERS)
-			return false; // No free slots
-
-		s_battleground_member_data member = {};
-
-		sd->bg_id = bg_id;
-		member.sd = sd;
-		member.x = sd->bl.x;
-		member.y = sd->bl.y;
-		if (is_queue) { // Save the location from where the person entered the battleground
-			member.entry_point.map = sd->mapindex;
-			member.entry_point.x = sd->bl.x;
-			member.entry_point.y = sd->bl.y;
-		}
-		bgteam->members.push_back(member);
-
-		guild_send_dot_remove(sd);
-
-		for (const auto &pl_sd : bgteam->members) {
-			if (pl_sd.sd != sd)
-				clif_hpmeter_single(sd->fd, pl_sd.sd->bl.id, pl_sd.sd->battle_status.hp, pl_sd.sd->battle_status.max_hp);
-		}
-
-		clif_bg_hp(sd);
-		clif_bg_xy(sd);
-		return true;
-	}
+	if( sd == NULL || !sd->bg_id )
+		return 0;
 
-	return false;
-}
+	bgd = bg_team_search(sd->bg_id);
+	if (bgd && bgd->logout_event[0] && flag)
+		npc_event(sd, bgd->logout_event, 0);
 
-/**
- * Remove a player from Battleground team
- * @param sd: Player data
- * @param quit: True if closed client or false otherwise
- * @param deserter: Whether to apply the deserter status or not
- * @return Remaining count in Battleground team or -1 on failure
- */
-int bg_team_leave(struct map_session_data *sd, bool quit, bool deserter)
-{
-	if (!sd || !sd->bg_id)
-		return -1;
+	// Packets
+	if (battle_config.bg_eAmod_mode) clif_bg_leave_single(sd, sd->status.name, "Leaving Battle...");
 
 	bg_send_dot_remove(sd);
-
-	int bg_id = sd->bg_id;
-	std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, bg_id);
-
 	sd->bg_id = 0;
-
-	if (bgteam) {
-		// Warping members out only applies to the Battleground Queue System
-		if (battle_config.feature_bgqueue) {
-			auto member = bgteam->members.begin();
-
-			while (member != bgteam->members.end()) {
-				if (member->sd == sd) {
-					if (member->entry_point.map != 0 && !map_getmapflag(map_mapindex2mapid(member->entry_point.map), MF_NOSAVE))
-						pc_setpos(sd, member->entry_point.map, member->entry_point.x, member->entry_point.y, CLR_TELEPORT);
-					else
-						pc_setpos(sd, sd->status.save_point.map, sd->status.save_point.x, sd->status.save_point.y, CLR_TELEPORT); // Warp to save point if the entry map has no save flag.
-
-					bgteam->members.erase(member);
-					break;
-				} else
-					member++;
-			}
+	sd->bg_kills = 0;
+	sd->state.bg_afk = 0;
+	sd->bmaster_flag = NULL;
+	bg_member_removeskulls(sd);
+	
+	if (battle_config.bg_team_color && sd->bg_color)
+		pc_changelook(sd,LOOK_CLOTHES_COLOR,sd->bg_color-1);
+	
+	// Remove Guild Skill Buffs
+	status_change_end(&sd->bl, SC_GUILDAURA, INVALID_TIMER);
+	status_change_end(&sd->bl, SC_BATTLEORDERS, INVALID_TIMER);
+	status_change_end(&sd->bl, SC_REGENERATION, INVALID_TIMER);
+	
+	if (battle_config.bg_eAmod_mode)
+	{ // Refresh Guild Information
+		if (sd->status.guild_id && (g = guild_search(sd->status.guild_id)) != NULL)
+		{
+			clif_guild_belonginfo(sd);
+			clif_guild_basicinfo(sd);
+			clif_guild_allianceinfo(sd);
+			clif_guild_memberlist(sd);
+			clif_guild_skillinfo(sd);
+			clif_guild_emblem(sd, g);
+		}
+		clif_name_area(&sd->bl);
+		clif_guild_emblem_area(&sd->bl);
+	}
+	
+	if (!bgd) return 0;
+
+	ARR_FIND(0, MAX_BG_MEMBERS, i, bgd->members[i].sd == sd);
+	if( i < MAX_BG_MEMBERS ) // Removes member from BG
+		memset(&bgd->members[i], 0, sizeof(bgd->members[0]));
+		if (bgd->leader_char_id == sd->status.char_id)
+			bgd->leader_char_id = 0;
+	for (i = 0; i < MAX_BG_MEMBERS; i++)
+	{ // Update other BG members
+		if ((pl_sd = bgd->members[i].sd) == NULL)
+			continue;
+		if (!bgd->leader_char_id)
+		{ // Set new Leader first on the list
+			bgd->leader_char_id = pl_sd->status.char_id;
+			pl_sd->bmaster_flag = bgd;
 		}
 
-		char output[CHAT_SIZE_MAX];
-
-		if (quit)
-			sprintf(output, "Server: %s has quit the game...", sd->status.name);
-		else
-			sprintf(output, "Server: %s is leaving the battlefield...", sd->status.name);
+		if (battle_config.bg_eAmod_mode)
+		{
+			switch (flag)
+			{
+			case 3: clif_bg_expulsion_single(pl_sd, sd->status.name, "Kicked by AFK Status..."); break;
+			case 2: clif_bg_expulsion_single(pl_sd, sd->status.name, "Kicked by AFK Report..."); break;
+			case 1: clif_bg_expulsion_single(pl_sd, sd->status.name, "User has quit the game..."); break;
+			case 0: clif_bg_leave_single(pl_sd, sd->status.name, "Leaving Battle..."); break;
+			}
 
-		clif_bg_message(bgteam.get(), 0, "Server", output, strlen(output) + 1);
+			clif_guild_basicinfo(pl_sd);
+			clif_bg_emblem(pl_sd, bgd->g);
+			clif_bg_memberlist(pl_sd);
+		}
+ 	}
 
-		if (!bgteam->logout_event.empty() && quit)
-			npc_event(sd, bgteam->logout_event.c_str(), 0);
+	bgd->count--;
 
-		if (deserter) {
-			std::shared_ptr<s_battleground_type> bg = battleground_db.find(bg_id);
+	if( flag )
+		sprintf(output, "Server : %s has quit the game...", sd->status.name);
+	else
+		sprintf(output, "Server : %s is leaving the battlefield...", sd->status.name);
 
-			if (bg)
-				sc_start(nullptr, &sd->bl, SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT, 100, 1, static_cast<t_tick>(bg->deserter_time) * 1000); // Deserter timer
-		}
+	clif_bg_message(bgd, 0, "Server", output, strlen(output) + 1);
 
-		return bgteam->members.size();
-	}
-
-	return -1;
+	return bgd->count;
 }
 
-/**
- * Respawn a Battleground player
- * @param sd: Player data
- * @return True on success or false otherwise
- */
-bool bg_member_respawn(struct map_session_data *sd)
-{
-	if (!sd || !sd->bg_id || !pc_isdead(sd))
-		return false;
-
-	std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, sd->bg_id);
+int bg_member_respawn(struct map_session_data *sd)
+{ // Respawn after killed
+	struct battleground_data *bg;
 
-	if (bgteam) {
-		if (bgteam->cemetery.map == 0)
-			return false; // Respawn not handled by Core
+	if( sd == NULL || !pc_isdead(sd) || !sd->bg_id || (bg = bg_team_search(sd->bg_id)) == NULL )
+		return 0;
 
-		pc_setpos(sd, bgteam->cemetery.map, bgteam->cemetery.x, bgteam->cemetery.y, CLR_OUTSIGHT);
-		status_revive(&sd->bl, 1, 100);
+	if( bg->mapindex == 0 )
+		return 0; // Respawn not handled by Core
 
-		return true; // Warped
-	}
+	pc_setpos(sd, bg->mapindex, bg->x, bg->y, CLR_OUTSIGHT);
+	status_revive(&sd->bl, 1, 100);
 
-	return false;
+	return 1; // Warped
 }
 
-/**
- * Initialize Battleground data
- * @param mapindex: Map Index
- * @param rx: Return X coordinate (on death)
- * @param ry: Return Y coordinate (on death)
- * @param ev: Logout NPC Event
- * @param dev: Death NPC Event
- * @return Battleground ID
- */
-int bg_create(uint16 mapindex, s_battleground_team* team)
+int bg_create(unsigned short mapindex, short rx, short ry, int guild_index, const char *ev, const char *dev)
 {
-	int bg_team_counter = 1;
-
-	while (bg_team_db.find(bg_team_counter) != bg_team_db.end())
-		bg_team_counter++;
-
-	bg_team_db[bg_team_counter] = std::make_shared<s_battleground_data>();
-
-	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_team_counter);
-
-	bg->id = bg_team_counter;
-	bg->cemetery.map = mapindex;
-	bg->cemetery.x = team->warp_x;
-	bg->cemetery.y = team->warp_y;
-	bg->logout_event = team->quit_event.c_str();
-	bg->die_event = team->death_event.c_str();
-	bg->active_event = team->active_event.c_str();
+	struct battleground_data *bg;
+	int i;
+	
+	if (++bg_team_counter <= 0) bg_team_counter = 1;
+
+	CREATE(bg, struct battleground_data, 1);
+	bg->bg_id = bg_team_counter;
+	bg->creation_tick = 0;
+	bg->count = 0;
+	bg->g = &bg_guild[guild_index];
+	bg->mapindex = mapindex;
+	bg->x = rx;
+	bg->y = ry;
+	bg->color = bg_colors[guild_index];
+	bg->pf_id = 0;
+	safestrncpy(bg->logout_event, ev, sizeof(bg->logout_event));
+	safestrncpy(bg->die_event, dev, sizeof(bg->die_event));
+	for( i = 0; i < MAX_GUILDSKILL-1; i++ )
+		bg->skill_block_timer[i] = INVALID_TIMER;
+
+	memset(&bg->members, 0, sizeof(bg->members));
+	idb_put(bg_team_db, bg_team_counter, bg);
+
+	return bg->bg_id;
+}
 
-	return bg->id;
+struct guild* bg_guild_get(int bg_id)
+{ // Return Fake Guild for BG Members
+	struct battleground_data *bg = bg_team_search(bg_id);
+	if( bg == NULL ) return NULL;
+	return bg->g;
 }
 
-/**
- * Get an object's Battleground ID
- * @param bl: Object
- * @return Battleground ID
- */
 int bg_team_get_id(struct block_list *bl)
 {
-	nullpo_ret(bl);
-
+	if (bl)
 	switch( bl->type ) {
 		case BL_PC:
 			return ((TBL_PC*)bl)->bg_id;
@@ -652,7 +607,7 @@
 			struct map_session_data *msd;
 			struct mob_data *md = (TBL_MOB*)bl;
 
-			if( md->special_state.ai && (msd = map_id2sd(md->master_id)) != nullptr )
+			if( md->special_state.ai && (msd = map_id2sd(md->master_id)) != NULL )
 				return msd->bg_id;
 
 			return md->bg_id;
@@ -665,6 +620,13 @@
 			if( ((TBL_MER*)bl)->master )
 				return ((TBL_MER*)bl)->master->bg_id;
 			break;
+		case BL_ELEM:
+			if( ((TBL_ELEM*)bl)->master )
+				return ((TBL_ELEM*)bl)->master->bg_id;
+			break;
+		case BL_NPC:
+			return ((TBL_NPC*)bl)->u.scr.bg_id;
+			break;
 		case BL_SKILL:
 			return ((TBL_SKILL*)bl)->group->bg_id;
 	}
@@ -672,899 +634,608 @@
 	return 0;
 }
 
-/**
- * Send a Battleground chat message
- * @param sd: Player data
- * @param mes: Message
- * @param len: Message length
- */
-void bg_send_message(struct map_session_data *sd, const char *mes, int len)
+int bg_send_message(struct map_session_data *sd, const char *mes, int len)
 {
-	nullpo_retv(sd);
+	struct battleground_data *bg;
 
-	if (sd->bg_id == 0)
-		return;
-	
-	std::shared_ptr<s_battleground_data> bgteam = util::umap_find(bg_team_db, sd->bg_id);
+	nullpo_ret(sd);
 
-	if (bgteam)
-		clif_bg_message(bgteam.get(), sd->bl.id, sd->status.name, mes, len);
+	if( sd->bg_id == 0 || (bg = bg_team_search(sd->bg_id)) == NULL )
+		return 0;
+	
+	clif_bg_message(bg, sd->bl.id, sd->status.name, mes, len);
 
-	return;
+	return 0;
 }
 
 /**
- * Update a player's Battleground minimap icon
  * @see DBApply
  */
-int bg_send_xy_timer_sub(std::shared_ptr<s_battleground_data> bg)
+int bg_send_xy_timer_sub(DBKey key, DBData *data, va_list ap)
 {
+	struct battleground_data *bgd = (struct battleground_data *)db_data2ptr(data);
 	struct map_session_data *sd;
+	char output[128];
+	int i, m, idle_announce = battle_config.bg_idle_announce,
+		idle_autokick = battle_config.bg_idle_autokick;
 
-	for (auto &pl_sd : bg->members) {
-		sd = pl_sd.sd;
-
-		if (sd->bl.x != pl_sd.x || sd->bl.y != pl_sd.y) { // xy update
-			pl_sd.x = sd->bl.x;
-			pl_sd.y = sd->bl.y;
-			clif_bg_xy(sd);
-		}
-	}
-
-	return 0;
-}
-
-/**
- * Update a player's Battleground minimap icon
- * @param tid: Timer ID
- * @param tick: Timer
- * @param id: ID
- * @return 0 on success or 1 otherwise
- */
-TIMER_FUNC(bg_send_xy_timer)
-{
-	for (const auto &entry : bg_team_db)
-		bg_send_xy_timer_sub(entry.second);
+	nullpo_ret(bgd);
+	m = map_mapindex2mapid(bgd->mapindex);
+	bgd->reveal_flag = !bgd->reveal_flag; // Switch
 
-	return 0;
-}
-
-/**
- * Mark a Battleground as ready to begin queuing for a free map
- * @param tid: Timer ID
- * @param tick: Timer
- * @param id: ID
- * @return 0 on success or 1 otherwise
- */
-static TIMER_FUNC(bg_on_ready_loopback)
-{
-	int queue_id = (int)data;
-	std::shared_ptr<s_battleground_queue> queue = bg_search_queue(queue_id);
-
-	if (queue == nullptr) {
-		ShowError("bg_on_ready_loopback: Invalid battleground queue %d.\n", queue_id);
-		return 1;
-	}
-
-	std::shared_ptr<s_battleground_type> bg = battleground_db.find(queue->id);
-
-	if (bg) {
-		bg_queue_on_ready(bg->name.c_str(), queue);
-		return 0;
-	} else {
-		ShowError("bg_on_ready_loopback: Can't find battleground %d in the battlegrounds database.\n", queue->id);
-		return 1;
-	}
-}
-
-/**
- * Reset Battleground queue data if players don't accept in time
- * @param tid: Timer ID
- * @param tick: Timer
- * @param id: ID
- * @return 0 on success or 1 otherwise
- */
-static TIMER_FUNC(bg_on_ready_expire)
-{
-	int queue_id = (int)data;
-	std::shared_ptr<s_battleground_queue> queue = bg_search_queue(queue_id);
+	for (i = 0; i < MAX_BG_MEMBERS; i++) {
+		if ((sd = bgd->members[i].sd) == NULL)
+			continue;
 
-	if (queue == nullptr) {
-		ShowError("bg_on_ready_expire: Invalid battleground queue %d.\n", queue_id);
-		return 1;
-	}
+		if (idle_autokick && DIFF_TICK(last_tick, sd->idletime) >= idle_autokick
+			&& bgd->g && map_getmapflag(sd->bl.m, MF_BATTLEGROUND))
+		{
+			sprintf(output, "[Battlegrounds] %s has been kicked for being AFK.", sd->status.name);
+			clif_broadcast2(&sd->bl, output, (int)strlen(output) + 1, bgd->color, 0x190, 20, 0, 0, BG);
 
-	std::string bg_name = battleground_db.find(queue->id)->name;
+			bg_team_leave(sd, 3);
 
-	for (const auto &sd : queue->teama_members) {
-		clif_bg_queue_apply_result(BG_APPLY_QUEUE_FINISHED, bg_name.c_str(), sd);
-		clif_bg_queue_entry_init(sd);
-	}
-
-	for (const auto &sd : queue->teamb_members) {
-		clif_bg_queue_apply_result(BG_APPLY_QUEUE_FINISHED, bg_name.c_str(), sd);
-		clif_bg_queue_entry_init(sd);
+			clif_displaymessage(sd->fd, "You have been kicked from Battleground because of your AFK status.");
+			pc_setpos(sd, sd->status.save_point.map, sd->status.save_point.x, sd->status.save_point.y, CLR_TELEPORT);
+			continue;
+		}
+		else if (sd->bl.x != bgd->members[i].x || sd->bl.y != bgd->members[i].y) { // xy update
+			bgd->members[i].x = sd->bl.x;
+			bgd->members[i].y = sd->bl.y;
+			clif_bg_xy(sd);
+		}
+		if (bgd->reveal_pos && bgd->reveal_flag && sd->bl.m == m)
+			map_foreachinmap(bg_reveal_pos, m, BL_PC, sd, 1, bgd->color);
+
+		// Message for AFK Idling
+		if (idle_announce && DIFF_TICK(last_tick, sd->idletime) >= idle_announce && !sd->state.bg_afk && bgd->g)
+		{ // Set AFK status and announce to the team.
+			sd->state.bg_afk = 1;
+			sprintf(output, "%s : %s seems to be away. AFK Warning - Can be kicked out with @reportafk.", bgd->g->name, sd->status.name);
+			clif_bg_message(bgd, bgd->bg_id, bgd->g->name, output, strlen(output) + 1);
+		}
 	}
-
-	bg_queue_clear(queue, true);
 	return 0;
 }
 
-/**
- * Start a Battleground when all players have accepted
- * @param tid: Timer ID
- * @param tick: Timer
- * @param id: ID
- * @return 0 on success or 1 otherwise
- */
-static TIMER_FUNC(bg_on_ready_start)
-{
-	int queue_id = (int)data;
-	std::shared_ptr<s_battleground_queue> queue = bg_search_queue(queue_id);
-
-	if (queue == nullptr) {
-		ShowError("bg_on_ready_start: Invalid battleground queue %d.\n", queue_id);
-		return 1;
-	}
-
-	queue->tid_start = INVALID_TIMER;
-	bg_queue_start_battleground(queue);
+TIMER_FUNC(bg_send_xy_timer){
+	bg_team_db->foreach(bg_team_db, bg_send_xy_timer_sub, tick);
 
 	return 0;
 }
 
-/**
- * Check if the given player is in a battleground
- * @param sd: Player data
- * @return True if in a battleground or false otherwise
- */
-bool bg_player_is_in_bg_map(struct map_session_data *sd)
+void bg_guild_build_data(void)
 {
-	nullpo_retr(false, sd);
-
-	for (const auto &pair : battleground_db) {
-		for (const auto &it : pair.second->maps) {
-			if (it.mapindex == sd->mapindex)
-				return true;
+	int i, j, k, skill;
+	memset(&bg_guild, 0, sizeof(bg_guild));
+	for( i = 1; i <= 13; i++ )
+	{ // Emblem Data - Guild ID's
+		FILE* fp = NULL;
+		char path[256];
+
+		j = i - 1;
+		bg_guild[j].emblem_id = 1; // Emblem Index
+		bg_guild[j].guild_id = SHRT_MAX - j;
+		bg_guild[j].guild_lv = 1;
+		bg_guild[j].max_member = MAX_BG_MEMBERS;
+
+		// Skills
+		if( j < 3 )
+		{ // Clan Skills
+			for( k = 0; k < MAX_GUILDSKILL-1; k++ )
+			{
+				skill = k + GD_SKILLBASE;
+				bg_guild[j].skill[k].id = skill;
+				switch( skill )
+				{
+				case GD_GLORYGUILD:
+					bg_guild[j].skill[k].lv = 0;
+					break;
+				case GD_APPROVAL:
+				case GD_KAFRACONTRACT:
+				case GD_GUARDRESEARCH:
+				case GD_BATTLEORDER:
+				case GD_RESTORE:
+				case GD_EMERGENCYCALL:
+				case GD_DEVELOPMENT:
+					bg_guild[j].skill[k].lv = 1;
+					break;
+				case GD_GUARDUP:
+				case GD_REGENERATION:
+					bg_guild[j].skill[k].lv = 3;
+					break;
+				case GD_LEADERSHIP:
+				case GD_GLORYWOUNDS:
+				case GD_SOULCOLD:
+				case GD_HAWKEYES:
+					bg_guild[j].skill[k].lv = 5;
+					break;
+				case GD_EXTENSION:
+					bg_guild[j].skill[k].lv = 10;
+					break;
+				}
+			}
 		}
-	}
-
-	return false;
-}
-
-/**
- * Battleground status change check
- * @param sd: Player data
- * @param name: Battleground name
- * @return True if the player is good to join a queue or false otherwise
- */
-static bool bg_queue_check_status(struct map_session_data* sd, const char *name)
-{
-	nullpo_retr(false, sd);
-
-	if (sd->sc.count) {
-		if (sd->sc.data[SC_ENTRY_QUEUE_APPLY_DELAY]) { // Exclude any player who's recently left a battleground queue
-			char buf[CHAT_SIZE_MAX];
-
-			sprintf(buf, msg_txt(sd, 339), static_cast<int32>((get_timer(sd->sc.data[SC_ENTRY_QUEUE_APPLY_DELAY]->timer)->tick - gettick()) / 1000)); // You can't apply to a battleground queue for %d seconds due to recently leaving one.
-			clif_bg_queue_apply_result(BG_APPLY_NONE, name, sd);
-			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], buf, false, SELF);
-			return false;
+		else
+		{ // Other Data
+			snprintf(bg_guild[j].name, NAME_LENGTH, "Team %d", i - 3); // Team 1, Team 2 ... Team 10
+			strncpy(bg_guild[j].master, bg_guild[j].name, NAME_LENGTH);
+			snprintf(bg_guild[j].position[0].name, NAME_LENGTH, "%s Leader", bg_guild[j].name);
+			strncpy(bg_guild[j].position[1].name, bg_guild[j].name, NAME_LENGTH);
 		}
 
-		if (sd->sc.data[SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT]) { // Exclude any player who's recently deserted a battleground
-			char buf[CHAT_SIZE_MAX];
-			int32 status_tick = static_cast<int32>(DIFF_TICK(get_timer(sd->sc.data[SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT]->timer)->tick, gettick()) / 1000);
-
-			sprintf(buf, msg_txt(sd, 338), status_tick / 60, status_tick % 60); // You can't apply to a battleground queue due to recently deserting a battleground. Time remaining: %d minutes and %d seconds.
-			clif_bg_queue_apply_result(BG_APPLY_NONE, name, sd);
-			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], buf, false, SELF);
-			return false;
+		sprintf(path, "%s/emblems/bg_%d.ebm", db_path, i);
+		if( (fp = fopen(path, "rb")) != NULL )
+		{
+			fseek(fp, 0, SEEK_END);
+			bg_guild[j].emblem_len = ftell(fp);
+			fseek(fp, 0, SEEK_SET);
+			if (fread(&bg_guild[j].emblem_data, 1, bg_guild[j].emblem_len, fp) == bg_guild[j].emblem_len) {
+				fclose(fp);
+				ShowStatus("Done reading '%s' emblem data file.\n", path);
+			} else
+				ShowStatus("Failed to read '%s'.\n", path); // Never happen
 		}
 	}
 
-	return true;
+	// Guild Data - Guillaume
+	strncpy(bg_guild[0].name, "Blue Team", NAME_LENGTH);
+	strncpy(bg_guild[0].master, "General Guillaume", NAME_LENGTH);
+	strncpy(bg_guild[0].position[0].name, "Blue Team Leader", NAME_LENGTH);
+	strncpy(bg_guild[0].position[1].name, "Blue Team", NAME_LENGTH);
+	bg_guild[0].ccolor = battle_config.bg_team_ccolor_blue;
+
+	// Guild Data - Croix
+	strncpy(bg_guild[1].name, "Red Team", NAME_LENGTH);
+	strncpy(bg_guild[1].master, "Prince Croix", NAME_LENGTH);
+	strncpy(bg_guild[1].position[0].name, "Red Team Leader", NAME_LENGTH);
+	strncpy(bg_guild[1].position[1].name, "Red Team", NAME_LENGTH);
+	bg_guild[1].ccolor = battle_config.bg_team_ccolor_red;
+
+	// Guild Data - Traitors
+	strncpy(bg_guild[2].name, "Green Team", NAME_LENGTH);
+	strncpy(bg_guild[2].master, "Mercenary", NAME_LENGTH);
+	strncpy(bg_guild[2].position[0].name, "Green Team Leader", NAME_LENGTH);
+	strncpy(bg_guild[2].position[1].name, "Green Team", NAME_LENGTH);
+	bg_guild[2].ccolor = battle_config.bg_team_ccolor_green;
 }
 
-/**
- * Check to see if a Battleground is joinable
- * @param bg: Battleground data
- * @param sd: Player data
- * @param name: Battleground name
- * @return True on success or false otherwise
- */
-bool bg_queue_check_joinable(std::shared_ptr<s_battleground_type> bg, struct map_session_data *sd, const char *name)
+void bg_team_getitem(int bg_id, int nameid, int amount)
 {
-	nullpo_retr(false, sd);
-
-	for (const auto &job : bg->job_restrictions) { // Check class requirement
-		if (sd->status.class_ == job) {
-			clif_bg_queue_apply_result(BG_APPLY_PLAYER_CLASS, name, sd);
-			return false;
-		}
-	}
-
-	if (bg->min_lvl > 0 && sd->status.base_level < bg->min_lvl) { // Check minimum level requirement
-		clif_bg_queue_apply_result(BG_APPLY_PLAYER_LEVEL, name, sd);
-		return false;
-	}
+	struct battleground_data *bg;
+	struct map_session_data *sd;
+	struct item_data *id;
+	struct item it;
+	int get_amount, j, flag;
 
-	if (bg->max_lvl > 0 && sd->status.base_level > bg->max_lvl) { // Check maximum level requirement
-		clif_bg_queue_apply_result(BG_APPLY_PLAYER_LEVEL, name, sd);
-		return false;
-	}
+	if (amount < 1 || (bg = bg_team_search(bg_id)) == NULL || (id = itemdb_exists(nameid)) == NULL)
+		return;
+	if( battle_config.bg_reward_rates != 100 )
+		amount = amount * battle_config.bg_reward_rates / 100;
 
-	if (!bg_queue_check_status(sd, name)) // Check status blocks
-		return false;
+	memset(&it, 0, sizeof(it));
+	it.nameid = nameid;
+	it.identify = 1;
 
-	if (bg_player_is_in_bg_map(sd)) { // Is the player currently in a battleground map? Reject them.
-		clif_bg_queue_apply_result(BG_APPLY_NONE, name, sd);
-		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], msg_txt(sd, 337), false, SELF); // You can't apply to a battleground queue from this map.
-		return false;
-	}
+	for (j = 0; j < MAX_BG_MEMBERS; j++)
+	{
+		if ((sd = bg->members[j].sd) == NULL)
+			continue;
+		
+		get_amount = amount;
 
-	if (battle_config.bgqueue_nowarp_mapflag > 0 && map_getmapflag(sd->bl.m, MF_NOWARP)) { // Check player's current position for mapflag check
-		clif_bg_queue_apply_result(BG_APPLY_NONE, name, sd);
-		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], msg_txt(sd, 337), false, SELF); // You can't apply to a battleground queue from this map.
-		return false;
+		if ((flag = pc_additem(sd, &it, get_amount, LOG_TYPE_SCRIPT)))
+			clif_additem(sd, 0, 0, flag);
 	}
-
-	return true;
 }
-
-/**
- * Mark a map as reserved for a Battleground
- * @param name: Battleground map name
- * @param state: Whether to mark reserved or not
- * @param ended: Whether the Battleground event is complete; players getting prize
- * @return True on success or false otherwise
- */
-bool bg_queue_reservation(const char *name, bool state, bool ended)
+void bg_team_get_kafrapoints(int bg_id, int amount)
 {
-	uint16 mapindex = mapindex_name2id(name);
-
-	for (auto &pair : battleground_db) {
-		for (auto &map : pair.second->maps) {
-			if (map.mapindex == mapindex) {
-				map.isReserved = state;
-				for (auto &queue : bg_queues) {
-					if (queue->map == &map) {
-						if (ended) // The ended flag is applied from bg_reserve (bg_unbook clears it for the next queue)
-							queue->state = QUEUE_STATE_ENDED;
-						if (!state)
-							bg_queue_clear(queue, true);
-					}
-				}
-				return true;
-			}
-		}
-	}
-
-	return false;
-}
+	struct battleground_data *bgd;
+	struct map_session_data *sd;
+	int i, get_amount;
 
-/**
- * Join as an individual into a Battleground
- * @param name: Battleground name
- * @param sd: Player who requested to join the battlegrounds
- */
-void bg_queue_join_solo(const char *name, struct map_session_data *sd)
-{
-	if (!sd) {
-		ShowError("bg_queue_join_solo: Tried to join non-existent player\n.");
+	if ((bgd = bg_team_search(bg_id)) == NULL)
 		return;
-	}
+	if( battle_config.bg_reward_rates != 100 )
+		amount = amount * battle_config.bg_reward_rates / 100;
 
-	std::shared_ptr<s_battleground_type> bg = bg_search_name(name);
+	for (i = 0; i < MAX_BG_MEMBERS; i++)
+	{
+		if ((sd = bgd->members[i].sd) == NULL)
+			continue;
 
-	if (!bg) {
-		ShowWarning("bq_queue_join_solo: Could not find battleground \"%s\" requested by %s (AID: %d / CID: %d)\n", name, sd->status.name, sd->status.account_id, sd->status.char_id);
-		return;
+		get_amount = amount;
+		pc_getcash(sd, 0, get_amount, LOG_TYPE_SCRIPT);
 	}
-
-	if (!bg->solo) {
-		clif_bg_queue_apply_result(BG_APPLY_INVALID_APP, name, sd);
-		return;
-	}
-
-	bg_queue_join_multi(name, sd, { sd }); // Join as solo
 }
 
-/**
- * Join a party onto the same side of a Battleground
- * @param name: Battleground name
- * @param sd: Player who requested to join the battlegrounds
- */
-void bg_queue_join_party(const char *name, struct map_session_data *sd)
+/* ==============================================================
++bg_arena (0 EoS | 1 Boss | 2 TI | 3 CTF | 4 TD | 5 SC | 6 CON)
++bg_result (0 Won | 1 Tie | 2 Lost)
++============================================================== */
+void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena, int bg_result)
 {
-	if (!sd) {
-		ShowError("bg_queue_join_party: Tried to join non-existent player\n.");
-		return;
-	}
-
-	struct party_data *p = party_search(sd->status.party_id);
-
-	if (!p) {
-		clif_bg_queue_apply_result(BG_APPLY_INVALID_APP, name, sd);
-		return; // Someone has bypassed the client check for being in a party
-	}
+	struct battleground_data *bgd;
+	struct map_session_data *sd;
+	struct item_data *id;
+	struct item it;
+	int j, flag, get_amount;
 
-	for (const auto &it : p->party.member) {
-		if (it.leader && sd->status.char_id != it.char_id) {
-			clif_bg_queue_apply_result(BG_APPLY_PARTYGUILD_LEADER, name, sd);
-			return; // Not the party leader
-		}
+	if (amount < 1 || (bgd = bg_team_search(bg_id)) == NULL || (id = itemdb_exists(nameid)) == NULL)
+		return;
+	
+	if( battle_config.bg_reward_rates != 100 )
+	{ // BG Reward Rates
+		amount = amount * battle_config.bg_reward_rates / 100;
+		kafrapoints = kafrapoints * battle_config.bg_reward_rates / 100;
 	}
 
-	std::shared_ptr<s_battleground_type> bg = bg_search_name(name);
+	bg_result = cap_value(bg_result, 0, 2);
+	memset(&it, 0, sizeof(it));
+	it.nameid = nameid;
+	it.identify = 1;
 
-	if (bg) {
-		if (!bg->party) {
-			clif_bg_queue_apply_result(BG_APPLY_INVALID_APP, name, sd);
-			return;
-		}
+	for (j = 0; j < MAX_BG_MEMBERS; j++)
+	{
+		if ((sd = bgd->members[j].sd) == NULL)
+			continue;
 
-		int p_online = 0;
+		pc_setglobalreg(sd, add_str(var), pc_readglobalreg(sd, add_str(var)) + add_value);
 
-		for (const auto &it : p->party.member) {
-			if (it.online)
-				p_online++;
+		if (kafrapoints > 0)
+		{
+			get_amount = kafrapoints;
+			pc_getcash(sd, 0, get_amount, LOG_TYPE_SCRIPT);
 		}
 
-		if (p_online > bg->max_players) {
-			clif_bg_queue_apply_result(BG_APPLY_PLAYER_COUNT, name, sd);
-			return; // Too many party members online
+		if (nameid && amount > 0)
+		{
+			if ((flag = pc_additem(sd, &it, amount, LOG_TYPE_SCRIPT)))
+				clif_additem(sd, 0, 0, flag);
 		}
-
-		std::vector<struct map_session_data *> list;
-
-		for (const auto &it : p->party.member) {
-			if (list.size() == bg->max_players)
+		// Extended Features BG
+		achievement_update_objective(sd, AG_BG_DAMAGE, 1, sd->status.bgstats.damage_done);
+		switch( bg_result ) {
+			case 0: // Won
+				add2limit(sd->status.bgstats.win,1,USHRT_MAX);
+				achievement_update_objective(sd, AG_BG_WIN, 1, 1);
+				if( sd->bmaster_flag )
+					add2limit(sd->status.bgstats.leader_win,1,USHRT_MAX);
+				switch( bg_arena ) {
+					case 0: add2limit(sd->status.bgstats.eos_wins,1,USHRT_MAX); break;
+					case 1: add2limit(sd->status.bgstats.boss_wins,1,USHRT_MAX); break;
+					case 2: add2limit(sd->status.bgstats.ti_wins,1,USHRT_MAX); break;
+					case 3: add2limit(sd->status.bgstats.ctf_wins,1,USHRT_MAX); break;
+					case 4: add2limit(sd->status.bgstats.td_wins,1,USHRT_MAX); break;
+					case 5: add2limit(sd->status.bgstats.sc_wins,1,USHRT_MAX); break;
+					case 6: add2limit(sd->status.bgstats.cq_wins,1,USHRT_MAX); break;
+					case 7: add2limit(sd->status.bgstats.ru_wins,1,USHRT_MAX); break;
+					case 8: add2limit(sd->status.bgstats.dom_wins,1,USHRT_MAX); break;
+				}
+				break;
+			case 1: // Tie
+				add2limit(sd->status.bgstats.tie,1,USHRT_MAX);
+				achievement_update_objective(sd, AG_BG_TIE, 1, 1);
+				if( sd->bmaster_flag )
+					add2limit(sd->status.bgstats.leader_tie,1,USHRT_MAX);
+				switch( bg_arena ) {
+					case 0: add2limit(sd->status.bgstats.eos_tie,1,USHRT_MAX); break;
+					case 1: add2limit(sd->status.bgstats.boss_tie,1,USHRT_MAX); break;
+					case 2: add2limit(sd->status.bgstats.ti_tie,1,USHRT_MAX); break;
+					case 3: add2limit(sd->status.bgstats.ctf_tie,1,USHRT_MAX); break;
+					case 4: add2limit(sd->status.bgstats.td_tie,1,USHRT_MAX); break;
+					case 5: add2limit(sd->status.bgstats.sc_tie,1,USHRT_MAX); break;
+					// No Tie for Conquest or Rush
+					case 8: add2limit(sd->status.bgstats.dom_tie,1,USHRT_MAX); break;
+				}
+				break;
+			case 2: // Lost
+				add2limit(sd->status.bgstats.lost,1,USHRT_MAX);
+				achievement_update_objective(sd, AG_BG_LOSE, 1, 1);
+				if( sd->bmaster_flag )
+					add2limit(sd->status.bgstats.leader_lost,1,USHRT_MAX);
+				switch( bg_arena ) {
+					case 0: add2limit(sd->status.bgstats.eos_lost,1,USHRT_MAX); break;
+					case 1: add2limit(sd->status.bgstats.boss_lost,1,USHRT_MAX); break;
+					case 2: add2limit(sd->status.bgstats.ti_lost,1,USHRT_MAX); break;
+					case 3: add2limit(sd->status.bgstats.ctf_lost,1,USHRT_MAX); break;
+					case 4: add2limit(sd->status.bgstats.td_lost,1,USHRT_MAX); break;
+					case 5: add2limit(sd->status.bgstats.sc_lost,1,USHRT_MAX); break;
+					case 6: add2limit(sd->status.bgstats.cq_lost,1,USHRT_MAX); break;
+					case 7: add2limit(sd->status.bgstats.ru_lost,1,USHRT_MAX); break;
+					case 8: add2limit(sd->status.bgstats.dom_lost,1,USHRT_MAX); break;
+				}
 				break;
-
-			if (it.online) {
-				struct map_session_data *pl_sd = map_charid2sd(it.char_id);
-
-				if (pl_sd)
-					list.push_back(pl_sd);
-			}
 		}
-
-		bg_queue_join_multi(name, sd, list); // Join as party, all on the same side of the BG
-	} else {
-		ShowWarning("clif_parse_bg_queue_apply_request: Could not find Battleground: \"%s\" requested by player: %s (AID:%d CID:%d)\n", name, sd->status.name, sd->status.account_id, sd->status.char_id);
-		clif_bg_queue_apply_result(BG_APPLY_INVALID_NAME, name, sd);
-		return; // Invalid BG name
 	}
 }
 
-/**
- * Join a guild onto the same side of a Battleground
- * @param name: Battleground name
- * @param sd: Player who requested to join the battlegrounds
- */
-void bg_queue_join_guild(const char *name, struct map_session_data *sd)
-{
-	if (!sd) {
-		ShowError("bg_queue_join_guild: Tried to join non-existent player\n.");
-		return;
-	}
-
-	if (!sd->guild) {
-		clif_bg_queue_apply_result(BG_APPLY_INVALID_APP, name, sd);
-		return; // Someone has bypassed the client check for being in a guild
-	}
-	
-	if (strcmp(sd->status.name, sd->guild->master) != 0) {
-		clif_bg_queue_apply_result(BG_APPLY_PARTYGUILD_LEADER, name, sd);
-		return; // Not the guild leader
-	}
+// ====================================================================
+// Battleground Queue System
+// ====================================================================
 
-	std::shared_ptr<s_battleground_type> bg = bg_search_name(name);
-
-	if (bg) {
-		if (!bg->guild) {
-			clif_bg_queue_apply_result(BG_APPLY_INVALID_APP, name, sd);
-			return;
-		}
-
-		struct guild* g = sd->guild;
-
-		if (g->connect_member > bg->max_players) {
-			clif_bg_queue_apply_result(BG_APPLY_PLAYER_COUNT, name, sd);
-			return; // Too many guild members online
-		}
-
-		std::vector<struct map_session_data *> list;
-
-		for (const auto &it : g->member) {
-			if (list.size() == bg->max_players)
-				break;
-
-			if (it.online) {
-				struct map_session_data *pl_sd = map_charid2sd(it.char_id);
-
-				if (pl_sd)
-					list.push_back(pl_sd);
-			}
-		}
-
-		bg_queue_join_multi(name, sd, list); // Join as guild, all on the same side of the BG
-	} else {
-		ShowWarning("clif_parse_bg_queue_apply_request: Could not find Battleground: \"%s\" requested by player: %s (AID:%d CID:%d)\n", name, sd->status.name, sd->status.account_id, sd->status.char_id);
-		clif_bg_queue_apply_result(BG_APPLY_INVALID_NAME, name, sd);
-		return; // Invalid BG name
-	}
+struct queue_data* bg_queue_search(int q_id){ // Search a Queue using q_id
+	if (!q_id) return NULL;
+	return (struct queue_data *)idb_get(bg_queue_db, q_id);
 }
 
-/**
- * Join multiple players onto the same side of a Battleground
- * @param name: Battleground name
- * @param sd: Player who requested to join the battlegrounds
- * @param list: Contains all players including the player who requested to join
- */
-void bg_queue_join_multi(const char *name, struct map_session_data *sd, std::vector <map_session_data *> list)
+int bg_queue_create(const char* queue_name, const char* join_event, int min_level)
 {
-	if (!sd) {
-		ShowError("bg_queue_join_multi: Tried to join non-existent player\n.");
-		return;
-	}
-
-	std::shared_ptr<s_battleground_type> bg = bg_search_name(name);
-
-	if (!bg) {
-		ShowWarning("bq_queue_join_multi: Could not find battleground \"%s\" requested by %s (AID: %d / CID: %d)\n", name, sd->status.name, sd->status.account_id, sd->status.char_id);
-		return;
-	}
-
-	if (!bg_queue_check_joinable(bg, sd, name)){
-		return;
-	}
-
-	for (const auto &queue : bg_queues) {
-		if (queue->id != bg->id || queue->state == QUEUE_STATE_SETUP_DELAY || queue->state == QUEUE_STATE_ENDED)
-			continue;
-
-		// Make sure there's enough space on one side to join as a party/guild in this queue
-		if (queue->teama_members.size() + list.size() > bg->max_players && queue->teamb_members.size() + list.size() > bg->max_players) {
-			break;
-		}
-
-		bool r = rnd() % 2 != 0;
-		std::vector<map_session_data *> *team = r ? &queue->teamb_members : &queue->teama_members;
-
-		if (queue->state == QUEUE_STATE_ACTIVE) {
-			// If one team has lesser members try to balance (on an active BG)
-			if (r && queue->teama_members.size() < queue->teamb_members.size())
-				team = &queue->teama_members;
-			else if (!r && queue->teamb_members.size() < queue->teama_members.size())
-				team = &queue->teamb_members;
-		} else {
-			// If the designated team is full, put the player into the other team
-			if (team->size() + list.size() > bg->required_players)
-				team = r ? &queue->teama_members : &queue->teamb_members;
-		}
-
-		while (!list.empty() && team->size() < bg->max_players) {
-			struct map_session_data *sd2 = list.back();
-
-			list.pop_back();
-
-			if (!sd2 || sd2->bg_queue_id > 0)
-				continue;
-
-			if (!bg_queue_check_joinable(bg, sd2, name))
-				continue;
-
-			sd2->bg_queue_id = queue->queue_id;
-			team->push_back(sd2);
-			clif_bg_queue_apply_result(BG_APPLY_ACCEPT, name, sd2);
-			clif_bg_queue_apply_notify(name, sd2);
-		}
-
-		if (queue->state == QUEUE_STATE_ACTIVE) { // Battleground is already active
-			for (auto &pl_sd : *team) {
-				if (queue->map->mapindex == pl_sd->mapindex)
-					continue;
+	struct queue_data *qd;
+	if( ++queue_counter <= 0 ) queue_counter = 1;
 
-				pc_set_bg_queue_timer(pl_sd);
-				clif_bg_queue_lobby_notify(name, pl_sd);
-			}
-		} else if (queue->state == QUEUE_STATE_SETUP && queue->teamb_members.size() >= bg->required_players && queue->teama_members.size() >= bg->required_players) // Enough players have joined
-			bg_queue_on_ready(name, queue);
+	CREATE(qd, struct queue_data, 1);
+	qd->q_id = queue_counter;
+	safestrncpy(qd->queue_name, queue_name, sizeof(qd->queue_name));
+	safestrncpy(qd->join_event, join_event, sizeof(qd->join_event));
+	qd->first = qd->last = NULL; // First and Last Queue Members
+	qd->users = 0;
+	qd->min_level = min_level;
 
-		return;
-	}
+	idb_put(bg_queue_db, queue_counter, qd);
 
-	// Something went wrong, sends reconnect and then reapply message to client.
-	clif_bg_queue_apply_result(BG_APPLY_RECONNECT, name, sd);
+	return qd->q_id;
 }
 
-/**
- * Clear Battleground queue for next one
- * @param queue: Queue to clean up
- * @param ended: If a Battleground has ended through normal means (by script command bg_unbook)
- */
-void bg_queue_clear(std::shared_ptr<s_battleground_queue> queue, bool ended)
+void bg_queue_members_clean(struct queue_data *qd)
 {
-	if (queue == nullptr)
-		return;
-
-	if (queue->tid_requeue != INVALID_TIMER) {
-		delete_timer(queue->tid_requeue, bg_on_ready_loopback);
-		queue->tid_requeue = INVALID_TIMER;
-	}
+	struct queue_member *head, *next;
+	nullpo_retv(qd);
 
-	if (queue->tid_expire != INVALID_TIMER) {
-		delete_timer(queue->tid_expire, bg_on_ready_expire);
-		queue->tid_expire = INVALID_TIMER;
+	head = qd->first;
+	while( head != NULL )
+	{
+		if( head->sd ) head->sd->qd = NULL;
+		next = head->next;
+		aFree(head);
+		head = next;
 	}
 
-	if (queue->tid_start != INVALID_TIMER) {
-		delete_timer(queue->tid_start, bg_on_ready_start);
-		queue->tid_start = INVALID_TIMER;
-	}
-
-	if (ended) {
-		if (queue->map != nullptr) {
-			queue->map->isReserved = false; // Remove reservation to free up for future queue
-			queue->map = nullptr;
-		}
-
-		for (const auto &sd : queue->teama_members)
-			sd->bg_queue_id = 0;
-
-		for (const auto &sd : queue->teamb_members)
-			sd->bg_queue_id = 0;
-
-		queue->teama_members.clear();
-		queue->teamb_members.clear();
-		queue->teama_members.shrink_to_fit();
-		queue->teamb_members.shrink_to_fit();
-		queue->accepted_players = 0;
-		queue->state = QUEUE_STATE_SETUP;
-	}
+	qd->first = qd->last = NULL;
+	qd->users = 0;
 }
 
-/**
- * Sub function for leaving a Battleground queue
- * @param sd: Player leaving
- * @param members: List of players in queue data
- * @return True on success or false otherwise
- */
-static bool bg_queue_leave_sub(struct map_session_data *sd, std::vector<map_session_data *> &members)
+int bg_queue_member_add(struct queue_data *qd, struct map_session_data *sd)
 {
-	if (!sd)
-		return false;
+	struct queue_member *qm;
+	nullpo_retr(0, qd);
+	nullpo_retr(0, sd);
+
+	CREATE(qm, struct queue_member, 1);
+	qd->users++;
+	qm->sd = sd;
+	qm->position = qd->users;
+	qm->next = NULL;
+	sd->qd = qd; // Attach user to the Queue too
+
+	if (qd->last == NULL)
+		qd->first = qd->last = qm; // Attach to first position
+	else
+	{ // Attach at the end of the queue
+		qd->last->next = qm;
+		qd->last = qm;
+	}
+
+	return qm->position;
+}
 
-	auto list_it = members.begin();
+struct queue_member* bg_queue_member_get(struct queue_data *qd, int position)
+{
+	struct queue_member *head;
+	if( !qd ) return NULL;
 
-	while (list_it != members.end()) {
-		if (*list_it == sd) {
-			members.erase(list_it);
+	head = qd->first;
+	while( head != NULL )
+	{
+		if( head->sd && head->position == position )
+			return head;
 
-			sc_start(nullptr, &sd->bl, SC_ENTRY_QUEUE_APPLY_DELAY, 100, 1, 60000);
-			sd->bg_queue_id = 0;
-			pc_delete_bg_queue_timer(sd);
-			return true;
-		} else {
-			list_it++;
-		}
+		head = head->next;
 	}
 
-	return false;
+	return NULL;
 }
 
-/**
- * Leave a Battleground queue
- * @param sd: Player data
- * @return True on success or false otherwise
- */
-bool bg_queue_leave(struct map_session_data *sd)
+int bg_queue_member_remove(struct queue_data *qd, int id)
 {
-	if (!sd || sd->bg_queue_id == 0)
-		return false;
-
-	pc_delete_bg_queue_timer(sd);
+	struct queue_member *head, *previous;
+	int i;
+	nullpo_retr(0,qd);
+
+	head = qd->first;
+	previous = NULL;
+
+	while( head != NULL )
+	{
+		if( head->sd && head->sd->bl.id == id )
+		{
+			struct queue_member *next;
+
+			next = head->next;
+			i = head->position;
+			head->sd->qd = NULL;
+			qd->users--;
+
+			// De-attach target from the main queue
+			if( previous )
+				previous->next = head->next;
+			else
+				qd->first = head->next; // Deleted is on first position
 
-	for (auto &queue : bg_queues) {
-		if (sd->bg_queue_id == queue->queue_id) {
-			if (!bg_queue_leave_sub(sd, queue->teama_members) && !bg_queue_leave_sub(sd, queue->teamb_members)) {
-				ShowError("bg_queue_leave: Couldn't find player %s in battlegrounds queue.\n", sd->status.name);
-				return false;
-			} else {
-				if ((queue->state == QUEUE_STATE_SETUP || queue->state == QUEUE_STATE_SETUP_DELAY) && queue->teama_members.empty() && queue->teamb_members.empty()) // If there are no players left in the queue (that hasn't started), discard it
-					bg_queue_clear(queue, true);
+			if( head->next == NULL ) qd->last = previous; // Deleted is on last position
 
-				return true;
+			while( next != NULL )
+			{ // Reduces positions of the next of the queue in -1
+				next->position--;
+				next = next->next;
 			}
+
+			aFree(head);
+			return i;
 		}
+
+		previous = head;
+		head = head->next;
 	}
 
-	return false;
+	return 0;
 }
 
-/**
- * Send packets to all clients in queue to notify them that the battleground is ready to be joined
- * @param name: Battleground name
- * @param queue: Battleground queue
- * @return True on success or false otherwise
- */
-bool bg_queue_on_ready(const char *name, std::shared_ptr<s_battleground_queue> queue)
+int bg_queue_member_search(struct queue_data *qd, int id)
 {
-	std::shared_ptr<s_battleground_type> bg = battleground_db.find(queue->id);
-
-	if (!bg) {
-		ShowError("bg_queue_on_ready: Couldn't find battleground ID %d in battlegrounds database.\n", queue->id);
-		return false;
-	}
-
-	if (queue->teama_members.size() < queue->required_players || queue->teamb_members.size() < queue->required_players)
-		return false; // Return players to the queue and stop reapplying the timer
+	struct queue_member *head;
+	nullpo_retr(0,qd);
 
-	bool map_reserved = false;
+	head = qd->first;
+	while( head != NULL )
+	{
+		if( head->sd && head->sd->bl.id == id )
+			return head->position;
 
-	for (auto &map : bg->maps) {
-		if (!map.isReserved) {
-			map.isReserved = true;
-			map_reserved = true;
-			queue->map = &map;
-			break;
-		}
-	}
-
-	if (!map_reserved) { // All the battleground maps are reserved. Set a timer to check for an open battleground every 10 seconds.
-		queue->tid_requeue = add_timer(gettick() + 10000, bg_on_ready_loopback, 0, (intptr_t)queue->queue_id);
-		return false;
+		head = head->next;
 	}
 
-	queue->state = QUEUE_STATE_SETUP_DELAY;
-	queue->tid_expire = add_timer(gettick() + 20000, bg_on_ready_expire, 0, (intptr_t)queue->queue_id);
+	return 0; // Not Found
+}
 
-	for (const auto &sd : queue->teama_members)
-		clif_bg_queue_lobby_notify(name, sd);
+int bg_queue_destroy(int q_id)
+{
+	struct queue_data *qd;
 
-	for (const auto &sd : queue->teamb_members)
-		clif_bg_queue_lobby_notify(name, sd);
+	if( (qd = bg_queue_search(q_id)) == NULL )
+		return 0;
 
-	return true;
+	bg_queue_members_clean(qd);
+	idb_remove(bg_queue_db, q_id);
+	return 1;
 }
 
-/**
- * Send a player into an active Battleground
- * @param sd: Player to send in
- * @param queue: Queue data
- */
-void bg_join_active(map_session_data *sd, std::shared_ptr<s_battleground_queue> queue)
+int bg_queue_join(struct map_session_data *sd, int q_id)
 {
-	if (sd == nullptr || queue == nullptr)
-		return;
+	char output[128];
+	struct queue_data *qd;
+	int i;
 
-	// Check player's current position for mapflag check
-	if (battle_config.bgqueue_nowarp_mapflag > 0 && map_getmapflag(sd->bl.m, MF_NOWARP)) {
-		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], msg_txt(sd, 337), false, SELF); // You can't apply to a battleground queue from this map.
-		bg_queue_leave(sd);
-		clif_bg_queue_entry_init(sd);
-		return;
+	if (battle_config.bg_queue_onlytowns && !map_getmapflag(sd->bl.m, MF_TOWN))
+	{
+		clif_displaymessage(sd->fd, "You only can join BG queues from Towns or BG Waiting Room.");
+		return 0;
 	}
 
-	int bg_id_team_1 = static_cast<int>(mapreg_readreg(add_str(queue->map->team1.bg_id_var.c_str())));
-	std::shared_ptr<s_battleground_data> bgteam_1 = util::umap_find(bg_team_db, bg_id_team_1);
-
-	for (auto &pl_sd : queue->teama_members) {
-		if (sd != pl_sd)
-			continue;
-
-		if (bgteam_1 == nullptr) {
-			bg_queue_leave(sd);
-			clif_bg_queue_apply_result(BG_APPLY_RECONNECT, battleground_db.find(queue->id)->name.c_str(), sd);
-			clif_bg_queue_entry_init(sd);
-			return;
-		}
-
-		clif_bg_queue_entry_init(pl_sd);
-		bg_team_join(bg_id_team_1, pl_sd, true);
-		npc_event(pl_sd, bgteam_1->active_event.c_str(), 0);
-		return;
+	if (sd->bg_id)
+	{
+		clif_displaymessage(sd->fd, "You cannot join queues when already playing Battlegrounds.");
+		return 0;
 	}
 
-	int bg_id_team_2 = static_cast<int>(mapreg_readreg(add_str(queue->map->team2.bg_id_var.c_str())));
-	std::shared_ptr<s_battleground_data> bgteam_2 = util::umap_find(bg_team_db, bg_id_team_2);
-
-	for (auto &pl_sd : queue->teamb_members) {
-		if (sd != pl_sd)
-			continue;
-
-		if (bgteam_2 == nullptr) {
-			bg_queue_leave(sd);
-			clif_bg_queue_apply_result(BG_APPLY_RECONNECT, battleground_db.find(queue->id)->name.c_str(), sd);
-			clif_bg_queue_entry_init(sd);
-			return;
-		}
+	if (sd->sc.data[SC_JAILED])
+	{
+		clif_displaymessage(sd->fd, "You cannot join queues when jailed.");
+		return 0;
+	}
 
-		clif_bg_queue_entry_init(pl_sd);
-		bg_team_join(bg_id_team_2, pl_sd, true);
-		npc_event(pl_sd, bgteam_2->active_event.c_str(), 0);
-		return;
+	if ((qd = sd->qd) != NULL)
+	{ // You cannot join a Queue if you are already on one.
+		i = bg_queue_member_search(qd, sd->bl.id);
+		sprintf(output, "You are already on %s queue at position %d.", qd->queue_name, i);
+		clif_displaymessage(sd->fd, output);
+		return 0;
 	}
 
-	return;
-}
+	if ((qd = bg_queue_search(q_id)) == NULL)
+		return 0; // Current Queue don't exists
 
-/**
- * Check to see if any players in the queue are on a map with MF_NOWARP and remove them from the queue
- * @param queue: Queue data
- * @return True if the player is on a map with MF_NOWARP or false otherwise
- */
-bool bg_mapflag_check(std::shared_ptr<s_battleground_queue> queue) {
-	if (queue == nullptr || battle_config.bgqueue_nowarp_mapflag == 0)
-		return false;
-
-	bool found = false;
-
-	for (const auto &sd : queue->teama_members) {
-		if (map_getmapflag(sd->bl.m, MF_NOWARP)) {
-			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], msg_txt(sd, 337), false, SELF); // You can't apply to a battleground queue from this map.
-			bg_queue_leave(sd);
-			clif_bg_queue_entry_init(sd);
-			found = true;
-		}
+	if (qd->min_level && sd->status.base_level < qd->min_level)
+	{
+		sprintf(output, "You cannot join %s queue. Required min level is %d.", qd->queue_name, qd->min_level);
+		clif_displaymessage(sd->fd, output);
+		return 0;
 	}
-
-	for (const auto &sd : queue->teamb_members) {
-		if (map_getmapflag(sd->bl.m, MF_NOWARP)) {
-			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], msg_txt(sd, 337), false, SELF); // You can't apply to a battleground queue from this map.
-			bg_queue_leave(sd);
-			clif_bg_queue_entry_init(sd);
-			found = true;
-		}
+	if( bg_countlogin(sd,false) > 0 && battle_config.bg_double_login)
+	{
+		sprintf(output,"You cannot join %s queue. Double Login detected.", qd->queue_name);
+		clif_displaymessage(sd->fd,output);
+		return 0;
 	}
 
-	if (found) {
-		queue->state = QUEUE_STATE_SETUP; // Set back to queueing state
-		queue->accepted_players = 0; // Reset acceptance count
-
-		// Free map to avoid creating a reservation delay
-		if (queue->map != nullptr) {
-			queue->map->isReserved = false;
-			queue->map = nullptr;
-		}
-
-		// Announce failure to remaining players
-		for (const auto &sd : queue->teama_members)
-			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], msg_txt(sd, 340), false, SELF); // Participants were unable to join. Delaying entry for more participants.
-
-		for (const auto &sd : queue->teamb_members)
-			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], msg_txt(sd, 340), false, SELF); // Participants were unable to join. Delaying entry for more participants.
+	i = bg_queue_member_add(qd, sd);
+	sprintf(output, "You have joined %s queue at position %d.", qd->queue_name, i);
+	clif_displaymessage(sd->fd, output);
+	
+	if (battle_config.bg_queue_interface) {
+		clif_bg_queue_apply_result(BG_APPLY_ACCEPT, qd->queue_name, sd);
+		clif_bg_queue_apply_notify(qd->queue_name, sd);
 	}
-
-	return found;
+	
+	if (qd->join_event[0]) npc_event_do(qd->join_event);
+	return 1;
 }
 
-/**
- * Update the Battleground queue when the player accepts the invite
- * @param queue: Battleground queue
- * @param sd: Player data
- */
-void bg_queue_on_accept_invite(struct map_session_data *sd)
+int bg_queue_leave(struct map_session_data *sd, int q_id)
 {
-	nullpo_retv(sd);
+	char output[128];
+	struct queue_data *qd;
 
-	std::shared_ptr<s_battleground_queue> queue = bg_search_queue(sd->bg_queue_id);
+	if( (qd = bg_queue_search(q_id)) == NULL )
+		return 0;
 
-	if (queue == nullptr) {
-		ShowError("bg_queue_on_accept_invite: Couldn't find player %s in battlegrounds queue.\n", sd->status.name);
-		return;
+	if( !bg_queue_member_remove(qd,sd->bl.id) )
+	{
+		sprintf(output,"You are not at %s queue.", qd->queue_name);
+		clif_displaymessage(sd->fd, output);
+		return 0;
 	}
+	sprintf(output,"You have been removed from the %s queue.", qd->queue_name);
+	clif_displaymessage(sd->fd, output);
+	
+	//if (battle_config.bg_queue_interface)
+	//	clif_bg_queue_entry_init(sd);
 
-	queue->accepted_players++;
-	clif_bg_queue_ack_lobby(true, mapindex_id2name(queue->map->mapindex), mapindex_id2name(queue->map->mapindex), sd);
-
-	if (queue->state == QUEUE_STATE_ACTIVE) // Battleground is already active
-		bg_join_active(sd, queue);
-	else if (queue->state == QUEUE_STATE_SETUP_DELAY) {
-		if (queue->accepted_players == queue->required_players * 2) {
-			if (queue->tid_expire != INVALID_TIMER) {
-				delete_timer(queue->tid_expire, bg_on_ready_expire);
-				queue->tid_expire = INVALID_TIMER;
-			}
-
-			// Check player's current position for mapflag check
-			if (battle_config.bgqueue_nowarp_mapflag > 0 && bg_mapflag_check(queue))
-				return;
-
-			queue->tid_start = add_timer(gettick() + battleground_db.find(queue->id)->start_delay * 1000, bg_on_ready_start, 0, (intptr_t)queue->queue_id);
-		}
-	}
+	return 1;
 }
 
-/**
- * Begin the Battleground from the given queue
- * @param queue: Battleground queue
- */
-void bg_queue_start_battleground(std::shared_ptr<s_battleground_queue> queue)
+void bg_queue_leaveall(struct map_session_data *sd)
 {
-	if (queue == nullptr)
-		return;
-
-	std::shared_ptr<s_battleground_type> bg = battleground_db.find(queue->id);
-
-	if (!bg) {
-		bg_queue_clear(queue, true);
-		ShowError("bg_queue_start_battleground: Could not find battleground ID %d in battlegrounds database.\n", queue->id);
-		return;
-	}
-
-	// Check player's current position for mapflag check
-	if (battle_config.bgqueue_nowarp_mapflag > 0 && bg_mapflag_check(queue))
-		return;
-
-	uint16 map_idx = queue->map->mapindex;
-	int bg_team_1 = bg_create(map_idx, &queue->map->team1);
-	int bg_team_2 = bg_create(map_idx, &queue->map->team2);
-
-	for (const auto &sd : queue->teama_members) {
-		clif_bg_queue_entry_init(sd);
-		bg_team_join(bg_team_1, sd, true);
-	}
-
-	for (const auto &sd : queue->teamb_members) {
-		clif_bg_queue_entry_init(sd);
-		bg_team_join(bg_team_2, sd, true);
+	struct queue_data *qd;
+	if( sd && (qd = sd->qd) != NULL )
+	{
+		char output[128];
+		bg_queue_member_remove(qd,sd->bl.id);
+		sprintf(output,"You have been removed from %s BG Queue.",qd->queue_name);
+		clif_displaymessage(sd->fd, output);
+		//if (battle_config.bg_queue_interface)
+		//	clif_bg_queue_entry_init(sd);
 	}
+}
 
-	mapreg_setreg(add_str(queue->map->team1.bg_id_var.c_str()), bg_team_1);
-	mapreg_setreg(add_str(queue->map->team2.bg_id_var.c_str()), bg_team_2);
-	npc_event_do(queue->map->bgcallscript.c_str());
-	queue->state = QUEUE_STATE_ACTIVE;
+// ====================================================================
 
-	bg_queue_clear(queue, false);
+int bg_team_db_reset( DBKey key, DBData *data, va_list ap)
+{
+	struct battleground_data *bgd = (struct battleground_data *)db_data2ptr(data);
+	bg_team_clean(bgd->bg_id,false);
+	return 0;
 }
 
-/**
- * Initialize a Battleground queue
- * @param bg_id: Battleground ID
- * @param req_players: Required amount of players
- * @return s_battleground_queue*
- */
-static void bg_queue_create(int bg_id, int req_players)
+int queue_db_final( DBKey key, DBData *data, va_list ap)
 {
-	auto queue = std::make_shared<s_battleground_queue>();
-
-	queue->queue_id = bg_queue_count++;
-	queue->id = bg_id;
-	queue->required_players = req_players;
-	queue->accepted_players = 0;
-	queue->tid_expire = INVALID_TIMER;
-	queue->tid_start = INVALID_TIMER;
-	queue->tid_requeue = INVALID_TIMER;
-	queue->state = QUEUE_STATE_SETUP;
-
-	bg_queues.push_back(queue);
+	struct queue_data *qd = (struct queue_data *)db_data2ptr(data);
+	bg_queue_members_clean(qd); // Unlink all queue members
+	return 0;
 }
 
-/**
- * Initialize the Battleground data
- */
 void do_init_battleground(void)
 {
-	if (battle_config.feature_bgqueue) {
-		battleground_db.load();
-
-		for (const auto &bg : battleground_db)
-			bg_queue_create(bg.first, bg.second->required_players);
-	}
-
+	bg_team_db = idb_alloc(DB_OPT_RELEASE_DATA);
+	bg_queue_db = idb_alloc(DB_OPT_RELEASE_DATA);
 	add_timer_func_list(bg_send_xy_timer, "bg_send_xy_timer");
-	add_timer_func_list(bg_on_ready_loopback, "bg_on_ready_loopback");
-	add_timer_func_list(bg_on_ready_expire, "bg_on_ready_expire");
-	add_timer_func_list(bg_on_ready_start, "bg_on_ready_start");
+	add_timer_func_list(bg_block_skill_end,"bg_block_skill_end");
 	add_timer_interval(gettick() + battle_config.bg_update_interval, bg_send_xy_timer, 0, 0, battle_config.bg_update_interval);
+	bg_guild_build_data();
 }
 
-/**
- * Clear the Battleground data from memory
- */
 void do_final_battleground(void)
 {
+	bg_team_db->destroy(bg_team_db, NULL);
+	bg_queue_db->destroy(bg_queue_db, queue_db_final);
 }
Index: src/map/battleground.hpp
===================================================================
diff --git a/src/map/battleground.hpp b/src/map/battleground.hpp
--- a/src/map/battleground.hpp	cd68b2a3805
+++ b/src/map/battleground.hpp	e1e7333adff
@@ -4,86 +4,51 @@
 #ifndef BATTLEGROUND_HPP
 #define BATTLEGROUND_HPP
 
-#include <memory>
-#include <string>
-#include <vector>
-
 #include "../common/cbasetypes.hpp"
-#include "../common/database.hpp"
 #include "../common/mmo.hpp" // struct party
 
-#define MAX_BG_MEMBERS 30
+#define MAX_BG_MEMBERS 50
 
-struct s_battleground_member_data {
+struct battleground_member_data {
 	unsigned short x, y;
 	struct map_session_data *sd;
 	unsigned afk : 1;
-	struct point entry_point; ///< Battleground queue entry point
-};
-
-struct s_battleground_data {
-	int id; ///< Battleground ID
-	std::vector<s_battleground_member_data> members; ///< List of players in battleground
-	struct point cemetery; ///< Respawn point for players who die
-	std::string logout_event; ///< NPC Event to call on log out events
-	std::string die_event; ///< NPC Event to call on death events
-	std::string active_event; ///< NPC Event to call on players joining an active battleground
-};
-
-struct s_battleground_team {
-	int16 warp_x, warp_y; ///< Team respawn coordinates
-	std::string quit_event, ///< Team NPC Event to call on log out events
-		death_event, ///< Team NPC Event to call on death events
-		active_event, ///< Team NPC Event to call on players joining an active battleground
-		bg_id_var; ///< Team NPC variable name
 };
 
-struct s_battleground_map {
-	int id; ///< Battleground ID
-	uint16 mapindex; ///< Index of the map
-	s_battleground_team team1, team2; ///< Team data
-	std::string bgcallscript; ///< Script to be called when players join the battleground
-	bool isReserved; ///< Reserve BG maps that are used so that the system won't create multiple BG instances on the same map
+struct battleground_data {
+	unsigned int bg_id;
+	int count;
+	time_t creation_tick; // Creation of this Team
+	// Team Leader and BG Skills features
+	int leader_char_id;
+	int skill_block_timer[MAX_GUILDSKILL];
+	unsigned int color;
+	bool reveal_pos, reveal_flag;
+	// Party - Faction ID
+	int pf_id;
+	// Fake Guild Link
+	struct guild *g;
+	struct battleground_member_data members[MAX_BG_MEMBERS];
+	// BG Cementery
+	unsigned short mapindex, x, y;
+	// Logout Event
+	char logout_event[EVENT_NAME_LENGTH];
+	char die_event[EVENT_NAME_LENGTH];
+	// Score Board
+	int team_score;
 };
 
-/// Enum for queue state tracking
-enum e_queue_state : uint16 {
-	QUEUE_STATE_SETUP = 0, ///< The initial setup of a queue (a required amount of players hasn't been met)
-	QUEUE_STATE_SETUP_DELAY, ///< The initial setup of a queue but a required amount of players have accepted and the delay timer is active
-	QUEUE_STATE_ACTIVE, ///< The queue is active script side and more players can join (players may or may not be on the field)
-	QUEUE_STATE_ENDED, ///< The queue is no longer joinable (players are getting prizes)
-};
-
-/// Battlegrounds client interface queue system [MasterOfMuppets]
-struct s_battleground_queue {
-	int queue_id; ///< Battlegrounds Queue ID
-	int id; ///< Battlegrounds database ID
-	std::vector<map_session_data *> teama_members; ///< List of members on team A
-	std::vector<map_session_data *> teamb_members; ///< List of members on team B
-	int required_players; ///< Amount of players required on each side to start
-	int max_players; ///< Maximum amount of players on each side
-	int accepted_players; ///< Amount of players who accepted the offer to enter the battleground
-	e_queue_state state; ///< See @e_queue_state
-	int tid_expire; ///< Timer ID associated with the time out at the ready to enter window
-	int tid_start; ///< Timer ID associated with the start delay
-	int tid_requeue; ///< Timer ID associated with requeuing this group if all BG maps are reserved
-	s_battleground_map *map; ///< Map this BG queue has been assigned to
+struct queue_member {
+	int position;
+	struct map_session_data *sd;
+	struct queue_member *next;
 };
 
-struct s_battleground_type {
-	int id; ///< Battlegrounds database ID
-	std::string name; ///< Name of the battleground type
-	int required_players; ///< Amount of players required on each side to start
-	int max_players; ///< Maximum amount of players on each side
-	int min_lvl; ///< Minimum level to participate in this battleground type
-	int max_lvl; ///< Maximum level to participate in this battleground type
-	std::vector<s_battleground_map> maps; ///< List of battleground locations
-	uint32 deserter_time; ///< Amount of time a player is marked deserter (seconds)
-	uint32 start_delay; ///< Amount of time before the start message is sent to players (seconds)
-	bool solo; ///< Ability to join a queue as an individual.
-	bool party; ///< Ability to join a queue as a party.
-	bool guild; ///< Ability to join a queue as a guild.
-	std::vector<int32> job_restrictions; ///< List of jobs that are unable to join.
+struct queue_data {
+	unsigned int q_id;
+	int min_level, users;
+	struct queue_member *first, *last;
+	char queue_name[50], join_event[EVENT_NAME_LENGTH];
 };
 
 /// Enum of responses when applying for a Battleground
@@ -101,61 +66,55 @@
 	BG_APPLY_PLAYER_CLASS, ///< Your class can't apply
 };
 
-/// Enum of script command bg_info types
-enum e_bg_info : uint16 {
-	BG_INFO_ID = 0,
-	BG_INFO_REQUIRED_PLAYERS,
-	BG_INFO_MAX_PLAYERS,
-	BG_INFO_MIN_LEVEL,
-	BG_INFO_MAX_LEVEL,
-	BG_INFO_MAPS,
-	BG_INFO_DESERTER_TIME,
-};
-
-class BattlegroundDatabase : public TypesafeYamlDatabase<uint32, s_battleground_type> {
-public:
-	BattlegroundDatabase() : TypesafeYamlDatabase("BATTLEGROUND_DB", 1) {
-
-	}
-
-	const std::string getDefaultLocation();
-	uint64 parseBodyNode(const YAML::Node& node);
-};
-
-extern BattlegroundDatabase battleground_db;
-extern std::unordered_map<int, std::shared_ptr<s_battleground_data>> bg_team_db;
-extern std::vector<std::shared_ptr<s_battleground_queue>> bg_queues;
-
-std::shared_ptr<s_battleground_type> bg_search_name(const char *name);
-std::shared_ptr<s_battleground_queue> bg_search_queue(int queue_id);
-void bg_send_dot_remove(struct map_session_data *sd);
-int bg_team_get_id(struct block_list *bl);
-struct map_session_data *bg_getavailablesd(s_battleground_data *bg);
-
-bool bg_queue_reservation(const char *name, bool state, bool ended);
-#define bg_queue_reserve(name, end) (bg_queue_reservation(name, true, end))
-#define bg_queue_unbook(name) (bg_queue_reservation(name, false, false))
-
-int bg_create(uint16 mapindex, s_battleground_team* team);
-bool bg_team_join(int bg_id, struct map_session_data *sd, bool is_queue);
-bool bg_team_delete(int bg_id);
-int bg_team_leave(struct map_session_data *sd, bool quit, bool deserter);
-bool bg_team_warp(int bg_id, unsigned short mapindex, short x, short y);
-bool bg_player_is_in_bg_map(struct map_session_data *sd);
-bool bg_queue_check_joinable(std::shared_ptr<s_battleground_type> bg, struct map_session_data *sd, const char *name);
-void bg_queue_join_solo(const char *name, struct map_session_data *sd);
-void bg_queue_join_party(const char *name, struct map_session_data *sd);
-void bg_queue_join_guild(const char *name, struct map_session_data *sd);
-void bg_queue_join_multi(const char *name, struct map_session_data *sd, std::vector<map_session_data *> list);
-void bg_queue_clear(std::shared_ptr<s_battleground_queue> queue, bool ended);
-bool bg_queue_leave(struct map_session_data *sd);
-bool bg_queue_on_ready(const char *name, std::shared_ptr<s_battleground_queue> queue);
-void bg_queue_on_accept_invite(struct map_session_data *sd);
-void bg_queue_start_battleground(std::shared_ptr<s_battleground_queue> queue);
-bool bg_member_respawn(struct map_session_data *sd);
-void bg_send_message(struct map_session_data *sd, const char *mes, int len);
+extern struct guild bg_guild[];
+extern const unsigned int bg_colors[];
 
 void do_init_battleground(void);
 void do_final_battleground(void);
 
+struct battleground_data* bg_team_search(int bg_id);
+struct guild* bg_guild_get(int bg_id);
+int bg_send_dot_remove(struct map_session_data *sd);
+int bg_team_get_id(struct block_list *bl);
+struct map_session_data* bg_getavailablesd(struct battleground_data *bg);
+
+int bg_create(unsigned short mapindex, short rx, short ry, int guild_index, const char *ev, const char *dev);
+int bg_team_join(int bg_id, struct map_session_data *sd);
+int bg_team_delete(int bg_id);
+int bg_team_clean(int bg_id, bool remove);
+int bg_team_leave(struct map_session_data *sd, int flag);
+int bg_team_warp(int bg_id, unsigned short mapindex, short x, short y);
+int bg_member_respawn(struct map_session_data *sd);
+int bg_send_message(struct map_session_data *sd, const char *mes, int len);
+int battleground_countlogin(struct map_session_data *sd, bool check_bat_room);
+void bg_team_getitem(int bg_id, int nameid, int amount);
+void bg_team_get_kafrapoints(int bg_id, int amount);
+void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena, int bg_result);
+
+int bg_countlogin(struct map_session_data *sd, bool check_bat_room);
+void bg_team_getitem(int bg_id, int nameid, int amount);
+void bg_team_get_kafrapoints(int bg_id, int amount);
+void bg_team_rewards(int bg_id, int nameid, int amount, int kafrapoints, int quest_id, const char *var, int add_value, int bg_arena, int bg_result);
+
+struct queue_data* bg_queue_search(int q_id);
+int bg_queue_create(const char* queue_name, const char* join_event, int min_level);
+int bg_queue_destroy(int q_id);
+int bg_queue_leave(struct map_session_data *sd, int q_id);
+void bg_queue_leaveall(struct map_session_data *sd);
+int bg_queue_join(struct map_session_data *sd, int q_id);
+
+struct queue_member* bg_queue_member_get(struct queue_data *qd, int position);
+int bg_queue_member_remove(struct queue_data *qd, int id);
+
+int bg_checkskill (struct battleground_data *bg, int id);
+void bg_block_skill_status (struct battleground_data *bg, int skillnum);
+void bg_block_skill_start (struct battleground_data *bg, int skillnum, t_tick time);
+//int bg_block_skill_end (int tid, unsigned int tick, int id, intptr_t data);
+int bg_team_sub_count(struct block_list *bl, va_list ap);
+int bg_team_foreachsamemap(int (*func)(struct block_list *,va_list),struct map_session_data *sd,int range,...);
+int bg_queue_member_search(struct queue_data *qd, int id);
+
+void bg_reload(void);
+void bg_guild_build_data(void);
+
 #endif /* BATTLEGROUND_HPP */
Index: src/map/buyingstore.cpp
===================================================================
diff --git a/src/map/buyingstore.cpp b/src/map/buyingstore.cpp
--- a/src/map/buyingstore.cpp	df19d70b45d
+++ b/src/map/buyingstore.cpp	6c5d0c11a13
@@ -12,6 +12,7 @@
 #include "../common/socket.hpp"  // RBUF*
 #include "../common/strlib.hpp"  // safestrncpy
 #include "../common/timer.hpp"  // gettick
+#include "../common/utils.hpp"
 
 #include "atcommand.hpp"  // msg_txt
 #include "battle.hpp"  // battle_config.*
@@ -396,6 +397,13 @@
 			clif_buyingstore_trade_failed_seller( sd, BUYINGSTORE_TRADE_SELLER_FAILED, item->itemId );
 			return;
 		}
+		
+		if (sd->inventory.u.items_inventory[index].card[0] == CARD0_CREATE && ((MakeDWord(sd->inventory.u.items_inventory[index].card[2], sd->inventory.u.items_inventory[index].card[3])) == (battle_config.bg_reserved_char_id || battle_config.woe_reserved_char_id) && !battle_config.bg_can_trade ))
+		{ // Items where creator's ID is important
+			clif_buyingstore_trade_failed_seller( sd, BUYINGSTORE_TRADE_SELLER_FAILED, item->itemId );
+			clif_displaymessage(sd->fd, "Cannot Trade event reserved Items (Battleground, WoE).");
+			return;
+		}
 
 		int listidx;
 
Index: src/map/chrif.cpp
===================================================================
diff --git a/src/map/chrif.cpp b/src/map/chrif.cpp
--- a/src/map/chrif.cpp	2d431c67514
+++ b/src/map/chrif.cpp	32d36f1e24c
@@ -1205,11 +1205,12 @@
 /*==========================================
  * Request/Receive top 10 Fame character list
  *------------------------------------------*/
-int chrif_updatefamelist(struct map_session_data* sd) {
+int chrif_updatefamelist(struct map_session_data* sd, int flag) {
 	char type;
 
 	chrif_check(-1);
 
+	if (!flag)
 	switch(sd->class_ & MAPID_UPPERMASK) {
 		case MAPID_BLACKSMITH: type = RANK_BLACKSMITH; break;
 		case MAPID_ALCHEMIST:  type = RANK_ALCHEMIST; break;
@@ -1218,10 +1219,23 @@
 			return 0;
 	}
 
+	if (flag == 1)
+		type = RANK_BG;
+	else if (flag == 2)
+		type = RANK_WOE;
+	
 	WFIFOHEAD(char_fd, 11);
 	WFIFOW(char_fd,0) = 0x2b10;
 	WFIFOL(char_fd,2) = sd->status.char_id;
-	WFIFOL(char_fd,6) = sd->status.fame;
+	if (!flag)
+		WFIFOL(char_fd,6) = sd->status.fame;
+	else {
+		switch(type) {
+			case RANK_BG: WFIFOL(char_fd,6) = sd->status.bgstats.points; break;
+			case RANK_WOE: WFIFOL(char_fd,6) = sd->status.wstats.points; break;
+			default: WFIFOL(char_fd,6) = sd->status.fame;
+		}
+	}
 	WFIFOB(char_fd,10) = type;
 	WFIFOSET(char_fd,11);
 
@@ -1240,11 +1254,31 @@
 
 int chrif_recvfamelist(int fd) {
 	int num, size;
-	int total = 0, len = 8;
+	int total = 0, len = 12;
 
 	memset (smith_fame_list, 0, sizeof(smith_fame_list));
 	memset (chemist_fame_list, 0, sizeof(chemist_fame_list));
 	memset (taekwon_fame_list, 0, sizeof(taekwon_fame_list));
+	memset (bg_fame_list, 0, sizeof(bg_fame_list));
+	memset (woe_fame_list, 0, sizeof(woe_fame_list));
+
+	size = RFIFOW(fd,10); //WoE rank block size
+	for( num = 0; len < size && num < MAX_FAME_LIST; num++ )
+	{
+		memcpy(&woe_fame_list[num],RFIFOP(fd,len),sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+
+	total += num;
+
+	size = RFIFOW(fd,8); //BG rank block size
+	for( num = 0; len < size && num < MAX_FAME_LIST; num++ )
+	{
+		memcpy(&bg_fame_list[num],RFIFOP(fd,len),sizeof(struct fame_list));
+		len += sizeof(struct fame_list);
+	}
+
+	total += num;
 
 	size = RFIFOW(fd, 6); //Blacksmith block size
 
@@ -1288,6 +1322,8 @@
 		case RANK_BLACKSMITH:	list = smith_fame_list;   break;
 		case RANK_ALCHEMIST:	list = chemist_fame_list; break;
 		case RANK_TAEKWON:		list = taekwon_fame_list; break;
+		case RANK_BG:			list = bg_fame_list;      break;
+		case RANK_WOE:			list = woe_fame_list;      break;
 		default: return 0;
 	}
 
Index: src/map/chrif.hpp
===================================================================
diff --git a/src/map/chrif.hpp b/src/map/chrif.hpp
--- a/src/map/chrif.hpp	6e9bcb33020
+++ b/src/map/chrif.hpp	078011c9134
@@ -66,7 +66,7 @@
 int chrif_searchcharid(uint32 char_id);
 int chrif_changeemail(int id, const char *actual_email, const char *new_email);
 int chrif_req_login_operation(int aid, const char* character_name, enum chrif_req_op operation_type, int32 timediff, int val1, int val2);
-int chrif_updatefamelist(struct map_session_data *sd);
+int chrif_updatefamelist(struct map_session_data *sd, int flag);
 int chrif_buildfamelist(void);
 int chrif_save_scdata(struct map_session_data *sd);
 int chrif_char_offline(struct map_session_data *sd);
Index: src/map/clif.cpp
===================================================================
diff --git a/src/map/clif.cpp b/src/map/clif.cpp
--- a/src/map/clif.cpp	29b55c65cbb
+++ b/src/map/clif.cpp	705754c68bd
@@ -468,11 +468,11 @@
 	struct map_session_data *sd, *tsd;
 	struct party_data *p = NULL;
 	struct guild *g = NULL;
-	std::shared_ptr<s_battleground_data> bg;
+	struct battleground_data *bg = NULL;
 	int x0 = 0, x1 = 0, y0 = 0, y1 = 0, fd;
 	struct s_mapiterator* iter;
 
-	if( type != ALL_CLIENT )
+	if( type != ALL_CLIENT && type != BG_LISTEN)
 		nullpo_ret(bl);
 
 	sd = BL_CAST(BL_PC, bl);
@@ -480,8 +480,11 @@
 	switch(type) {
 
 	case ALL_CLIENT: //All player clients.
+	case BG_LISTEN:
 		iter = mapit_getallusers();
 		while( ( tsd = (map_session_data*)mapit_next( iter ) ) != nullptr ){
+			if (type == BG_LISTEN && (tsd->state.bg_listen && !tsd->qd))
+				continue;
 			if( session_isActive( fd = tsd->fd ) ){
 				WFIFOHEAD( fd, len );
 				memcpy( WFIFOP( fd, 0 ), buf, len );
@@ -678,10 +681,11 @@
 	case BG_SAMEMAP_WOS:
 	case BG:
 	case BG_WOS:
-		if( sd && sd->bg_id > 0 && (bg = util::umap_find(bg_team_db, sd->bg_id)))
+		if( sd && sd->bg_id && (bg = bg_team_search(sd->bg_id)) != NULL )
 		{
-			for (const auto &member : bg->members) {
-				if( ( sd = member.sd ) == nullptr || !session_isActive( fd = sd->fd ) )
+			for( i = 0; i < MAX_BG_MEMBERS; i++ )
+			{
+				if( (sd = bg->members[i].sd) == NULL || !(fd = sd->fd) )
 					continue;
 				if(sd->bl.id == bl->id && (type == BG_WOS || type == BG_SAMEMAP_WOS || type == BG_AREA_WOS) )
 					continue;
@@ -1045,7 +1049,7 @@
 	struct map_session_data* sd = BL_CAST( BL_PC, bl );
 	struct status_change* sc = status_get_sc( bl );
 	struct view_data* vd = status_get_viewdata( bl );
-	int g_id = status_get_guild_id( bl );
+	int g_id = clif_visual_guild_id(bl);
 
 #if PACKETVER < 20091103
 	if( !pcdb_checkid( vd->class_ ) ){
@@ -1066,7 +1070,7 @@
 		p.accessory = vd->head_bottom;
 		if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
 			// The hell, why flags work like this?
-			p.shield = status_get_emblem_id( bl );
+			p.shield = clif_visual_emblem_id(bl);
 			p.accessory2 = GetWord( g_id, 1 );
 			p.accessory3 = GetWord( g_id, 0 );
 		}else{
@@ -1078,7 +1082,7 @@
 		p.bodypalette = vd->cloth_color;
 		p.headDir = ( sd )? sd->head_dir : 0;
 		p.GUID = g_id;
-		p.GEmblemVer = status_get_emblem_id( bl );
+		p.GEmblemVer = clif_visual_emblem_id(bl);
 		p.honor = ( sd ) ? sd->status.manner : 0;
 		p.virtue = ( sc ) ? sc->opt3 : 0;
 		p.isPKModeON = ( sd && sd->status.karma ) ? 1 : 0;
@@ -1135,7 +1139,7 @@
 #endif
 	if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
 		// The hell, why flags work like this?
-		p.accessory = status_get_emblem_id( bl );
+		p.accessory = clif_visual_emblem_id(bl);
 		p.accessory2 = GetWord( g_id, 1 );
 		p.accessory3 = GetWord( g_id, 0 );
 	}else{
@@ -1150,7 +1154,7 @@
 	p.robe = vd->robe;
 #endif
 	p.GUID = g_id;
-	p.GEmblemVer = status_get_emblem_id( bl );
+	p.GEmblemVer = clif_visual_emblem_id(bl);
 	p.honor = (sd) ? sd->status.manner : 0;
 	p.virtue = (sc) ? sc->opt3 : 0;
 	p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
@@ -1210,7 +1214,7 @@
 	struct map_session_data* sd = BL_CAST( BL_PC, bl );
 	struct status_change* sc = status_get_sc( bl );
 	struct view_data* vd = status_get_viewdata( bl );
-	int g_id = status_get_guild_id( bl );
+	int g_id = clif_visual_guild_id(bl);
 
 #if PACKETVER < 20091103
 	if( !pcdb_checkid( vd->class_ ) ){
@@ -1231,7 +1235,7 @@
 		p.job = vd->class_;
 		if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
 			// The hell, why flags work like this?
-			p.shield = status_get_emblem_id( bl );
+			p.shield = clif_visual_emblem_id(bl);
 			p.accessory2 = GetWord( g_id, 1 );
 			p.accessory3 = GetWord( g_id, 0 );
 		}else{
@@ -1277,7 +1281,7 @@
 #endif
 	if( bl->type == BL_NPC && vd->class_ == JT_GUILD_FLAG ){
 		// The hell, why flags work like this?
-		p.accessory = status_get_emblem_id( bl );
+		p.accessory = clif_visual_emblem_id(bl);
 		p.accessory2 = GetWord( g_id, 1 );
 		p.accessory3 = GetWord( g_id, 0 );
 	}else{
@@ -1292,7 +1296,7 @@
 	p.robe = vd->robe;
 #endif
 	p.GUID = g_id;
-	p.GEmblemVer = status_get_emblem_id( bl );
+	p.GEmblemVer = clif_visual_emblem_id(bl);
 	p.honor = (sd) ? sd->status.manner : 0;
 	p.virtue = (sc) ? sc->opt3 : 0;
 	p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
@@ -1362,7 +1366,7 @@
 	struct status_change* sc = status_get_sc( bl );
 	struct view_data* vd = status_get_viewdata( bl );
 	struct packet_unit_walking p;
-	int g_id = status_get_guild_id(bl);
+	int g_id = clif_visual_guild_id(bl);
 
 	sd = BL_CAST(BL_PC, bl);
 
@@ -1400,7 +1404,7 @@
 	p.robe = vd->robe;
 #endif
 	p.GUID = g_id;
-	p.GEmblemVer = status_get_emblem_id(bl);
+	p.GEmblemVer = clif_visual_emblem_id(bl);
 	p.honor = (sd) ? sd->status.manner : 0;
 	p.virtue = (sc) ? sc->opt3 : 0;
 	p.isPKModeON = (sd && sd->status.karma) ? 1 : 0;
@@ -1632,7 +1636,7 @@
 				clif_specialeffect(bl,EF_GIANTBODY2,AREA);
 			else if(sd->state.size==SZ_MEDIUM)
 				clif_specialeffect(bl,EF_BABYBODY2,AREA);
-			if( sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND) )
+			if (battle_config.bg_eAmod_mode && sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND))
 				clif_sendbgemblem_area(sd);
 			if (sd->spiritcharm_type != CHARM_TYPE_NONE && sd->spiritcharm > 0)
 				clif_spiritcharm(sd);
@@ -2149,6 +2153,14 @@
 			if( !pc_can_sell_item(sd, &sd->inventory.u.items_inventory[i], nd->subtype))
 				continue;
 
+			if (sd->inventory.u.items_inventory[i].card[0] == CARD0_CREATE)
+			{ // Do not allow sell BG/WoE Consumables
+				if (battle_config.bg_reserved_char_id && MakeDWord(sd->inventory.u.items_inventory[i].card[2], sd->inventory.u.items_inventory[i].card[3]) == battle_config.bg_reserved_char_id)
+					continue;
+				if (battle_config.woe_reserved_char_id && MakeDWord(sd->inventory.u.items_inventory[i].card[2], sd->inventory.u.items_inventory[i].card[3]) == battle_config.woe_reserved_char_id)
+					continue;
+			}
+			
 			if (battle_config.rental_item_novalue && sd->inventory.u.items_inventory[i].expire_time)
 				val = 0;
 			else {
@@ -4773,7 +4785,7 @@
 				clif_specialeffect_single(bl,EF_GIANTBODY2,sd->fd);
 			else if(tsd->state.size==SZ_MEDIUM)
 				clif_specialeffect_single(bl,EF_BABYBODY2,sd->fd);
-			if( tsd->bg_id && map_getmapflag(tsd->bl.m, MF_BATTLEGROUND) )
+			if (battle_config.bg_eAmod_mode && tsd->bg_id && map_getmapflag(tsd->bl.m, MF_BATTLEGROUND))
 				clif_sendbgemblem_single(sd->fd,tsd);
 			if ( tsd->status.robe )
 				clif_refreshlook(&sd->bl,bl->id,LOOK_ROBE,tsd->status.robe,SELF);
@@ -8446,6 +8458,12 @@
 	nullpo_retv(sd);
 	nullpo_retv(g = sd->guild);
 
+	if( battle_config.bg_eAmod_mode && sd->bg_id )
+	{
+		clif_bg_belonginfo(sd);
+		return;
+	}
+	
 	fd=sd->fd;
 	ps=guild_getposition(sd);
 	WFIFOHEAD(fd,packet_len(0x16c));
@@ -8564,6 +8582,7 @@
 void clif_guild_basicinfo(struct map_session_data *sd) {
 	int fd;
 	struct guild *g;
+	struct battleground_data *bgd = NULL;
 #if PACKETVER < 20160622
 	int cmd = 0x1b6;
 	int offset = NAME_LENGTH;
@@ -8575,14 +8594,19 @@
 	nullpo_retv(sd);
 	fd = sd->fd;
 
-	if( (g = sd->guild) == NULL )
+	if (battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL)
+		bgd = bg_team_search(sd->bg_id);
+	else
+		g = sd->guild;
+
+	if (g == NULL)
 		return;
 
 	WFIFOHEAD(fd,packet_len(cmd));
 	WFIFOW(fd, 0)=cmd;
 	WFIFOL(fd, 2)=g->guild_id;
 	WFIFOL(fd, 6)=g->guild_lv;
-	WFIFOL(fd,10)=g->connect_member;
+	WFIFOL(fd,10)= bgd ? bgd->count : g->connect_member;
 	WFIFOL(fd,14)=g->max_member;
 	WFIFOL(fd,18)=g->average_lv;
 	WFIFOL(fd,22)=(uint32)cap_value(g->exp, 0, MAX_GUILD_EXP);
@@ -8613,7 +8637,9 @@
 	struct guild *g;
 
 	nullpo_retv(sd);
-	if( (g = sd->guild) == NULL )
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = sd->guild;
+	if( g == NULL )
 		return;
 
 	fd = sd->fd;
@@ -8632,6 +8658,44 @@
 	WFIFOSET(fd,WFIFOW(fd,2));
 }
 
+void clif_bg_memberlist(struct map_session_data *sd)
+{
+	int fd, i, c;
+	struct battleground_data *bgd;
+	struct map_session_data *psd;
+	nullpo_retv(sd);
+
+	if( (fd = sd->fd) == 0 )
+		return;
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (bgd = bg_team_search(sd->bg_id)) != NULL) )
+		return;
+
+	WFIFOHEAD(fd,bgd->count * 104 + 4);
+	WFIFOW(fd,0) = 0x154;
+	for( i = 0, c = 0; i < bgd->count; i++ )
+	{
+		if( (psd = bgd->members[i].sd) == NULL )
+			continue;
+		WFIFOL(fd,c*104+ 4) = psd->status.account_id;
+		WFIFOL(fd,c*104+ 8) = psd->status.char_id;
+		WFIFOW(fd,c*104+12) = psd->status.hair;
+		WFIFOW(fd,c*104+14) = psd->status.hair_color;
+		WFIFOW(fd,c*104+16) = psd->status.sex;
+		WFIFOW(fd,c*104+18) = psd->status.class_;
+		WFIFOW(fd,c*104+20) = psd->status.base_level;
+		WFIFOL(fd,c*104+22) = psd->bg_kills; // Exp slot used to show kills
+		WFIFOL(fd,c*104+26) = 1; // Online
+		WFIFOL(fd,c*104+30) = psd->bmaster_flag ? 0 : 1; // Position
+		if( psd->state.bg_afk )
+			memcpy(WFIFOP(fd,c*104+34),"AFK",50);
+		else
+			memset(WFIFOP(fd,c*104+34),0,50);
+		memcpy(WFIFOP(fd,c*104+84),psd->status.name,NAME_LENGTH);
+		c++;
+	}
+	WFIFOW(fd, 2)=c*104+4;
+	WFIFOSET(fd,WFIFOW(fd,2));
+}
 
 /// Guild member manager information
 /// 0154 <packet len>.W { <account>.L <char id>.L <hair style>.W <hair color>.W <gender>.W <class>.W <level>.W <contrib exp>.L <state>.L <position>.L <memo>.50B <name>.24B }* (ZC_MEMBERMGR_INFO)
@@ -8658,7 +8722,15 @@
 
 	if( !session_isActive(fd = sd->fd) )
 		return;
-	if( (g = sd->guild) == NULL )
+	if( battle_config.bg_eAmod_mode && sd->bg_id )
+	{
+		clif_bg_memberlist(sd);
+		return;
+	}
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = sd->guild;
+ 
+	if( g == NULL )
 		return;
 
 	WFIFOHEAD(fd, g->max_member * size + 4);
@@ -8698,7 +8770,10 @@
 	struct guild *g;
 
 	nullpo_retv(sd);
-	if( (g = sd->guild) == NULL )
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = sd->guild;
+
+	if( g == NULL )
 		return;
 
 	fd = sd->fd;
@@ -8726,7 +8801,10 @@
 	struct guild *g;
 
 	nullpo_retv(sd);
-	if( (g = sd->guild) == NULL )
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = sd->guild;
+
+	if( g == NULL )
 		return;
 
 	fd = sd->fd;
@@ -8831,8 +8909,8 @@
 	PACKET_ZC_CHANGE_GUILD p{};
 
 	p.packetType = HEADER_ZC_CHANGE_GUILD;
-	p.guild_id = status_get_guild_id(bl);
-	p.emblem_id = status_get_emblem_id(bl);
+	p.guild_id = clif_visual_guild_id(bl);
+	p.emblem_id = clif_visual_emblem_id(bl);
 
 #if PACKETVER < 20190724
 	p.aid = bl->id;
@@ -8853,7 +8931,10 @@
 	int i,c;
 
 	nullpo_retv(sd);
-	if( (g = sd->guild) == NULL )
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = sd->guild;
+
+	if( g == NULL )
 		return;
 
 	fd = sd->fd;
@@ -8888,7 +8969,11 @@
 	struct guild* g;
 
 	nullpo_retv(sd);
-	nullpo_retv(g = sd->guild);
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		g = sd->guild;
+
+	if( g == NULL )
+		return;
 
 	int fd = sd->fd;
 
@@ -9711,6 +9796,8 @@
 
 			map_session_data *sd = (map_session_data *)bl;
 
+			struct guild *g = NULL;
+			
 			//Requesting your own "shadow" name. [Skotlex]
 			if( src == bl && target == SELF && sd->disguise ){
 				packet.gid = -bl->id;
@@ -9735,7 +9822,15 @@
 				safestrncpy( packet.party_name, p->party.name, NAME_LENGTH );
 			}
 
-			if( sd->guild ){
+			if (battle_config.bg_eAmod_mode && sd->bg_id)
+			{
+				int ps = -1;
+				g = bg_guild_get(sd->bg_id);
+				ps = sd->bmaster_flag ? 0 : 1;
+				safestrncpy( packet.guild_name, g->name,NAME_LENGTH);
+				safestrncpy( packet.position_name, g->position[ps].name, NAME_LENGTH);
+			}
+			else if( sd->guild ){
 				int position;
 
 				// Will get the position of the guild the player is in
@@ -10150,6 +10245,9 @@
 	nullpo_retv(sd);
 	fd = sd->fd;
 
+	if (sd->bg_id && id == WORK_IN_PROGRESS) // BG eAmod
+		return;
+	
 	WFIFOHEAD(fd, packet_len(0x291));
 	WFIFOW(fd, 0) = 0x291;
 	WFIFOW(fd, 2) = id;  // zero-based msgstringtable.txt index
@@ -10338,6 +10436,8 @@
 		sd->idletime_hom = last_tick;
 	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_CHAT)
 		sd->idletime_mer = last_tick;
+	if (sd && sd->bg_id)
+		pc_update_last_action(sd);
 
 	//achievement_update_objective(sd, AG_CHATTING, 1, 1); // !TODO: Confirm how this achievement is triggered
 
@@ -11154,6 +11254,8 @@
 		sd->idletime_hom = last_tick;
 	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_WALK)
 		sd->idletime_mer = last_tick;
+	if (sd && sd->bg_id)
+		pc_update_last_action(sd);
 
 	unit_walktoxy(&sd->bl, x, y, 4);
 }
@@ -11375,6 +11477,8 @@
 			sd->idletime_hom = last_tick;
 		if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_EMOTION)
 			sd->idletime_mer = last_tick;
+		if (sd && sd->bg_id)
+			pc_update_last_action(sd);
 
 		if (sd->state.block_action & PCBLOCK_EMOTION) {
 			clif_skill_fail(sd, 1, USESKILL_FAIL_LEVEL, 1);
@@ -11463,6 +11567,8 @@
 			sd->idletime_hom = last_tick;
 		if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_ATTACK)
 			sd->idletime_mer = last_tick;
+		if (sd && sd->bg_id)
+			pc_update_last_action(sd);
 		unit_attack(&sd->bl, target_id, action_type != 0);
 		break;
 	case 0x02: // sitdown
@@ -11497,6 +11603,8 @@
 			sd->idletime_hom = last_tick;
 		if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_SIT)
 			sd->idletime_mer = last_tick;
+		if (sd && sd->bg_id)
+			pc_update_last_action(sd);
 
 		pc_setsit(sd);
 		skill_sit(sd, true);
@@ -11524,6 +11632,8 @@
 				sd->idletime_hom = last_tick;
 			if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_SIT)
 				sd->idletime_mer = last_tick;
+			if (sd && sd->bg_id)
+				pc_update_last_action(sd);
 			skill_sit(sd, false);
 			clif_standing(&sd->bl);
 		}
@@ -11785,6 +11895,8 @@
 			sd->idletime_hom = last_tick;
 		if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_DROPITEM)
 			sd->idletime_mer = last_tick;
+		if (sd && sd->bg_id)
+			pc_update_last_action(sd);
 
 		return;
 	}
@@ -11819,6 +11931,8 @@
 		sd->idletime_hom = last_tick;
 	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USEITEM)
 		sd->idletime_mer = last_tick;
+	if (sd && sd->bg_id)
+			pc_update_last_action(sd);
 	n = RFIFOW(fd,packet_db[RFIFOW(fd,0)].pos[0])-2;
 
 	if(n <0 || n >= MAX_INVENTORY)
@@ -11870,6 +11984,8 @@
 		sd->idletime_hom = last_tick;
 	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USEITEM)
 		sd->idletime_mer = last_tick;
+	if (sd && sd->bg_id)
+			pc_update_last_action(sd);
 
 	//Client doesn't send the position for ammo.
 	if(sd->inventory_data[index]->type == IT_AMMO)
@@ -11913,6 +12029,8 @@
 		sd->idletime_hom = last_tick;
 	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USEITEM)
 		sd->idletime_mer = last_tick;
+	if (sd && sd->bg_id)
+			pc_update_last_action(sd);
 
 	pc_unequipitem(sd,index,1);
 }
@@ -12575,6 +12693,8 @@
 		sd->idletime_hom = last_tick;
 	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USESKILLTOID)
 		sd->idletime_mer = last_tick;
+	if (sd && sd->bg_id)
+			pc_update_last_action(sd);
 
 	if( sd->npc_id ){
 		if( pc_hasprogress( sd, WIP_DISABLE_SKILLITEM ) || !sd->npc_item_flag || !( inf & INF_SELF_SKILL ) ){
@@ -12641,7 +12761,24 @@
 	sd->skillitem = sd->skillitemlv = 0;
 
 	if( SKILL_CHK_GUILD(skill_id) ) {
-		if( sd->state.gmaster_flag || skill_id == GD_CHARGESHOUT_BEATING )
+		if (map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
+			struct battleground_data *bgd;
+			int idx = skill_id - GD_SKILLBASE;
+			if( idx < 0 || idx >= MAX_GUILDSKILL )
+				skill_lv = 0;
+			if( (bgd = sd->bmaster_flag) != NULL )
+			{
+				if (bgd->skill_block_timer[idx] == INVALID_TIMER)
+					skill_lv = bg_checkskill(bgd, skill_id);
+				else
+				{
+					bg_block_skill_status(bgd, skill_id);
+					skill_lv = 0;
+				}
+			}
+			else
+				skill_lv = 0;
+		} else if( sd->state.gmaster_flag || skill_id == GD_CHARGESHOUT_BEATING )
 			skill_lv = guild_checkskill(sd->guild, skill_id);
 		else
 			skill_lv = 0;
@@ -12707,6 +12844,8 @@
 		sd->idletime_hom = last_tick;
 	if (battle_config.mer_idle_no_share && sd->md && battle_config.idletime_mer_option&IDLE_USESKILLTOPOS)
 		sd->idletime_mer = last_tick;
+	if (sd && sd->bg_id)
+		pc_update_last_action(sd);
 
 	if( skill_isNotOk(skill_id, sd) )
 		return;
@@ -13941,10 +14080,14 @@
 void clif_parse_GuildRequestEmblem(int fd,struct map_session_data *sd)
 {
 	struct guild* g;
-	int guild_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]);
+	int guild_id = RFIFOL(fd,packet_db[RFIFOW(fd,0)].pos[0]),i;
 
 	if( (g = guild_search(guild_id)) != NULL )
 		clif_guild_emblem(sd,g);
+	else if( guild_id > INT16_MAX - 13 && guild_id <= INT16_MAX ) {
+		i = (int)(INT16_MAX - guild_id);
+		clif_bg_emblem(sd, &bg_guild[i]);
+	}
 }
 
 
@@ -17095,6 +17238,42 @@
 	WFIFOSET(fd,70);
 }
 
+/// Check Equip
+/// 0442 <Length>.W <count>.L <Skill_list>.W (ZC_SKILL_SELECT_REQUEST).
+int clif_skill_select_list(struct map_session_data *sd) {
+	int i;
+	int fd;
+	unsigned short skills[3];
+	memset(skills, 0, sizeof(skills));
+	skills[0] = CS_EQUIPMENT;
+	skills[1] = CS_BG;
+	skills[2] = CS_WOE;
+
+	nullpo_ret(sd);
+
+	fd = sd->fd;
+
+	if (!fd)
+		return 0;
+	
+	WFIFOHEAD(fd, 8 + 3 * 2);
+	WFIFOW(fd, 0) = 0x442;
+
+	for (i = 0; i < 3; i++)
+		WFIFOW(fd, 8 + i * 2) = skills[i];
+	
+	WFIFOW(fd, 2) = 8 + 3 * 2;
+	WFIFOL(fd, 4) = 3;
+	WFIFOSET(fd, WFIFOW(fd, 2));
+
+	sd->menuskill_id = SC_AUTOSHADOWSPELL;
+	sd->menuskill_val = 3;
+
+	sd->state.check_equip_skill = true;
+	sd->state.workinprogress = WIP_DISABLE_ALL;
+
+	return 1;
+}
 
 /// Requesting equip of a player (CZ_EQUIPWIN_MICROSCOPE).
 /// 02d6 <account id>.L
@@ -17108,7 +17287,12 @@
 
 	if (sd->bl.m != tsd->bl.m)
 		return;
-	else if( tsd->status.show_equip || pc_has_permission(sd, PC_PERM_VIEW_EQUIPMENT) )
+	if (battle_config.bg_extended_check_equip) { //Yumi Doubt #2
+		sd->ce_gid = tsd->status.account_id;
+		clif_skill_select_list(sd);
+		return;
+	}
+	if( tsd->status.show_equip || pc_has_permission(sd, PC_PERM_VIEW_EQUIPMENT) )
 		clif_viewequip_ack(sd, tsd);
 	else
 		clif_msg(sd, VIEW_EQUIP_FAIL);
@@ -17811,6 +17995,29 @@
 
 /// Battlegrounds
 ///
+int clif_visual_guild_id(struct block_list *bl)
+{
+	struct battleground_data *bgd;
+	int bg_id;
+	nullpo_ret(bl);
+ 
+	if( battle_config.bg_eAmod_mode && (bg_id = bg_team_get_id(bl)) > 0 && (bgd = bg_team_search(bg_id)) != NULL && bgd->g )
+		return bgd->g->guild_id;
+	else
+		return status_get_guild_id(bl);
+}
+
+int clif_visual_emblem_id(struct block_list *bl)
+{
+	struct battleground_data *bgd;
+	int bg_id;
+	nullpo_ret(bl);
+
+	if( battle_config.bg_eAmod_mode && (bg_id = bg_team_get_id(bl)) > 0 && (bgd = bg_team_search(bg_id)) != NULL && bgd->g )
+		return bgd->g->emblem_id;
+	else
+		return status_get_emblem_id(bl);
+}
 
 /// Updates HP bar of a camp member.
 /// 02e0 <account id>.L <name>.24B <hp>.W <max hp>.W (ZC_BATTLEFIELD_NOTIFY_HP)
@@ -17883,7 +18090,7 @@
 
 /// Notifies clients of a battleground message.
 /// 02DC <packet len>.W <account id>.L <name>.24B <message>.?B (ZC_BATTLEFIELD_CHAT)
-void clif_bg_message( struct s_battleground_data *bg, int src_id, const char *name, const char *mes, int len ){
+void clif_bg_message( struct battleground_data *bg, int src_id, const char *name, const char *mes, int len ){
 	struct map_session_data *sd = bg_getavailablesd( bg );
 
 	if( sd == nullptr ){
@@ -17904,6 +18111,120 @@
 	clif_send(buf,WBUFW(buf,2), &sd->bl, BG);
 }
 
+void clif_bg_updatescore_team(struct battleground_data *bgd)
+{
+	unsigned char buf[6];
+	struct map_session_data *sd;
+	int i, m;
+
+	nullpo_retv(bgd);
+
+	if( (m = map_mapindex2mapid(bgd->mapindex)) < 0 )
+		return;
+
+	WBUFW(buf,0) = 0x2de;
+	WBUFW(buf,2) = bgd->team_score;
+	WBUFW(buf,4) = map[m].bgscore_top;
+
+	for (i = 0; i < MAX_BG_MEMBERS; i++)
+	{
+		if ((sd = bgd->members[i].sd) == NULL || sd->bl.m != m)
+			continue;
+
+		clif_send(buf, packet_len(0x2de), &sd->bl, SELF);
+	}
+}
+
+void clif_bg_leave_single(struct map_session_data *sd, const char *name, const char *mes)
+{
+	int fd;
+	nullpo_retv(sd);
+
+	fd = sd->fd;
+	WFIFOHEAD(fd, 66);
+	WFIFOW(fd, 0) = 0x15a;
+	memcpy(WFIFOP(fd, 2), name, NAME_LENGTH);
+	memcpy(WFIFOP(fd, 26), mes, 40);
+	WFIFOSET(fd, 66);
+}
+
+void clif_bg_expulsion_single(struct map_session_data *sd, const char *name, const char *mes)
+{
+	int fd;
+
+#if PACKETVER < 20100803
+	const unsigned short cmd = 0x15c;
+#else
+	const unsigned short cmd = 0x839;
+#endif
+
+	nullpo_retv(sd);
+
+	fd = sd->fd;
+
+	WFIFOHEAD(fd, packet_len(cmd));
+	WFIFOW(fd, 0) = cmd;
+	safestrncpy((char*)WFIFOP(fd, 2), name, NAME_LENGTH);
+	safestrncpy((char*)WFIFOP(fd,26), mes, 40);
+#if PACKETVER < 20100803
+	safestrncpy((char*)WFIFOP(fd,66), "", NAME_LENGTH);
+#endif
+	WFIFOSET(fd, packet_len(cmd));
+}
+
+void clif_bg_belonginfo(struct map_session_data *sd)
+{
+	int fd;
+	struct guild *g;
+	nullpo_retv(sd);
+
+	if( !(battle_config.bg_eAmod_mode && sd->bg_id && (g = bg_guild_get(sd->bg_id)) != NULL) )
+		return;
+
+	fd = sd->fd;
+	WFIFOHEAD(fd,packet_len(0x16c));
+	memset(WFIFOP(fd,0),0,packet_len(0x16c));
+	WFIFOW(fd,0) = 0x16c;
+	WFIFOL(fd,2) = g->guild_id;
+	WFIFOL(fd,6) = g->emblem_id;
+	WFIFOL(fd,10) = 0;
+	WFIFOB(fd,14) = 0;
+	WFIFOL(fd,15) = 0;
+	memcpy(WFIFOP(fd,19), g->name, NAME_LENGTH);
+	WFIFOSET(fd,packet_len(0x16c));
+}
+
+void clif_bg_emblem(struct map_session_data *sd, struct guild *g)
+{
+	int fd;
+
+	nullpo_retv(sd);
+	nullpo_retv(g);
+
+	if( g->emblem_len <= 0 )
+		return;
+
+	fd = sd->fd;
+	WFIFOHEAD(fd,g->emblem_len+12);
+	WFIFOW(fd,0)=0x152;
+	WFIFOW(fd,2)=g->emblem_len+12;
+	WFIFOL(fd,4)=g->guild_id;
+	WFIFOL(fd,8)=g->emblem_id;
+	memcpy(WFIFOP(fd,12),g->emblem_data,g->emblem_len);
+	WFIFOSET(fd,WFIFOW(fd,2));
+}
+
+void clif_bg_leave(struct map_session_data *sd, const char *name, const char *mes)
+{
+	unsigned char buf[128];
+	nullpo_retv(sd);
+
+	WBUFW(buf,0)=0x15a;
+	memcpy(WBUFP(buf, 2),name,NAME_LENGTH);
+	memcpy(WBUFP(buf,26),mes,40);
+	clif_send(buf,packet_len(0x15a),&sd->bl,BG);
+}
+
 /// Validates and processes battlechat messages.
 /// All messages that are sent after enabling battleground chat with /battlechat.
 /// 02DB <packet len>.W <text>.?B (CZ_BATTLEFIELD_CHAT)
@@ -17938,6 +18259,7 @@
 void clif_bg_updatescore_single(struct map_session_data *sd)
 {
 	int fd;
+	struct battleground_data *bg;
 	nullpo_retv(sd);
 	fd = sd->fd;
 
@@ -17945,8 +18267,13 @@
 
 	WFIFOHEAD(fd,packet_len(0x2de));
 	WFIFOW(fd,0) = 0x2de;
-	WFIFOW(fd,2) = mapdata->bgscore_lion;
-	WFIFOW(fd,4) = mapdata->bgscore_eagle;
+	if (map_getmapflag(sd->bl.m, MF_BATTLEGROUND) == 2) {
+		WFIFOW(fd,2) = mapdata->bgscore_lion;
+		WFIFOW(fd,4) = mapdata->bgscore_eagle;
+	} else if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) == 3 && (bg = bg_team_search(sd->bg_id)) != NULL ) {
+		WFIFOW(fd,2) = bg->team_score;
+		WFIFOW(fd,4) = mapdata->bgscore_top;
+	}
 	WFIFOSET(fd,packet_len(0x2de));
 }
 
@@ -17981,31 +18308,46 @@
 /// 0x8d7 <queue type>.W <battleground name>.24B (CZ_REQ_ENTRY_QUEUE_APPLY)
 void clif_parse_bg_queue_apply_request(int fd, struct map_session_data *sd)
 {
-	if (!battle_config.feature_bgqueue)
+	if (!battle_config.bg_queue_interface)
 		return;
 
 	nullpo_retv(sd);
 
 	short type = RFIFOW(fd,2);
 	char name[NAME_LENGTH];
-
+	char event[128];
+	
 	safestrncpy(name, RFIFOCP(fd, 4), NAME_LENGTH);
 
-	if (sd->bg_queue_id > 0) {
-		//ShowWarning("clif_parse_bg_queue_apply_request: Received duplicate queue application: %d from player %s (AID:%d CID:%d).\n", type, sd->status.name, sd->status.account_id, sd->status.char_id);
-		clif_bg_queue_apply_result(BG_APPLY_DUPLICATE, name, sd); // Duplicate application warning
-		return;
-	} else if (type == 1) // Solo
-		bg_queue_join_solo(name, sd);
-	else if (type == 2) // Party
-		bg_queue_join_party(name, sd);
-	else if (type == 4) // Guild
-		bg_queue_join_guild(name, sd);
+	if (sd->bg_id) {
+		clif_bg_queue_apply_result(BG_APPLY_INVALID_APP, name, sd);
+		return;
+	}
+
+	if (stristr(name, "Capture"))
+		sprintf(event,"CTF_BG_Queue::OnJoinBG");
+	else if (stristr(name, "DeathMatch"))
+		sprintf(event,"TD_BG_Queue::OnJoinBG");
+	else if (stristr(name, "Conquest"))
+		sprintf(event,"CQ_BG_Queue::OnJoinBG");
+	else if (stristr(name, "Rush"))
+		sprintf(event,"RU_BG_Queue::OnJoinBG");
+	else if (stristr(name, "Inferno"))
+		sprintf(event,"TI_BG_Queue::OnJoinBG");
+	else if (stristr(name, "Storm"))
+		sprintf(event,"EOS_BG_Queue::OnJoinBG");
+	else if (stristr(name, "Domination"))
+		sprintf(event,"DOM_BG_Queue::OnJoinBG");
+	else if (stristr(name, "Boss"))
+		sprintf(event,"BOSS_BG_Queue::OnJoinBG");
+	else if (stristr(name, "Stone"))
+		sprintf(event,"SC_BG_Queue::OnJoinBG");
 	else {
-		ShowWarning("clif_parse_bg_queue_apply_request: Received invalid queue type: %d from player %s (AID:%d CID:%d).\n", type, sd->status.name, sd->status.account_id, sd->status.char_id);
-		clif_bg_queue_apply_result(BG_APPLY_INVALID_APP, name, sd); // Someone sent an invalid queue type packet
+		clif_bg_queue_apply_result(BG_APPLY_INVALID_NAME, name, sd);
 		return;
 	}
+	
+	npc_event_do_id(event, sd->bl.id);
 }
 
 /// Outgoing battlegrounds queue apply result.
@@ -18029,11 +18371,10 @@
 /// 0x8d9 <battleground name>.24B <queue number>.L (ZC_NOTIFY_ENTRY_QUEUE_APPLY)
 void clif_bg_queue_apply_notify(const char *name, struct map_session_data *sd)
 {
+	struct queue_data *qd;
 	nullpo_retv(sd);
 
-	std::shared_ptr<s_battleground_queue> queue = bg_search_queue(sd->bg_queue_id);
-
-	if (queue == nullptr) {
+	if ((qd = sd->qd) == NULL) {
 		ShowError("clif_bg_queue_apply_notify: Player is not in a battleground queue.\n");
 		return;
 	}
@@ -18042,8 +18383,8 @@
 
 	WFIFOHEAD(fd, packet_len(0x8d9));
 	WFIFOW(fd,0) = 0x8d9;
-	safestrncpy(WFIFOCP(fd,2), name, NAME_LENGTH);
-	WFIFOL(fd,2+NAME_LENGTH) = queue->teama_members.size() + queue->teamb_members.size();
+	safestrncpy(WFIFOCP(fd,2), qd->queue_name, NAME_LENGTH);
+	WFIFOL(fd,2+NAME_LENGTH) = bg_queue_member_search(qd, sd->bl.id);
 	WFIFOSET(fd, packet_len(0x8d9));
 }
 
@@ -18066,20 +18407,16 @@
 /// 0x8da <battleground name>.24B (CZ_REQ_ENTRY_QUEUE_CANCEL)
 void clif_parse_bg_queue_cancel_request(int fd, struct map_session_data *sd)
 {
-	if (!battle_config.feature_bgqueue)
+	if (!battle_config.bg_queue_interface)
 		return;
 
 	nullpo_retv(sd);
 
 	bool success;
 
-	if (sd->bg_queue_id > 0) {
-		std::shared_ptr<s_battleground_queue> queue = bg_search_queue(sd->bg_queue_id);
-
-		if (queue && queue->state == QUEUE_STATE_SETUP_DELAY)
-			return; // Make the cancel button do nothing if the entry window is open. Otherwise it'll crash the game when you click on both the queue status and entry status window.
-		else
-			success = bg_queue_leave(sd);
+	if (sd->qd) {
+		bg_queue_leaveall(sd);
+		success = true;
 	} else {
 		ShowWarning("clif_parse_bg_queue_cancel_request: Player trying to request leaving non-existent queue with name: %s (AID:%d CID:%d).\n", sd->status.name, sd->status.account_id, sd->status.char_id);
 		success = false;
@@ -18092,56 +18429,6 @@
 	clif_bg_queue_cancel_result(success, name, sd);
 }
 
-/// Battleground is ready to be joined, send a window asking for players to accept or decline.
-/// 0x8df <battleground name>.24B <lobby name>.24B (ZC_NOTIFY_LOBBY_ADMISSION)
-void clif_bg_queue_lobby_notify(const char *name, struct map_session_data *sd)
-{
-	nullpo_retv(sd);
-
-	int fd = sd->fd;
-
-	WFIFOHEAD(fd, packet_len(0x8df));
-	WFIFOW(fd,0) = 0x8df;
-	safestrncpy(WFIFOCP(fd,2), name, NAME_LENGTH);
-	safestrncpy(WFIFOCP(fd,2+NAME_LENGTH), name, NAME_LENGTH);
-	WFIFOSET(fd, packet_len(0x8df));
-}
-
-/// Incoming packet from client telling server whether player wants to enter battleground or cancel.
-/// Result types: 1(Accept), 2(Decline).
-/// 0x8e0 <result>.B <battleground name>.24B <lobby name>.24B (CZ_REPLY_LOBBY_ADMISSION)
-void clif_parse_bg_queue_lobby_reply(int fd, struct map_session_data *sd)
-{
-	nullpo_retv(sd);
-
-	if(sd->bg_queue_id > 0) {
-		uint8 result = RFIFOB(fd, 2);
-
-		if(result == 1) { // Accept
-			bg_queue_on_accept_invite(sd);
-		} else if(result == 2) { // Decline
-			bg_queue_leave(sd);
-			clif_bg_queue_entry_init(sd);
-		}
-	}
-}
-
-/// Plays a gong sound, signaling that someone has accepted the invite to enter a battleground.
-/// 0x8e1 <result>.B <battleground name>.24B <lobby name>.24B (ZC_REPLY_ACK_LOBBY_ADMISSION)
-void clif_bg_queue_ack_lobby(bool result, const char *name, const char *lobbyname, struct map_session_data *sd)
-{
-	nullpo_retv(sd);
-
-	int fd = sd->fd;
-
-	WFIFOHEAD(fd, packet_len(0x8e1));
-	WFIFOW(fd,0) = 0x8e1;
-	WFIFOB(fd,2) = result;
-	safestrncpy(WFIFOCP(fd,3), name, NAME_LENGTH);
-	safestrncpy(WFIFOCP(fd,3+NAME_LENGTH), lobbyname, NAME_LENGTH);
-	WFIFOSET(fd, packet_len(0x8e1));
-}
-
 /// Battlegrounds queue incoming queue number request from client.
 /// 0x90a <battleground name>.24B (CZ_REQ_ENTRY_QUEUE_RANKING)
 void clif_parse_bg_queue_request_queue_number(int fd, struct map_session_data *sd)
@@ -19205,6 +19492,41 @@
 		sd->state.workinprogress = WIP_DISABLE_NONE;
 		skill_autospell(sd, RFIFOW(fd, info->pos[1]));
 	} else if (sd->menuskill_id == SC_AUTOSHADOWSPELL) {
+		// Check Equip 
+		if (sd->state.check_equip_skill) {
+			int skill = RFIFOW(fd, info->pos[1]);
+			struct map_session_data *tsd = map_id2sd(sd->ce_gid);
+
+			sd->state.check_equip_skill = false;
+			sd->state.workinprogress = WIP_DISABLE_NONE;
+			clif_menuskill_clear(sd);
+
+			if (!tsd) {
+				clif_displaymessage(fd,"Player not found.");
+				return;
+			}
+
+			if (!(skill >= 780 && skill <= 782))
+				return;
+
+			switch(skill) {
+				case CS_EQUIPMENT:
+					if( tsd->status.show_equip || pc_has_permission(sd, PC_PERM_VIEW_EQUIPMENT) )
+						clif_viewequip_ack(sd, tsd);
+					else
+						clif_msg(sd, VIEW_EQUIP_FAIL);
+					break;
+				case CS_BG:
+					pc_battle_stats(sd,tsd,1);
+					break;
+				case CS_WOE:
+					pc_battle_stats(sd,tsd,2);
+					break;
+				default:
+					return;
+			}	
+			return;
+		}
 		if (pc_istrading(sd)) {
 			clif_skill_fail(sd, sd->ud.skill_id, USESKILL_FAIL_LEVEL, 0);
 			clif_menuskill_clear(sd);
@@ -21579,6 +21901,26 @@
 #endif
 }
 
+void clif_rank_info(struct map_session_data *sd, int points, int total, int flag)
+{
+	char message[100];
+
+	if (flag) {
+		if( points < 0 )
+			sprintf(message, "[Your Battleground Rank -%d = %d points]", points, total);
+		else
+			sprintf(message, "[Your Battleground Rank +%d = %d points]", points, total);
+	} else {
+		if( points < 0 )
+			sprintf(message, "[Your War of Emperium Rank -%d = %d points]", points, total);
+		else
+			sprintf(message, "[Your War of Emperium Rank +%d = %d points]", points, total);
+	}
+
+	clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], message, false, SELF);
+	//clif_displaymessage(sd->fd, message);
+}
+
 void clif_parse_StartUseSkillToId( int fd, struct map_session_data* sd ){
 #if PACKETVER_MAIN_NUM >= 20181002 || PACKETVER_RE_NUM >= 20181002 || PACKETVER_ZERO_NUM >= 20181010
 	const struct PACKET_CZ_START_USE_SKILL *p = (struct PACKET_CZ_START_USE_SKILL *)RFIFOP( fd, 0 );
Index: src/map/clif.hpp
===================================================================
diff --git a/src/map/clif.hpp b/src/map/clif.hpp
--- a/src/map/clif.hpp	c8c5daa19ee
+++ b/src/map/clif.hpp	17bb23019aa
@@ -35,7 +35,7 @@
 struct party;
 struct party_data;
 struct guild;
-struct s_battleground_data;
+struct battleground_data;
 struct quest;
 struct party_booking_ad_info;
 struct sale_item_data;
@@ -224,6 +224,7 @@
 	BG_SAMEMAP_WOS,
 	BG_AREA,
 	BG_AREA_WOS,
+	BG_LISTEN,
 
 	CLAN,				// Clan System
 };
@@ -829,18 +830,20 @@
 void clif_bg_hp(struct map_session_data *sd);
 void clif_bg_xy(struct map_session_data *sd);
 void clif_bg_xy_remove(struct map_session_data *sd);
-void clif_bg_message(struct s_battleground_data *bg, int src_id, const char *name, const char *mes, int len);
+void clif_bg_message(struct battleground_data *bg, int src_id, const char *name, const char *mes, int len);
 void clif_bg_updatescore(int16 m);
 void clif_bg_updatescore_single(struct map_session_data *sd);
 void clif_sendbgemblem_area(struct map_session_data *sd);
 void clif_sendbgemblem_single(int fd, struct map_session_data *sd);
-
-// Battleground Queue
-void clif_bg_queue_apply_result(e_bg_queue_apply_ack result, const char *name, struct map_session_data *sd);
-void clif_bg_queue_apply_notify(const char *name, struct map_session_data *sd);
-void clif_bg_queue_entry_init(struct map_session_data *sd);
-void clif_bg_queue_lobby_notify(const char *name, struct map_session_data *sd);
-void clif_bg_queue_ack_lobby(bool result, const char *name, const char *lobbyname, struct map_session_data *sd);
+// Battleground eAmod
+void clif_bg_belonginfo (struct map_session_data *sd);
+int clif_visual_guild_id (struct block_list *bl);
+int clif_visual_emblem_id (struct block_list *bl);
+void clif_bg_emblem (struct map_session_data *sd, struct guild *g);
+void clif_bg_memberlist (struct map_session_data *sd);
+void clif_bg_leave_single (struct map_session_data *sd, const char *name, const char *mes);
+void clif_bg_expulsion_single (struct map_session_data *sd, const char *name, const char *mes);
+void clif_bg_updatescore_team (struct battleground_data *bg);
 
 // Instancing
 void clif_instance_create(int instance_id, int num);
@@ -1146,6 +1149,15 @@
 /// Pet evolution
 void clif_pet_evolution_result( struct map_session_data* sd, e_pet_evolution_result result );
 
+void clif_rank_info(struct map_session_data *sd, int points, int total, int flag);
+
+void clif_parse_bg_queue_apply_request(int fd, struct map_session_data *sd);// Battleground Queue
+void clif_bg_queue_apply_result(e_bg_queue_apply_ack result, const char *name, struct map_session_data *sd);
+void clif_bg_queue_apply_notify(const char *name, struct map_session_data *sd);
+void clif_bg_queue_entry_init(struct map_session_data *sd);
+void clif_bg_queue_lobby_notify(const char *name, struct map_session_data *sd);
+void clig_bg_queue_ack_lobby(bool result, const char *name, const char *lobbyname, struct map_session_data *sd);
+
 void clif_parse_skill_toid( struct map_session_data* sd, uint16 skill_id, uint16 skill_lv, int target_id );
 
 #endif /* CLIF_HPP */
Index: src/map/clif_packetdb.hpp
===================================================================
diff --git a/src/map/clif_packetdb.hpp b/src/map/clif_packetdb.hpp
--- a/src/map/clif_packetdb.hpp	e3660a84650
+++ b/src/map/clif_packetdb.hpp	6a271d45f65
@@ -1948,7 +1948,7 @@
 	parseable_packet(0x08DD,27,clif_parse_dull,2,3);
 	packet(0x08DE,27);
 	packet(0x08DF,50);
-	parseable_packet(0x08E0,51,clif_parse_bg_queue_lobby_reply,2,3,27);
+	//parseable_packet(0x08E0,51,clif_parse_bg_queue_lobby_reply,2,3,27);
 	packet(0x08E1,51);
 	parseable_packet(0x090A,26,clif_parse_bg_queue_request_queue_number,2);
 	packet(0x090E,2);
@@ -2370,6 +2370,7 @@
 	packet(0x0AE2,7);
 	parseable_packet(0x0AEF,2,clif_parse_attendance_request,0);
 	packet(0x0AF0,10);
+	packet(0x0adf,58);  // ZC_ACK_REQNAME_TITLE
 #endif
 
 // 2018-03-21aRagexeRE
Index: src/map/itemdb.cpp
===================================================================
diff --git a/src/map/itemdb.cpp b/src/map/itemdb.cpp
--- a/src/map/itemdb.cpp	731089e4c71
+++ b/src/map/itemdb.cpp	f0de713107d
@@ -28,6 +28,8 @@
 static DBMap *itemdb_group; /// Item Group DB
 
 struct s_roulette_db rd;
+struct s_bg_reward bgr[MAX_FAME_LIST];
+struct s_woe_reward woer[MAX_FAME_LIST];
 
 static void itemdb_jobid2mapid(uint64 bclass[3], e_mapid jobmask, bool active);
 
@@ -35,6 +37,84 @@
 	return std::string(db_path) + "/item_db.yml";
 }
 
+/**
+* BG Reward read db
+**/
+static bool itemdb_read_bgreward(char* fields[], int columns, int current)
+{
+	struct item_data* id;
+	unsigned short nameid, amount;
+	int zeny;
+
+	nameid = atoi(fields[0]);
+	amount = atoi(fields[1]);
+	zeny = atoi(fields[2]);
+
+	if ((id = itemdb_exists(nameid)) == NULL)
+	{
+		ShowWarning("itemdb_read_bgreward: Invalid item id %hu.\n", nameid);
+		return false;
+	}
+
+	if (amount <= 0)
+	{
+		ShowWarning("itemdb_read_bgreward: Invalid item amount %hu.\n", amount);
+		return false;
+	}
+
+	if (zeny < 0)
+	{
+		ShowWarning("itemdb_read_bgreward: Invalid zeny amount %hu.\n", zeny);
+		return false;
+	}
+		
+
+	bgr[current].nameid = nameid;
+	bgr[current].amount = amount;
+	bgr[current].zeny = zeny;
+
+	return true;
+}
+
+/**
+* WoE Reward read db
+**/
+static bool itemdb_read_woereward(char* fields[], int columns, int current)
+{
+	struct item_data* id;
+	unsigned short nameid, amount;
+	int zeny;
+
+	nameid = atoi(fields[0]);
+	amount = atoi(fields[1]);
+	zeny = atoi(fields[2]);
+
+	if ((id = itemdb_exists(nameid)) == NULL)
+	{
+		ShowWarning("itemdb_read_woereward: Invalid item id %hu.\n", nameid);
+		return false;
+	}
+
+	if (amount <= 0)
+	{
+		ShowWarning("itemdb_read_woereward: Invalid item amount %hu.\n", amount);
+		return false;
+	}
+
+	if (zeny < 0)
+	{
+		ShowWarning("itemdb_read_woereward: Invalid zeny amount %hu.\n", zeny);
+		return false;
+	}
+		
+
+	woer[current].nameid = nameid;
+	woer[current].amount = amount;
+	woer[current].zeny = zeny;
+
+	return true;
+}
+
 /**
  * Reads and parses an entry from the item_db.
  * @param node: YAML node containing the entry.
@@ -2654,6 +2734,8 @@
 		sv_readdb(dbsubpath1, "item_findingore.txt",	',', 2, 10, -1, &itemdb_read_group, i > 0);
 		sv_readdb(dbsubpath2, "item_giftbox.txt",		',', 2, 10, -1, &itemdb_read_group, i > 0);
 		sv_readdb(dbsubpath2, "item_misc.txt",			',', 2, 10, -1, &itemdb_read_group, i > 0);
+		sv_readdb(dbsubpath1, "bg_rewards.txt",			',', 3, 3, MAX_FAME_LIST, &itemdb_read_bgreward, i > 0);
+		sv_readdb(dbsubpath1, "woe_rewards.txt",		',', 3, 3, MAX_FAME_LIST, &itemdb_read_woereward, i > 0);
 #ifdef RENEWAL
 		sv_readdb(dbsubpath2, "item_package.txt",		',', 2, 10, -1, &itemdb_read_group, i > 0);
 #endif
@@ -2727,6 +2809,8 @@
 	struct map_session_data* sd;
 
 	item_db.clear();
+	memset(bgr, 0, sizeof(bgr));
+	memset(woer, 0, sizeof(woer));
 	itemdb_combo.clear();
 	itemdb_group->clear(itemdb_group, itemdb_group_free);
 	random_option_db.clear();
Index: src/map/itemdb.hpp
===================================================================
diff --git a/src/map/itemdb.hpp b/src/map/itemdb.hpp
--- a/src/map/itemdb.hpp	ee0c77dcc87
+++ b/src/map/itemdb.hpp	603ae0c44db
@@ -60,6 +60,7 @@
 	ITEMID_POISON_BOTTLE				= 678,
 	ITEMID_EMPTY_BOTTLE					= 713,
 	ITEMID_EMPERIUM						= 714,
+	ITEMID_YELLOW_GEMSTONE				= 715,
 	ITEMID_RED_GEMSTONE					= 716,
 	ITEMID_BLUE_GEMSTONE				= 717,
 	ITEMID_ORIDECON_STONE				= 756,
@@ -846,6 +847,20 @@
 };
 extern struct s_roulette_db rd;
 
+/// Struct of BG Reward db
+struct s_bg_reward {
+	unsigned short nameid, amount;
+	int zeny;
+};
+extern struct s_bg_reward bgr[MAX_FAME_LIST];
+
+/// Struct of WoE Reward db
+struct s_woe_reward {
+	unsigned short nameid, amount;
+	int zeny;
+};
+extern struct s_woe_reward woer[MAX_FAME_LIST];
+
 ///Main item data struct
 struct item_data
 {
Index: src/map/map.cpp
===================================================================
diff --git a/src/map/map.cpp b/src/map/map.cpp
--- a/src/map/map.cpp	11f1f9c00c0
+++ b/src/map/map.cpp	c94fb4b5db3
@@ -2061,10 +2061,7 @@
 		npc_event_dequeue(sd);
 
 	if (sd->bg_id)
-		bg_team_leave(sd, true, true);
-
-	if (sd->bg_queue_id > 0)
-		bg_queue_leave(sd);
+		bg_team_leave(sd,1);
 
 	if( sd->status.clan_id )
 		clan_member_left(sd);
Index: src/map/map.hpp
===================================================================
diff --git a/src/map/map.hpp b/src/map/map.hpp
--- a/src/map/map.hpp	35abfd372f0
+++ b/src/map/map.hpp	d37e77d5e80
@@ -595,6 +595,10 @@
 	MF_PRIVATEAIRSHIP_SOURCE,
 	MF_PRIVATEAIRSHIP_DESTINATION,
 	MF_SKILL_DURATION,
+	MF_NOECALL, // Disallow Emergency Call
+	MF_BG_CONSUME, // Allow using BG consumables
+	MF_WOE_CONSUME, // Allow using WoE consumables
+	MF_BG_TOPSCORE,
 	MF_MAX
 };
 
@@ -723,7 +727,7 @@
 	int16 m;
 	int16 xs,ys; // map dimensions (in cells)
 	int16 bxs,bys; // map dimensions (in blocks)
-	int16 bgscore_lion, bgscore_eagle; // Battleground ScoreBoard
+	int16 bgscore_lion, bgscore_eagle, bgscore_top; // Battleground ScoreBoard
 	int npc_num; // number total of npc on the map
 	int npc_num_area; // number of npc with a trigger area on the map
 	int npc_num_warp; // number of warp npc on the map
Index: src/map/map-server.vcxproj
===================================================================
diff --git a/src/map/map-server.vcxproj b/src/map/map-server.vcxproj
--- a/src/map/map-server.vcxproj	96637c077ff
+++ b/src/map/map-server.vcxproj	7044b72892b
@@ -299,7 +299,6 @@
     <Copy SourceFiles="$(SolutionDir)db\import-tmpl\achievement_level_db.yml" DestinationFolder="$(SolutionDir)db\import\" ContinueOnError="true" Condition="!Exists('$(SolutionDir)db\import\achievement_level_db.yml')" />
     <Copy SourceFiles="$(SolutionDir)db\import-tmpl\attendance.yml" DestinationFolder="$(SolutionDir)db\import\" ContinueOnError="true" Condition="!Exists('$(SolutionDir)db\import\attendance.yml')" />
     <Copy SourceFiles="$(SolutionDir)db\import-tmpl\attr_fix.txt" DestinationFolder="$(SolutionDir)db\import\" ContinueOnError="true" Condition="!Exists('$(SolutionDir)db\import\attr_fix.txt')" />
-    <Copy SourceFiles="$(SolutionDir)db\import-tmpl\battleground_db.yml" DestinationFolder="$(SolutionDir)db\import\" ContinueOnError="true" Condition="!Exists('$(SolutionDir)db\import\battleground_db.yml')" />
     <Copy SourceFiles="$(SolutionDir)db\import-tmpl\castle_db.txt" DestinationFolder="$(SolutionDir)db\import\" ContinueOnError="true" Condition="!Exists('$(SolutionDir)db\import\castle_db.txt')" />
     <Copy SourceFiles="$(SolutionDir)db\import-tmpl\const.txt" DestinationFolder="$(SolutionDir)db\import\" ContinueOnError="true" Condition="!Exists('$(SolutionDir)db\import\const.txt')" />
     <Copy SourceFiles="$(SolutionDir)db\import-tmpl\create_arrow_db.txt" DestinationFolder="$(SolutionDir)db\import\" ContinueOnError="true" Condition="!Exists('$(SolutionDir)db\import\create_arrow_db.txt')" />
Index: src/map/mob.cpp
===================================================================
diff --git a/src/map/mob.cpp b/src/map/mob.cpp
--- a/src/map/mob.cpp	d2325c5cb58
+++ b/src/map/mob.cpp	cfdecd0bd69
@@ -1857,6 +1857,8 @@
 		if( md->bg_id && mode&MD_CANATTACK ) {
 			if( md->ud.walktimer != INVALID_TIMER )
 				return true;/* we are already moving */
+			if (status_get_class_(&md->bl) == CLASS_BOSS) /* Bossnia Bosses shouldn't follow */
+				return true;
 			map_foreachinallrange (mob_ai_sub_hard_bg_ally, &md->bl, view_range, BL_PC, md, &tbl, mode);
 			if( tbl ) {
 				if( distance_blxy(&md->bl, tbl->x, tbl->y) <= 3 || unit_walktobl(&md->bl, tbl, 1, 1) )
@@ -3091,6 +3093,8 @@
 			// The master or Mercenary can increase the kill count
 			if (sd->md && src && (src->type == BL_PC || src->type == BL_MER) && mob->lv > sd->status.base_level / 2)
 				mercenary_kills(sd->md);
+			
+			pc_record_mobkills(sd,md);
 		}
 
 		if( md->npc_event[0] && !md->state.npc_killmonster ) {
Index: src/map/mob.hpp
===================================================================
diff --git a/src/map/mob.hpp b/src/map/mob.hpp
--- a/src/map/mob.hpp	493b54d7c0d
+++ b/src/map/mob.hpp	0bc80bef019
@@ -291,7 +291,7 @@
 	int level;
 	int target_id,attacked_id,norm_attacked_id;
 	int areanpc_id; //Required in OnTouchNPC (to avoid multiple area touchs)
-	int bg_id; // BattleGround System
+	unsigned int bg_id; // BattleGround System
 
 	t_tick next_walktime,last_thinktime,last_linktime,last_pcneartime,dmgtick;
 	short move_fail_count;
Index: src/map/npc.hpp
===================================================================
diff --git a/src/map/npc.hpp b/src/map/npc.hpp
--- a/src/map/npc.hpp	44cfa89b955
+++ b/src/map/npc.hpp	02ff8775acd
@@ -93,7 +93,7 @@
 		struct {
 			struct script_code *script;
 			short xs,ys; // OnTouch area radius
-			int guild_id;
+			int guild_id, bg_id;
 			t_tick timer;
 			int timerid,timeramount,rid;
 			t_tick timertick;
Index: src/map/pc.cpp
===================================================================
diff --git a/src/map/pc.cpp b/src/map/pc.cpp
--- a/src/map/pc.cpp	35ba99cfa55
+++ b/src/map/pc.cpp	9eaf786cd75
@@ -82,6 +82,8 @@
 struct fame_list smith_fame_list[MAX_FAME_LIST];
 struct fame_list chemist_fame_list[MAX_FAME_LIST];
 struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+struct fame_list bg_fame_list[MAX_FAME_LIST];
+struct fame_list woe_fame_list[MAX_FAME_LIST];
 
 struct s_job_info job_info[CLASS_COUNT];
 
@@ -448,54 +450,6 @@
 	return sd->group_level;
 }
 
-/**
- * Remove a player from queue after timeout
- * @param tid: Timer ID
- * @param tick: Timer
- * @param id: ID
- * @return 0 on success or 1 otherwise
- */
-static TIMER_FUNC(pc_on_expire_active)
-{
-	map_session_data *sd = (map_session_data *)data;
-
-	nullpo_retr(1, sd);
-
-	sd->tid_queue_active = INVALID_TIMER;
-
-	bg_queue_leave(sd);
-	clif_bg_queue_entry_init(sd);
-	return 0;
-}
-
-/**
- * Function used to set timer externally
- * @param sd: Player data
- */
-void pc_set_bg_queue_timer(map_session_data *sd) {
-	nullpo_retv(sd);
-
-	if (sd->tid_queue_active != INVALID_TIMER) {
-		delete_timer(sd->tid_queue_active, pc_on_expire_active);
-		sd->tid_queue_active = INVALID_TIMER;
-	}
-
-	sd->tid_queue_active = add_timer(gettick() + 20000, pc_on_expire_active, 0, (intptr_t)sd);
-}
-
-/**
- * Function used to delete timer externally
- * @param sd: Player data
- */
-void pc_delete_bg_queue_timer(map_session_data *sd) {
-	nullpo_retv(sd);
-
-	if (sd->tid_queue_active != INVALID_TIMER) {
-		delete_timer(sd->tid_queue_active, pc_on_expire_active);
-		sd->tid_queue_active = INVALID_TIMER;
-	}
-}
-
 static TIMER_FUNC(pc_invincible_timer){
 	struct map_session_data *sd;
 
@@ -647,6 +601,42 @@
 	}
 }
 
+/**
+* Increases a player's battleground points and displays a notice to him
+* @param sd Player
+* @param count BG Point
+*/
+void pc_addbgpoints(struct map_session_data *sd,int count)
+{
+	nullpo_retv(sd);
+
+	clif_specialeffect(&sd->bl, EF_ENHANCE, SELF);
+	sd->status.bgstats.points += count;
+	if (sd->status.bgstats.points > MAX_FAME)
+		sd->status.bgstats.points = MAX_FAME;
+
+	clif_rank_info(sd,count,sd->status.bgstats.points,1);
+	chrif_updatefamelist(sd,1);
+}
+
+/**
+* Increases a player's war of emperium points and displays a notice to him
+* @param sd Player
+* @param count WoE Point
+*/
+void pc_addwoepoints(struct map_session_data *sd,int count)
+{
+	nullpo_retv(sd);
+
+	clif_specialeffect(&sd->bl, EF_ENHANCE, SELF);
+	sd->status.wstats.points += count;
+	if (sd->status.wstats.points > MAX_FAME)
+		sd->status.wstats.points = MAX_FAME;
+
+	clif_rank_info(sd,count,sd->status.wstats.points,0);
+	chrif_updatefamelist(sd,2);
+}
+
 /**
  * Adds a soulball to player
  * @param sd: Player data
@@ -731,7 +721,7 @@
 	}
 
 	clif_update_rankingpoint(sd,ranktype,count);
-	chrif_updatefamelist(sd);
+	chrif_updatefamelist(sd,0);
 }
 
 /**
@@ -744,6 +734,23 @@
 {
 	uint8 i;
 
+	// Battleground Rank
+	if (job == -1) {
+		for(i = 0; i < MAX_FAME_LIST; i++){
+				if(bg_fame_list[i].id == char_id)
+				    return i + 1;
+			}
+			return 0;
+	}
+	// War of Emperium Rank
+	else if (job == -2) {
+		for(i = 0; i < MAX_FAME_LIST; i++){
+				if(woe_fame_list[i].id == char_id)
+				    return i + 1;
+			}
+			return 0;
+	}
+	
 	switch(job){
 		case MAPID_BLACKSMITH: // Blacksmith
 		    for(i = 0; i < MAX_FAME_LIST; i++){
@@ -1606,7 +1613,6 @@
 	sd->expiration_tid = INVALID_TIMER;
 	sd->autotrade_tid = INVALID_TIMER;
 	sd->respawn_tid = INVALID_TIMER;
-	sd->tid_queue_active = INVALID_TIMER;
 
 	sd->skill_keep_using.tid = INVALID_TIMER;
 	sd->skill_keep_using.skill_id = 0;
@@ -1753,9 +1759,6 @@
 	sd->bonus_script.head = NULL;
 	sd->bonus_script.count = 0;
 
-	// Initialize BG queue
-	sd->bg_queue_id = 0;
-
 #if PACKETVER_MAIN_NUM >= 20150507 || PACKETVER_RE_NUM >= 20150429 || defined(PACKETVER_ZERO)
 	sd->hatEffects = {};
 #endif
@@ -5101,9 +5104,18 @@
  * @return Stored index in inventory, or -1 if not found.
  **/
 short pc_search_inventory(struct map_session_data *sd, t_itemid nameid) {
-	short i;
+	short i,x,y;
 	nullpo_retr(-1, sd);
 
+	if (map_getmapflag(sd->bl.m, MF_BG_CONSUME)) {
+		ARR_FIND( 0, MAX_INVENTORY, x, sd->inventory.u.items_inventory[x].nameid == nameid && ( MakeDWord(sd->inventory.u.items_inventory[x].card[2], sd->inventory.u.items_inventory[x].card[3]) == battle_config.bg_reserved_char_id ) && (sd->inventory.u.items_inventory[x].amount > 0 || nameid == 0) );
+			if( x < MAX_INVENTORY ) return x;
+	}
+	if (map_getmapflag(sd->bl.m, MF_WOE_CONSUME)) {
+		ARR_FIND( 0, MAX_INVENTORY, y, sd->inventory.u.items_inventory[y].nameid == nameid && ( MakeDWord(sd->inventory.u.items_inventory[y].card[2], sd->inventory.u.items_inventory[y].card[3]) == battle_config.woe_reserved_char_id ) && (sd->inventory.u.items_inventory[y].amount > 0 || nameid == 0) );
+			if( y < MAX_INVENTORY ) return y;
+	}
+	
 	ARR_FIND( 0, MAX_INVENTORY, i, sd->inventory.u.items_inventory[i].nameid == nameid && (sd->inventory.u.items_inventory[i].amount > 0 || nameid == 0) );
 	return ( i < MAX_INVENTORY ) ? i : -1;
 }
@@ -5623,6 +5635,13 @@
 		return 0;/* regardless, effect is not run */
 	}
 
+	if( sd->inventory.u.items_inventory[n].card[0] == CARD0_CREATE) {
+		if (MakeDWord(sd->inventory.u.items_inventory[n].card[2], sd->inventory.u.items_inventory[n].card[3]) == battle_config.bg_reserved_char_id && !map_getmapflag(sd->bl.m, MF_BG_CONSUME))
+			return 0;
+		if (MakeDWord(sd->inventory.u.items_inventory[n].card[2], sd->inventory.u.items_inventory[n].card[3]) == battle_config.woe_reserved_char_id && !map_getmapflag(sd->bl.m, MF_WOE_CONSUME))
+			return 0;
+	}
+	
 	sd->itemid = item.nameid;
 	sd->itemindex = n;
 	if(sd->catch_target_class != PET_CATCH_FAIL) //Abort pet catching.
@@ -6060,7 +6079,7 @@
 		}
 
 		if (sd->bg_id && mapdata && !mapdata->flag[MF_BATTLEGROUND]) // Moving to a map that isn't a Battlegrounds
-			bg_team_leave(sd, false, true);
+			bg_team_leave(sd,0);
 
 		sd->state.pmap = sd->bl.m;
 		if (sc && sc->count) { // Cancel some map related stuff.
@@ -6132,11 +6151,11 @@
 		}
 
 		if (sd->bg_id) // Switching map servers, remove from bg
-			bg_team_leave(sd, false, true);
+			bg_team_leave(sd,0);
 
 		if (sd->state.vending) // Stop vending
 			vending_closevending(sd);
-
+		
 		npc_script_event(sd, NPCE_LOGOUT);
 		//remove from map, THEN change x/y coordinates
 		unit_remove_map_pc(sd,clrtype);
@@ -8556,6 +8575,28 @@
 			// To-do: Receive exp on certain occasions
 #endif
 		}
+		// Extended Features BG
+		if (sd && sd->bg_id) {
+			achievement_update_objective(sd, AG_BG_DIE, 1, 1);
+			add2limit(sd->status.bgstats.death_count, 1, USHRT_MAX);
+			if (!strcmpi(map[sd->bl.m].name,"bat_b03"))
+				add2limit(sd->status.bgstats.td_deaths, 1, USHRT_MAX);
+		}
+		if (ssd->bg_id && ssd->bg_id != sd->bg_id) {
+			achievement_update_objective(ssd, AG_BG_DAMAGE, 1, ssd->status.bgstats.damage_done);
+			achievement_update_objective(ssd, AG_BG_KILL, 1, 1);
+			add2limit(ssd->status.bgstats.kill_count, 1, USHRT_MAX);
+			if (!strcmpi(map[sd->bl.m].name,"bat_b03"))
+				add2limit(ssd->status.bgstats.td_kills, 1, USHRT_MAX);
+		}
+		
+		if (map_flag_gvg2(sd->bl.m)) {
+			achievement_update_objective(sd, AG_WOE_DAMAGE, 1, sd->status.wstats.damage_done);
+			achievement_update_objective(sd, AG_WOE_DIE, 1, 1);
+			achievement_update_objective(ssd, AG_WOE_KILL, 1, 1);
+			add2limit(sd->status.wstats.death_count, 1, USHRT_MAX);
+			add2limit(ssd->status.wstats.kill_count, 1, USHRT_MAX);
+		}
 	}
 
 	if(battle_config.bone_drop==2
@@ -8702,13 +8743,10 @@
 		return 1|8;
 	}
 	else if( sd->bg_id ) {
-		std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
-
-		if (bg) {
-			if (bg->cemetery.map > 0) { // Respawn by BG
-				sd->respawn_tid = add_timer(tick + 1000, pc_respawn_timer, sd->bl.id, 0);
-				return 1|8;
-			}
+		struct battleground_data *bg = bg_team_search(sd->bg_id);
+		if( bg && bg->mapindex > 0 ) { // Respawn by BG
+			sd->respawn_tid = add_timer(tick+1000, pc_respawn_timer, sd->bl.id, 0);
+			return 1|8;
 		}
 	}
 
@@ -9227,6 +9265,8 @@
 		tmp = hp * bonus / 100; // Overflow check
 		if (bonus != 100 && tmp > hp)
 			hp = tmp;
+		if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+			add2limit(sd->status.bgstats.hp_heal_potions, 1, UINT_MAX);
 	}
 	if (sp) {
 		bonus = 100 + (sd->battle_status.int_ << 1) + pc_checkskill(sd, MG_SRECOVERY) * 10 + pc_checkskill(sd, AM_LEARNINGPOTION) * 5;
@@ -9237,6 +9277,8 @@
 		tmp = sp * bonus / 100; // Overflow check
 		if (bonus != 100 && tmp > sp)
 			sp = tmp;
+		if( map_getmapflag(sd->bl.m, MF_BATTLEGROUND) && sd->bg_id )
+			add2limit(sd->status.bgstats.sp_heal_potions, 1, UINT_MAX);
 	}
 	if (sd->sc.count) {
 		// Critical Wound and Death Hurt stack
@@ -9827,6 +9869,12 @@
 		return false;
 	if( !pc_can_give_items(sd) || sd->sc.cant.drop) //check if this GM level can drop items
 		return false;
+	if( item->card[0] == CARD0_CREATE) {
+		if (MakeDWord(item->card[2], item->card[3]) == battle_config.bg_reserved_char_id)
+			return false;
+		if (MakeDWord(item->card[2], item->card[3]) == battle_config.woe_reserved_char_id)
+			return false;
+	}
 	return (itemdb_isdropable(item, pc_get_group_level(sd)));
 }
 
@@ -13499,6 +13547,27 @@
 		clif_changelook(&sd->bl, LOOK_ROBE, sd->status.robe);
 }
 
+/***********************************************************
+* Update Idle PC Timer
+***********************************************************/
+int pc_update_last_action(struct map_session_data *sd)
+{
+	struct battleground_data *bgd;
+	int64 tick = gettick();
+
+	sd->idletime = last_tick;
+
+	if (sd->bg_id && sd->state.bg_afk && (bgd = bg_team_search(sd->bg_id)) != NULL && bgd->g)
+	{ // Battleground AFK announce
+		char output[128];
+		sprintf(output, "%s : %s is no longer away...", bgd->g->name, sd->status.name);
+		clif_bg_message(bgd, bgd->bg_id, bgd->g->name, output, strlen(output) + 1);
+		sd->state.bg_afk = 0;
+	}
+
+	return 1;
+}
+
 std::shared_ptr<s_attendance_period> pc_attendance_period(){
 	uint32 date = date_get(DT_YYYYMMDD);
 
@@ -13609,6 +13678,376 @@
 	clif_attendence_response( sd, attendance_counter );
 }
 
+void pc_record_mobkills(struct map_session_data *sd, struct mob_data *md)
+{
+	int type = 0;
+
+	if (!sd) return;
+
+	if( sd->guild && map_flag_gvg2(sd->bl.m)) {
+		switch(md->mob_id) {
+		case MOBID_EMPERIUM:
+			pc_addwoepoints(sd,100);
+			add2limit(sd->status.wstats.emperium_kill, 1, USHRT_MAX);
+			break;
+		case 1905:
+			pc_addwoepoints(sd,5);
+			add2limit(sd->status.wstats.barricade_kill, 1, USHRT_MAX);
+			break;
+		case MOBID_GUARDIAN_STONE1:
+		case MOBID_GUARDIAN_STONE2:
+			pc_addwoepoints(sd,10);
+			add2limit(sd->status.wstats.gstone_kill, 1, USHRT_MAX);
+			break;
+		case 1285:
+		case 1286:
+		case 1287:
+		case 1899:
+		case 1900:
+			pc_addwoepoints(sd,10);
+			add2limit(sd->status.wstats.guardian_kill, 1, USHRT_MAX);
+			break;
+		}
+	}
+	else if (sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
+		switch(md->mob_id) {
+		case 2100:
+		case 2101:
+		case 2102:
+		case 2103:
+		case 2104:
+			add2limit(sd->status.bgstats.boss_killed, 1, USHRT_MAX);
+			pc_addbgpoints(sd,25);
+			break;
+		case 20400:
+		case 20401:
+			add2limit(sd->status.bgstats.gstone_kill, 1, USHRT_MAX);
+			pc_addbgpoints(sd,10);
+			break;
+		case 20402:
+			add2limit(sd->status.bgstats.ru_captures, 1, USHRT_MAX);
+			add2limit(sd->status.bgstats.emperium_kill, 1, USHRT_MAX);
+			pc_addbgpoints(sd,30);
+			break;
+		case 1911:
+			if (!strcmpi(map[sd->bl.m].name,"bat_a03") ) {
+				add2limit(sd->status.bgstats.boss_flags, 1, USHRT_MAX);
+				pc_addbgpoints(sd,5);
+			}
+			break;
+		case 1906:
+			if (strcmpi(map[sd->bl.m].name,"bat_a01")) {
+				add2limit(sd->status.bgstats.barricade_kill, 1, USHRT_MAX);
+				pc_addbgpoints(sd,1);
+			}
+			break;
+		}
+	}
+}
+
+void pc_record_damage(struct block_list *src, struct block_list *target, int damage)
+{
+	struct block_list *s_bl;
+	struct map_session_data *sd;
+
+	if (!src || !target || src == target || damage <= 0)
+		return;
+
+	if ((s_bl = battle_get_master(src)) == NULL)
+		s_bl = src;
+
+	if (s_bl->type != BL_PC)
+		return;
+
+	sd = BL_CAST(BL_PC, s_bl);
+
+	switch(target->type) {
+		case BL_PC:
+			if (sd->bg_id && map_getmapflag(src->m, MF_BATTLEGROUND)) {
+				add2limit(sd->status.bgstats.damage_done, damage, UINT_MAX);
+				add2limit(((TBL_PC*)target)->status.bgstats.damage_received, damage, UINT_MAX);
+				if (sd->status.bgstats.top_damage < damage)
+					sd->status.bgstats.top_damage = damage;
+			}
+			else if (map_flag_gvg2(src->m)) {
+				add2limit(sd->status.wstats.damage_done, damage, UINT_MAX);
+				add2limit(((TBL_PC*)target)->status.wstats.damage_received, damage, UINT_MAX);
+				if (sd->status.wstats.top_damage < damage)
+					sd->status.wstats.top_damage = damage;
+			}
+			break;
+		case BL_MOB: {
+			struct mob_data *md = BL_CAST(BL_MOB, target);
+			if (sd->bg_id && map_getmapflag(src->m, MF_BATTLEGROUND) && md->mob_id >= 2100 && md->mob_id <= 2104 )
+				add2limit(sd->status.bgstats.boss_damage, damage, UINT_MAX);
+			else if (map_flag_gvg2(src->m) && md->guardian_data) {
+				switch(md->mob_id) {
+					case MOBID_EMPERIUM:
+						add2limit(sd->status.wstats.emperium_damage, damage, UINT_MAX);
+						break;
+					case 1905:
+						add2limit(sd->status.wstats.barricade_damage, damage, UINT_MAX);
+						break;
+					case MOBID_GUARDIAN_STONE1:
+					case MOBID_GUARDIAN_STONE2:
+						add2limit(sd->status.wstats.gstone_damage, damage, UINT_MAX);
+						break;
+					default:
+						add2limit(sd->status.wstats.guardian_damage, damage, UINT_MAX);
+						break;
+				}
+			}
+			break;
+		}
+	}
+}
+
+void pc_rank_reward(int position, int type)
+{
+	if (position > MAX_FAME_LIST)
+		return;
+	
+	struct mail_message msg;
+
+	memset( &msg, 0, sizeof( struct mail_message ) );
+
+	// Battleground Rewards
+	if (RANK_BG) {
+		safestrncpy(msg.dest_name,bg_fame_list[position].name, NAME_LENGTH);
+		safesnprintf( msg.title, MAIL_TITLE_LENGTH, "BG Rank Rewards");
+		safesnprintf( msg.body, MAIL_BODY_LENGTH, "You have been rewarded by your Rank #%d in Battleground", position+1 );
+
+		msg.item[0].nameid = bgr[position].nameid;
+		msg.item[0].amount = bgr[position].amount;
+		msg.zeny = bgr[position].zeny;
+	}
+	// War of Emperium Rewards
+	else if (RANK_WOE) {
+		safestrncpy(msg.dest_name,woe_fame_list[position].name, NAME_LENGTH);
+		safesnprintf( msg.title, MAIL_TITLE_LENGTH, "WoE Rank Rewards");
+		safesnprintf( msg.body, MAIL_BODY_LENGTH, "You have been rewarded by your Rank #%d in War of Emperium", position+1 );
+
+		msg.item[0].nameid = woer[position].nameid;
+		msg.item[0].amount = woer[position].amount;
+		msg.zeny = woer[position].zeny;
+	}
+	safestrncpy(msg.send_name, "Server", NAME_LENGTH );
+	msg.item[0].identify = 1;
+
+	msg.status = MAIL_NEW;
+	msg.type = MAIL_INBOX_NORMAL;
+	msg.timestamp = time(NULL);
+
+	intif_Mail_send(0, &msg);
+}
+
+void pc_rank_reset(int type, bool reward)
+{
+	struct map_session_data *sd = NULL;
+	struct s_mapiterator* iter = NULL;
+	int i;
+
+	if (reward)
+		for( i = 0; i < MAX_FAME_LIST; i++ )
+		{
+			if (!bg_fame_list[i].id)
+				continue;
+			else
+				pc_rank_reward(i, RANK_BG);
+		}
+
+	iter = mapit_getallusers();
+	for (sd = (TBL_PC*)mapit_first(iter); mapit_exists(iter); sd = (TBL_PC*)mapit_next(iter))	
+	{
+		switch(type) {
+			case RANK_BG: // Battleground Stats}
+				sd->status.bgstats.points = 0;
+				chrif_save(sd, CSAVE_NORMAL);
+				break;
+			case RANK_WOE: // WoE Ranking Reset
+				sd->status.wstats.points = 0;
+				chrif_save(sd, CSAVE_NORMAL);
+				break;
+		}
+	}
+	mapit_free(iter);
+
+	switch(type) {
+		case RANK_BG:
+			if( SQL_ERROR == Sql_Query(mmysql_handle, "UPDATE `char_bg` SET `points` = '0'") )
+				Sql_ShowDebug(mmysql_handle);
+			break;
+		case RANK_WOE:
+			if( SQL_ERROR == Sql_Query(mmysql_handle, "UPDATE `char_wstats` SET `points` = '0'") )
+				Sql_ShowDebug(mmysql_handle);
+			break;
+	}
+
+	chrif_buildfamelist();
+}
+
+void pc_battle_stats(struct map_session_data *sd, struct map_session_data *tsd, int flag)
+{
+	if (!sd || !tsd)
+		return;
+	char output[CHAT_SIZE_MAX];
+
+	// Battleground Stats
+	if (flag == 1) {
+		if (sd != tsd && tsd->status.bgstats.showstats) {
+			clif_displaymessage(sd->fd, "Player doesn not allow to show this information");
+			return;
+		}
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "============ BATTLEGROUND STATS ============", false, SELF);
+		sprintf(output, "    Name: %s (%s)", tsd->status.name,job_name(tsd->status.class_)); clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		if (pc_famerank(tsd->status.char_id,-1))
+			sprintf(output, "    Rank: %d    -    Points: %d", pc_famerank(tsd->status.char_id,-1),tsd->status.bgstats.points);
+		else
+			sprintf(output, "    Rank: N/A    -    Points: %d",tsd->status.bgstats.points);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d",tsd->status.bgstats.win,tsd->status.bgstats.lost,tsd->status.bgstats.tie);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Kills: %d    -    Deaths: %d", tsd->status.bgstats.kill_count, tsd->status.bgstats.death_count);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Damage dealt: %d    -    Top damage: %d", tsd->status.bgstats.damage_done,tsd->status.bgstats.top_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Damage received: %d    -    Healing done: %d", tsd->status.bgstats.damage_received, tsd->status.bgstats.healing_done);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    Deserter times: %d", tsd->status.bgstats.deserter);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    HP Potions: %d    -    SP Potions: %d", tsd->status.bgstats.hp_heal_potions, tsd->status.bgstats.sp_heal_potions);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		sprintf(output, "    SP used: %d", tsd->status.bgstats.sp_used);
+		clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		if (tsd->status.bgstats.yellow_gemstones || tsd->status.bgstats.red_gemstones|| tsd->status.bgstats.blue_gemstones) {
+			sprintf(output, "    Yellow G.: %d    -    Red G.: %d    -    Blue G.: %d", tsd->status.bgstats.yellow_gemstones, tsd->status.bgstats.red_gemstones, tsd->status.bgstats.blue_gemstones);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.poison_bottles) {
+			sprintf(output, "    Poison Bottles: %d", tsd->status.bgstats.poison_bottles);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.zeny_used || tsd->status.bgstats.spiritb_used || tsd->status.bgstats.ammo_used) {
+			sprintf(output, "    Zeny used: %d    -    Spirit Ball: %d    -    Ammo used: %d", tsd->status.bgstats.zeny_used, tsd->status.bgstats.spiritb_used, tsd->status.bgstats.ammo_used);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.leader_win || tsd->status.bgstats.leader_lost || tsd->status.bgstats.leader_tie) {
+			sprintf(output, "    Leader wins: %d    -    Leader lost: %d    -    Leader draw: %d", tsd->status.bgstats.leader_win, tsd->status.bgstats.leader_lost, tsd->status.bgstats.leader_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.ti_wins || tsd->status.bgstats.ti_lost || tsd->status.bgstats.ti_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Triple Inferno ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.ti_wins, tsd->status.bgstats.ti_lost, tsd->status.bgstats.ti_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Skulls (points): %d", tsd->status.bgstats.skulls);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.eos_wins || tsd->status.bgstats.eos_lost || tsd->status.bgstats.eos_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Eye of the Storm ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.eos_wins, tsd->status.bgstats.eos_lost, tsd->status.bgstats.eos_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Flags: %d    -    Bases: %d", tsd->status.bgstats.eos_flags, tsd->status.bgstats.eos_bases);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.boss_wins || tsd->status.bgstats.boss_lost || tsd->status.bgstats.boss_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Tierra Bossnia ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.boss_wins, tsd->status.bgstats.boss_lost, tsd->status.bgstats.boss_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Boss kills: %d    -    Boss damage: %d    -    Flags: %d", tsd->status.bgstats.boss_killed, tsd->status.bgstats.eos_bases, tsd->status.bgstats.boss_flags);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.td_wins || tsd->status.bgstats.td_lost || tsd->status.bgstats.td_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Team Deathmatch ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.td_wins, tsd->status.bgstats.td_lost, tsd->status.bgstats.td_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Kills: %d    -    Deaths: %d", tsd->status.bgstats.td_kills, tsd->status.bgstats.td_deaths);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.dom_wins || tsd->status.bgstats.dom_lost || tsd->status.bgstats.dom_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Domination ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.dom_wins, tsd->status.bgstats.dom_lost, tsd->status.bgstats.dom_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Offensive Kills: %d    -    Defensive Kills: %d", tsd->status.bgstats.dom_off_kills, tsd->status.bgstats.dom_def_kills);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Bases: %d", tsd->status.bgstats.dom_bases);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.sc_wins || tsd->status.bgstats.sc_lost || tsd->status.bgstats.sc_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Stone Control ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.sc_wins, tsd->status.bgstats.sc_lost, tsd->status.bgstats.sc_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Captures: %d    -    Stone Stolen: %d-    Stone Dropped: %d", tsd->status.bgstats.sc_captured, tsd->status.bgstats.sc_stole, tsd->status.bgstats.sc_droped);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.ctf_wins || tsd->status.bgstats.ctf_lost || tsd->status.bgstats.ctf_tie) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Capture the Flag ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d", tsd->status.bgstats.ctf_wins, tsd->status.bgstats.ctf_lost, tsd->status.bgstats.ctf_tie);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Flag captures: %d    -    Flag taken: %d    -    Flag Dropped: %d", tsd->status.bgstats.ctf_captured, tsd->status.bgstats.ctf_taken, tsd->status.bgstats.ctf_droped);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.cq_wins || tsd->status.bgstats.cq_lost) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Conquest ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d", tsd->status.bgstats.cq_wins, tsd->status.bgstats.cq_lost);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Emperium kills: %d    -    Barricade Kills: %d", tsd->status.bgstats.emperium_kill, tsd->status.bgstats.barricade_kill);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Guardian Stone kills: %d", tsd->status.bgstats.gstone_kill);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+		if (tsd->status.bgstats.ru_wins || tsd->status.bgstats.ru_lost) {
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], "___________ Rush ___________", false, SELF);
+			sprintf(output, "    Wins: %d    -    Lost: %d", tsd->status.bgstats.ru_wins, tsd->status.bgstats.ru_lost);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+			sprintf(output, "    Captures: %d", tsd->status.bgstats.ru_captures);
+			clif_messagecolor(&sd->bl, color_table[COLOR_LIGHT_GREEN], output, false, SELF);
+		}
+	// War of Emperium Stats
+	} else {
+		if (sd != tsd && tsd->status.wstats.showstats) {
+			clif_displaymessage(sd->fd, "Player doesn not allow to show this information");
+			return;
+		}
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], "============ WAR OF EMPERIUM STATS ============", false, SELF);
+		sprintf(output, "    Name: %s (%s)", tsd->status.name,job_name(tsd->status.class_));
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		if (pc_famerank(tsd->status.char_id,-2))
+			sprintf(output, "    Rank: %d    -    Points: %d", pc_famerank(tsd->status.char_id,-2),tsd->status.bgstats.points);
+		else
+			sprintf(output, "    Rank: N/A    -    Points: %d",tsd->status.bgstats.points);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Wins: %d    -    Lost: %d    -    Draw: %d",tsd->status.bgstats.win,tsd->status.bgstats.lost,tsd->status.bgstats.tie);
+		sprintf(output, "    Kills: %d    -    Deaths: %d", tsd->status.wstats.kill_count, tsd->status.wstats.death_count);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Damage dealt: %d    -    Top damage: %d", tsd->status.wstats.damage_done,tsd->status.wstats.top_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Damage received: %d    -    Healing done: %d", tsd->status.wstats.damage_received, tsd->status.wstats.healing_done);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    HP Potions: %d    -    SP Potions: %d", tsd->status.wstats.hp_heal_potions, tsd->status.wstats.sp_heal_potions);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    SP used: %d", tsd->status.wstats.sp_used);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Emperium kills: %d    -    Emperium damage: %d", tsd->status.wstats.emperium_kill, tsd->status.wstats.emperium_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Barricade kills: %d    -    Barricade damage: %d", tsd->status.wstats.barricade_kill, tsd->status.wstats.barricade_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		sprintf(output, "    Guardian kills: %d    -    Guardian damage: %d", tsd->status.wstats.guardian_kill, tsd->status.wstats.guardian_damage);
+		clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		if (tsd->status.wstats.yellow_gemstones || tsd->status.wstats.red_gemstones|| tsd->status.wstats.blue_gemstones) {
+			sprintf(output, "    Yellow G.: %d    -    Red G.: %d    -    Blue G.: %d", tsd->status.wstats.yellow_gemstones, tsd->status.wstats.red_gemstones, tsd->status.wstats.blue_gemstones);
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		}
+		if (tsd->status.wstats.poison_bottles) {
+			sprintf(output, "    Poison Bottles: %d", tsd->status.wstats.poison_bottles);
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		}
+		if (tsd->status.wstats.zeny_used || tsd->status.wstats.spiritb_used || tsd->status.wstats.ammo_used) {
+			sprintf(output, "    Zeny used: %d    -    Spirit Ball: %d    -    Ammo used: %d", tsd->status.wstats.zeny_used, tsd->status.wstats.spiritb_used, tsd->status.wstats.ammo_used);
+			clif_messagecolor(&sd->bl, color_table[COLOR_CYAN], output, false, SELF);
+		}
+	}
+}
+
 /*==========================================
  * pc Init/Terminate
  *------------------------------------------*/
@@ -13644,7 +14083,6 @@
 	add_timer_func_list(pc_global_expiration_timer, "pc_global_expiration_timer");
 	add_timer_func_list(pc_expiration_timer, "pc_expiration_timer");
 	add_timer_func_list(pc_autotrade_timer, "pc_autotrade_timer");
-	add_timer_func_list(pc_on_expire_active, "pc_on_expire_active");
 
 	add_timer(gettick() + autosave_interval, pc_autosave, 0, 0);
 
Index: src/map/pc.hpp
===================================================================
diff --git a/src/map/pc.hpp b/src/map/pc.hpp
--- a/src/map/pc.hpp	2032f7710af
+++ b/src/map/pc.hpp	4f87e7dfdc2
@@ -4,7 +4,6 @@
 #ifndef PC_HPP
 #define PC_HPP
 
-#include <memory>
 #include <vector>
 
 #include "../common/cbasetypes.hpp"
@@ -13,7 +12,6 @@
 #include "../common/strlib.hpp"// StringBuf
 #include "../common/timer.hpp"
 
-#include "battleground.hpp"
 #include "buyingstore.hpp" // struct s_buyingstore
 #include "clif.hpp" //e_wip_block
 #include "itemdb.hpp" // MAX_ITEMGROUP
@@ -340,7 +338,12 @@
 		bool mail_writing; // Whether the player is currently writing a mail in RODEX or not
 		bool cashshop_open;
 		bool sale_open;
+		// Battleground eAmod
+		unsigned bg_afk : 1;
+		unsigned int bg_listen : 1;
+		unsigned int only_walk : 1;
 		unsigned int block_action : 10;
+		bool check_equip_skill;
 	} state;
 	struct {
 		unsigned char no_weapon_damage, no_magic_damage, no_misc_damage;
@@ -692,10 +695,21 @@
 	int debug_line;
 	const char* debug_func;
 
-	// Battlegrounds queue system [MasterOfMuppets]
-	int bg_id, bg_queue_id;
-	int tid_queue_active; ///< Timer ID associated with players joining an active BG
-
+	//======================
+	// Battleground eAmod
+	//======================
+	struct battleground_data *bmaster_flag;
+	unsigned short bg_kills; // Battleground Kill Count
+	struct queue_data *qd;
+	// Battleground and Queue System
+	unsigned short bg_team;
+	//======================
+	unsigned int bg_id;
+	short bg_color;
+	struct s_bgentry {
+		unsigned short mapid;
+		int x, y;
+	} bgentry;
 #ifdef SECURE_NPCTIMEOUT
 	/**
 	 * ID of the timer
@@ -790,6 +804,8 @@
 
 	short setlook_head_top, setlook_head_mid, setlook_head_bottom, setlook_robe; ///< Stores 'setlook' script command values.
 
+	int ce_gid;
+	
 #if PACKETVER_MAIN_NUM >= 20150507 || PACKETVER_RE_NUM >= 20150429 || defined(PACKETVER_ZERO)
 	std::vector<int16> hatEffects;
 #endif
@@ -1374,9 +1390,6 @@
 };
 extern const struct sg_data sg_info[MAX_PC_FEELHATE];
 
-void pc_set_bg_queue_timer(map_session_data *sd);
-void pc_delete_bg_queue_timer(map_session_data *sd);
-
 void pc_setinvincibletimer(struct map_session_data* sd, int val);
 void pc_delinvincibletimer(struct map_session_data* sd);
 
@@ -1392,6 +1405,8 @@
 extern struct fame_list smith_fame_list[MAX_FAME_LIST];
 extern struct fame_list chemist_fame_list[MAX_FAME_LIST];
 extern struct fame_list taekwon_fame_list[MAX_FAME_LIST];
+extern struct fame_list bg_fame_list[MAX_FAME_LIST];
+extern struct fame_list woe_fame_list[MAX_FAME_LIST];
 
 void pc_readdb(void);
 void do_init_pc(void);
@@ -1460,6 +1475,16 @@
 
 bool pc_job_can_entermap(enum e_job jobid, int m, int group_lv);
 
+int pc_update_last_action(struct map_session_data *sd);
+
+void pc_rank_reset(int type, bool reward);
+
+void pc_record_damage(struct block_list *src, struct block_list *target, int damage);
+void pc_record_mobkills(struct map_session_data *sd, struct mob_data *md);
+void pc_addbgpoints(struct map_session_data *sd,int count);
+void pc_addwoepoints(struct map_session_data *sd,int count);
+void pc_battle_stats(struct map_session_data *sd, struct map_session_data *tsd, int flag);
+
 #if defined(RENEWAL_DROP) || defined(RENEWAL_EXP)
 uint16 pc_level_penalty_mod( struct map_session_data* sd, e_penalty_type type, std::shared_ptr<s_mob_db> mob, mob_data* md = nullptr );
 #endif
Index: src/map/script.cpp
===================================================================
diff --git a/src/map/script.cpp b/src/map/script.cpp
--- a/src/map/script.cpp	7d664419f50
+++ b/src/map/script.cpp	2c9cad4eb58
@@ -5888,6 +5888,287 @@
 	return SCRIPT_CMD_SUCCESS;
 }
 
+int viewpointmap_sub(struct block_list *bl, va_list ap)
+{
+	struct map_session_data *sd;
+	int npc_id, type, x, y, id, color;
+	npc_id = va_arg(ap, int);
+	type = va_arg(ap, int);
+	x = va_arg(ap, int);
+	y = va_arg(ap, int);
+	id = va_arg(ap, int);
+	color = va_arg(ap, int);
+	sd = (struct map_session_data *)bl;
+	clif_viewpoint(sd, npc_id, type, x, y, id, color);
+	return 0;
+}
+
+BUILDIN_FUNC(viewpointmap)
+{
+	int type, x, y, id, color, m;
+	const char *map_name;
+
+	map_name = script_getstr(st, 2);
+	if ((m = map_mapname2mapid(map_name)) < 0)
+		return SCRIPT_CMD_FAILURE; // Invalid Map
+
+	type = script_getnum(st, 3);
+	x = script_getnum(st, 4);
+	y = script_getnum(st, 5);
+	id = script_getnum(st, 6);
+	color = script_getnum(st, 7);
+
+	map_foreachinmap(viewpointmap_sub, m, BL_PC, st->oid, type, x, y, id, color);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bgannounce)
+{
+	const char *mes = script_getstr(st, 2);
+	const char *fontColor = script_hasdata(st, 3) ? script_getstr(st, 3) : "0xFFFFFF";
+	int         fontType = script_hasdata(st, 4) ? script_getnum(st, 4) : 0x190; // default fontType (FW_NORMAL)
+	int         fontSize = script_hasdata(st, 5) ? script_getnum(st, 5) : 12;    // default fontSize
+	int         fontAlign = script_hasdata(st, 6) ? script_getnum(st, 6) : 0;     // default fontAlign
+	int         fontY = script_hasdata(st, 7) ? script_getnum(st, 7) : 0;     // default fontY
+
+	clif_broadcast2(NULL, mes, (int)strlen(mes) + 1, strtol(fontColor, (char **)NULL, 0), fontType, fontSize, fontAlign, fontY, BG_LISTEN);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_queue_checkstart)
+{
+	int q_id, result = 0;
+	struct queue_data *qd;
+
+	q_id = script_getnum(st, 2);
+	if ((qd = bg_queue_search(q_id)) != NULL)
+	{
+		int type, req_min, teams;
+
+		type = script_getnum(st, 3);
+		teams = script_getnum(st, 4);
+		req_min = script_getnum(st, 5);
+
+		switch (type)
+		{
+		case 0: // Lineal, as they Join
+		case 1: // Random
+		case 2: // Class Balance
+			if (qd->users >= (req_min * teams))
+				result = 1;
+			break;
+		case 4: // BG Team Selected by Script
+		{
+			int count[3], teamcount = 0;
+			struct queue_member *qm = qd->first;
+			struct map_session_data *sd;
+
+			memset(count, 0, sizeof(count));
+			while (qm && (sd = qm->sd) != NULL && teamcount < teams)
+			{ // Faction Count
+				count[sd->bg_team]++;
+				// 0 - Traitors | 1 - Guillaume | 2 - Croix
+				if (count[sd->bg_team] == req_min)
+					teamcount++;
+				qm = qm->next;
+			}
+
+			if (teamcount >= teams) result = 1;
+		}
+		break;
+		default:
+			result = 0;
+			break;
+		}
+	}
+
+	script_pushint(st, result);
+	return SCRIPT_CMD_SUCCESS;
+}
+BUILDIN_FUNC(bg_clean)
+{
+	int bg_id = script_getnum(st, 2);
+	bg_team_clean(bg_id, false);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_team_updatescore)
+{
+	struct battleground_data *bgd;
+	int bg_id = script_getnum(st, 2),
+		score = script_getnum(st, 3);
+
+	if ((bgd = bg_team_search(bg_id)) != NULL)
+	{
+		bgd->team_score = score;
+		clif_bg_updatescore_team(bgd);
+	}
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_team_guildid)
+{
+	struct battleground_data *bgd;
+	int bg_id = script_getnum(st, 2),
+		guild_id = 0;
+	if ((bgd = bg_team_search(bg_id)) != NULL && bgd->g)
+		guild_id = bgd->g->guild_id;
+	script_pushint(st, guild_id);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_monster_immunity) {
+	struct mob_data *md;
+	struct block_list *mbl;
+	int id = script_getnum(st, 2);
+	bool flag = script_getnum(st, 3) != 0;
+
+	if (id == 0 || (mbl = map_id2bl(id)) == NULL || mbl->type != BL_MOB)
+		return SCRIPT_CMD_SUCCESS;
+	md = (TBL_MOB *)mbl;
+	md->ud.immune_attack = flag;
+	return SCRIPT_CMD_SUCCESS;
+}
+
+// Extended Features BG 
+// For now, only used to add statistics
+BUILDIN_FUNC(bg_rankpoints)
+{
+	struct map_session_data *sd;
+	struct battleground_data *bg;
+	const char *type;
+	int i, add_value, fame;
+
+	if( !script_accid2sd(5,sd) )
+		return SCRIPT_CMD_FAILURE;
+
+	if( sd == NULL )
+		return 0;
+
+	if( !sd->bg_id || (bg = bg_team_search(sd->bg_id)) == NULL )
+		return 0;
+	ARR_FIND(0,MAX_BG_MEMBERS,i,bg->members[i].sd == sd);
+	if( i >= MAX_BG_MEMBERS )
+		return 0;
+
+	type = script_getstr(st,2);
+	add_value = script_getnum(st,3);
+	fame = script_getnum(st,4);
+
+	if (fame)
+		pc_addbgpoints(sd,fame);
+
+	if (!strcmpi(type,"fame"))
+		return SCRIPT_CMD_SUCCESS;
+
+	if (!strcmpi(type,"skulls"))
+		add2limit(sd->status.bgstats.skulls,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"eos_flags"))
+		add2limit(sd->status.bgstats.eos_flags,add_value,USHRT_MAX);
+	else if(!strcmpi(type,"sc_stole"))
+		add2limit(sd->status.bgstats.sc_stole,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"sc_captured"))
+		add2limit(sd->status.bgstats.sc_captured,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"sc_droped"))
+		add2limit(sd->status.bgstats.sc_droped,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"ctf_taken"))
+		add2limit(sd->status.bgstats.ctf_taken,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"ctf_captured"))
+		add2limit(sd->status.bgstats.ctf_captured,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"ctf_droped"))
+		add2limit(sd->status.bgstats.ctf_droped,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"dom_off_kills"))
+		add2limit(sd->status.bgstats.dom_off_kills,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"dom_def_kills"))
+		add2limit(sd->status.bgstats.dom_def_kills,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"barricade"))
+		add2limit(sd->status.bgstats.barricade_kill,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"emperium"))
+		add2limit(sd->status.bgstats.emperium_kill,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"gstone"))
+		add2limit(sd->status.bgstats.gstone_kill,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"ru_captures"))
+		add2limit(sd->status.bgstats.ru_captures,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"boss_flags"))
+		add2limit(sd->status.bgstats.boss_flags,add_value,USHRT_MAX);
+	else if (!strcmpi(type,"boss_killed"))
+		add2limit(sd->status.bgstats.boss_killed,add_value,USHRT_MAX);
+	else
+		ShowDebug("bg_rankpoints: unknown string (%s)\n", (script_getstr(st,2)));
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_rankpoints_area)
+{
+	const char *str, *type;
+	int m, x0, y0, x1, y1, bg_id;
+	int i = 0, add_value;
+	int type_val, fame;
+	struct battleground_data *bg = NULL;
+	struct map_session_data *sd;
+
+	bg_id = script_getnum(st,2);
+	str = script_getstr(st,3);
+
+	if( (bg = bg_team_search(bg_id)) == NULL || (m = map_mapname2mapid(str)) < 0 )
+	{
+		script_pushint(st,0);
+		return SCRIPT_CMD_SUCCESS;
+	}
+
+	x0 = script_getnum(st,4);
+	y0 = script_getnum(st,5);
+	x1 = script_getnum(st,6);
+	y1 = script_getnum(st,7);
+	type = script_getstr(st,8);
+
+	if( !strcmpi(type,"eos_bases") )
+		type_val = 1;
+	else if( !strcmpi(type,"dom_bases") )
+		type_val = 2;
+	else if( !strcmpi(type,"ru_captures") )
+		type_val = 3;
+	else return 0; // Invalid Type
+
+	add_value = script_getnum(st,9);
+	fame = script_getnum(st,10);
+
+	for( i = 0; i < MAX_BG_MEMBERS; i++ )
+	{
+		if( (sd = bg->members[i].sd) == NULL )
+			continue;
+		if (x0 != -1 && y0 != -1 && x1 != -1 && y1 != -1) {
+			if( sd->bl.m != m || sd->bl.x < x0 || sd->bl.y < y0 || sd->bl.x > x1 || sd->bl.y > y1 )
+				continue;
+		}
+		if (fame)
+			pc_addbgpoints(sd,fame);
+
+		switch( type_val )
+		{
+		case 1:
+			add2limit(sd->status.bgstats.eos_bases,add_value,USHRT_MAX);
+			break;
+		case 2:
+			add2limit(sd->status.bgstats.dom_bases,add_value,USHRT_MAX);
+			break;
+		case 3:
+			add2limit(sd->status.bgstats.ru_captures,add_value,USHRT_MAX);
+			break;
+		}
+	}
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+static int bg_cleanmap_sub(struct block_list *bl, va_list ap)
+{
+	nullpo_ret(bl);
+	map_clearflooritem(bl);
+	return SCRIPT_CMD_SUCCESS;
+}
+
 /*==========================================
  * Force Heal a player (hp and sp)
  *------------------------------------------*/
@@ -8500,6 +8781,7 @@
  *	3 : account_id
  *	4 : bg_id
  *	5 : clan_id
+ *  6 : queue_id
  *------------------------------------------*/
 BUILDIN_FUNC(getcharid)
 {
@@ -8520,6 +8802,7 @@
 	case 3: script_pushint(st,sd->status.account_id); break;
 	case 4: script_pushint(st,sd->bg_id); break;
 	case 5: script_pushint(st,sd->status.clan_id); break;
+	case 6: script_pushint(st,(sd->qd)?sd->qd->q_id:0); break;
 	default:
 		ShowError("buildin_getcharid: invalid parameter (%d).\n", num);
 		script_pushint(st,0);
@@ -10900,6 +11183,15 @@
 	return SCRIPT_CMD_SUCCESS;
 }
 
+/*==========================================
+ *------------------------------------------*/
+BUILDIN_FUNC(donpceventall)
+{
+	const char* event = script_getstr(st,2);
+	npc_event_doall(event);
+	return SCRIPT_CMD_SUCCESS;
+}
+
 /// for Aegis compatibility
 /// basically a specialized 'donpcevent', with the event specified as two arguments instead of one
 BUILDIN_FUNC(cmdothernpc)	// Added by RoVeRT
@@ -13226,6 +13518,38 @@
 	return SCRIPT_CMD_SUCCESS;
 }
 
+BUILDIN_FUNC(flagemblembg) {
+	TBL_NPC* nd;
+	int g_id = script_getnum(st,2);
+
+	if( script_hasdata(st,3) )
+		nd = npc_name2id(script_getstr(st,3));
+	else
+		nd = map_id2nd(st->oid);
+
+	if(g_id < 0) return SCRIPT_CMD_SUCCESS;
+	
+	if( nd == NULL ) {
+		ShowError("script:flagemblem: npc %d not found\n", st->oid);
+	} else if( nd->subtype != NPCTYPE_SCRIPT ) {
+		ShowError("script:flagemblem: unexpected subtype %d for npc %d '%s'\n", nd->subtype, st->oid, nd->exname);
+	} else {
+		bool changed = ( nd->u.scr.guild_id != g_id )?true:false;
+		if( !map_getmapflag(nd->bl.m, MF_BATTLEGROUND))
+			nd->u.scr.guild_id = g_id;
+		else
+			nd->u.scr.bg_id = g_id;
+		
+		clif_guild_emblem_area(&nd->bl);
+		/* guild flag caching */
+		if( g_id ) /* adding a id */
+			guild_flag_add(nd);
+		else if( changed ) /* removing a flag */
+			guild_flag_remove(nd);
+	}
+	return SCRIPT_CMD_SUCCESS;
+}
+
 BUILDIN_FUNC(getcastlename)
 {
 	const char* mapname = mapindex_getmapname(script_getstr(st,2),NULL);
@@ -19991,15 +20315,11 @@
 {
 	struct npc_data *nd;
 	struct chat_data *cd;
-	const char *map_name;
-	int mapindex = 0, bg_id;
+	const char *map_name, *ev = "", *dev = "";
+	int x, y, mapindex = 0, bg_id, guild_index;
 	unsigned char i,c=0;
-	struct s_battleground_team team;
-
-	if( script_hasdata(st,7) )
-		nd = npc_name2id(script_getstr(st,7));
-	else
-		nd = (struct npc_data *)map_id2bl(st->oid);
+	
+	nd = (struct npc_data *)map_id2sd(st->oid);
 
 	if( nd == NULL || (cd = (struct chat_data *)map_id2bl(nd->chat_id)) == NULL )
 	{
@@ -20014,20 +20334,19 @@
 		return SCRIPT_CMD_SUCCESS;
 	}
 
-	team.warp_x = script_getnum(st,3);
-	team.warp_y = script_getnum(st,4);
-	if (script_hasdata(st,5)) {
-		team.quit_event = script_getstr(st,5); // Logout Event
-		check_event(st, team.quit_event.c_str());
-	} else
-		team.quit_event = "";
-	if (script_hasdata(st,6)) {
-		team.death_event = script_getstr(st,6); // Die Event
-		check_event(st, team.death_event.c_str());
-	} else
-		team.death_event = "";
+	x = script_getnum(st,3);
+	y = script_getnum(st,4);
+	guild_index = script_getnum(st, 5);
+	if(script_hasdata(st,6))
+		ev = script_getstr(st,6); // Logout Event
+	if(script_hasdata(st,7))
+		dev = script_getstr(st,7); // Die Event
 
-	if( (bg_id = bg_create(mapindex, &team)) == 0 )
+	check_event(st, ev);
+	check_event(st, dev);
+
+	guild_index = cap_value(guild_index, 0, 12);
+	if ((bg_id = bg_create(mapindex, x, y, guild_index, ev, dev)) == 0)
 	{ // Creation failed
 		script_pushint(st,0);
 		return SCRIPT_CMD_SUCCESS;
@@ -20035,7 +20354,7 @@
 
 	for (i = 0; i < cd->users; i++) { // Only add those who are in the chat room
 		struct map_session_data *sd;
-		if( (sd = cd->usersd[i]) != NULL && bg_team_join(bg_id, sd, false) ){
+		if( (sd = cd->usersd[i]) != NULL && bg_team_join(bg_id, sd) ){
 			mapreg_setreg(reference_uid(add_str("$@arenamembers"), c), sd->bl.id);
 			++c;
 		}
@@ -20052,10 +20371,11 @@
 	struct npc_data *nd;
 	struct chat_data *cd;
 	struct map_session_data *sd;
-	int x, y, mapindex, bg_id = script_getnum(st,2);
-	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	struct battleground_data *bg;
+	int x, y, mapindex, bg_id;
 
-	if (!bg) {
+	bg_id = script_getnum(st,2);
+	if ((bg = bg_team_search(bg_id)) == NULL) {
 		script_pushint(st, false);
 		return SCRIPT_CMD_SUCCESS;
 	}
@@ -20069,9 +20389,9 @@
 		y = script_getnum(st, 5);
 	}
 	else {
-		mapindex = bg->cemetery.map;
-		x = bg->cemetery.x;
-		y = bg->cemetery.y;
+		mapindex = bg->mapindex;
+		x = bg->x;
+		y = bg->y;
 	}
 	if (!map_getmapflag(map_mapindex2mapid(mapindex), MF_BATTLEGROUND)) {
 		ShowWarning("buildin_waitingroom2bg_single: Map %s requires the mapflag MF_BATTLEGROUND.\n", mapindex_id2name(mapindex));
@@ -20087,7 +20407,7 @@
 	if( (sd = cd->usersd[0]) == NULL )
 		return SCRIPT_CMD_SUCCESS;
 
-	if( bg_team_join(bg_id, sd, false) && pc_setpos(sd, mapindex, x, y, CLR_TELEPORT) == SETPOS_OK)
+	if( bg_team_join(bg_id, sd) && pc_setpos(sd, mapindex, x, y, CLR_TELEPORT) == SETPOS_OK)
 	{
 		script_pushint(st, true);
 	}
@@ -20102,9 +20422,8 @@
 /// *bg_create("<map name>",<x>,<y>{,"<On Quit Event>","<On Death Event>"});
 /// @author [secretdataz]
 BUILDIN_FUNC(bg_create) {
-	const char *map_name;
-	int mapindex = 0;
-	struct s_battleground_team team;
+	const char *map_name, *ev = "", *dev = "";
+	int x, y, mapindex = 0, guild_index, bg_id;
 
 	map_name = script_getstr(st, 2);
 	if (strcmp(map_name, "-") != 0 && (mapindex = mapindex_name2id(map_name)) == 0)
@@ -20113,20 +20432,24 @@
 		return SCRIPT_CMD_SUCCESS;
 	}
 
-	team.warp_x = script_getnum(st,3);
-	team.warp_y = script_getnum(st,4);
-	if (script_hasdata(st,5)) {
-		team.quit_event = script_getstr(st,5); // Logout Event
-		check_event(st, team.quit_event.c_str());
-	} else
-		team.quit_event = "";
-	if (script_hasdata(st,6)) {
-		team.death_event = script_getstr(st,6); // Die Event
-		check_event(st, team.death_event.c_str());
-	} else
-		team.death_event = "";
+	x = script_getnum(st, 3);
+	y = script_getnum(st, 4);
+	guild_index = script_getnum(st, 5);
+	if(script_hasdata(st, 6))
+		ev = script_getstr(st, 6); // Logout Event
+	if(script_hasdata(st, 7))
+		dev = script_getstr(st, 7); // Die Event
 
-	script_pushint(st, bg_create(mapindex, &team));
+	check_event(st, ev);
+	check_event(st, dev);
+
+	guild_index = cap_value(guild_index, 0, 12);
+	if ((bg_id = bg_create(mapindex, x, y, guild_index, ev, dev)) == 0) { // Creation failed
+		script_pushint(st, -1);
+	}
+	else
+		script_pushint(st, bg_id);
+	
 	return SCRIPT_CMD_SUCCESS;
 }
 
@@ -20138,10 +20461,11 @@
 BUILDIN_FUNC(bg_join) {
 	const char* map_name;
 	struct map_session_data *sd;
-	int x, y, mapindex, bg_id = script_getnum(st, 2);
-	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	struct battleground_data *bg;
+	int x, y, bg_id, mapindex;
 
-	if (!bg) {
+	bg_id = script_getnum(st, 2);
+	if ((bg = bg_team_search(bg_id)) == NULL) {
 		script_pushint(st, false);
 		return SCRIPT_CMD_SUCCESS;
 	}
@@ -20154,9 +20478,9 @@
 		x = script_getnum(st, 4);
 		y = script_getnum(st, 5);
 	} else {
-		mapindex = bg->cemetery.map;
-		x = bg->cemetery.x;
-		y = bg->cemetery.y;
+		mapindex = bg->mapindex;
+		x = bg->x;
+		y = bg->y;
 	}
 
 	if (!script_charid2sd(6, sd)) {
@@ -20169,7 +20493,7 @@
 		return SCRIPT_CMD_FAILURE;
 	}
 
-	if (bg_team_join(bg_id, sd, false) && pc_setpos(sd, mapindex, x, y, CLR_TELEPORT) == SETPOS_OK)
+	if (bg_team_join(bg_id, sd) && pc_setpos(sd, mapindex, x, y, CLR_TELEPORT) == SETPOS_OK)
 	{
 		script_pushint(st, true);
 	}
@@ -20179,102 +20503,755 @@
 	return SCRIPT_CMD_SUCCESS;
 }
 
-BUILDIN_FUNC(bg_team_setxy)
-{
-	int bg_id = script_getnum(st,2);
-	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
-
-	if (bg) {
-		bg->cemetery.x = script_getnum(st, 3);
-		bg->cemetery.y = script_getnum(st, 4);
-	}
+// Creates a Queue
+// bg_queue_create "Queue Name","On Join Event",min_level;
+BUILDIN_FUNC(bg_queue_create)
+ {
+	const char *queue_name, *jev;
+	int q_id, min_level = 0;
+ 
+	queue_name = script_getstr(st, 2);
+	jev = script_getstr(st, 3);
+	if (script_hasdata(st, 4))
+		min_level = script_getnum(st, 4);
 
+	q_id = bg_queue_create(queue_name, jev, min_level);
+	script_pushint(st, q_id);
 	return SCRIPT_CMD_SUCCESS;
 }
 
-BUILDIN_FUNC(bg_warp)
+// Changes the Queue's Join Event.
+// bg_queue_event queue_id,"On Join Event";
+BUILDIN_FUNC(bg_queue_event)
 {
-	int x, y, mapindex, bg_id;
-	const char* map_name;
+	struct queue_data *qd;
+	const char *jev;
+	int q_id;
 
-	bg_id = script_getnum(st,2);
-	map_name = script_getstr(st,3);
-	if( (mapindex = mapindex_name2id(map_name)) == 0 )
-		return SCRIPT_CMD_SUCCESS; // Invalid Map
-	x = script_getnum(st,4);
-	y = script_getnum(st,5);
-	bg_team_warp(bg_id, mapindex, x, y);
+	q_id = script_getnum(st, 2);
+	if ((qd = bg_queue_search(q_id)) == NULL)
+		return 0;
+	jev = script_getstr(st, 3);
+	safestrncpy(qd->join_event, jev, sizeof(qd->join_event));
 	return SCRIPT_CMD_SUCCESS;
 }
 
-BUILDIN_FUNC(bg_monster)
+// Joins a Queue
+// bg_queue_join queue_id;
+BUILDIN_FUNC(bg_queue_join)
 {
-	int class_ = 0, x = 0, y = 0, bg_id = 0;
-	const char *str,*mapname, *evt="";
-
-	bg_id  = script_getnum(st,2);
-	mapname    = script_getstr(st,3);
-	x      = script_getnum(st,4);
-	y      = script_getnum(st,5);
-	str    = script_getstr(st,6);
-	class_ = script_getnum(st,7);
-	if( script_hasdata(st,8) ) evt = script_getstr(st,8);
-	check_event(st, evt);
-	script_pushint(st, mob_spawn_bg(mapname,x,y,str,class_,evt,bg_id));
-	return SCRIPT_CMD_SUCCESS;
+	int q_id;
+	struct map_session_data *sd;
+	if( !script_rid2sd(sd) )
+		return SCRIPT_CMD_SUCCESS;
+	
+	q_id = script_getnum(st, 2);
+	bg_queue_join(sd, q_id);
+	return 0;
 }
 
-BUILDIN_FUNC(bg_monster_set_team)
+// Party Joins a Queue
+// bg_queue_partyjoin party_id,queue_id;
+BUILDIN_FUNC(bg_queue_partyjoin)
 {
-	struct mob_data *md;
-	struct block_list *mbl;
-	int id = script_getnum(st,2),
-		bg_id = script_getnum(st,3);
+	int q_id, i, party_id;
+	struct map_session_data *sd;
+	struct party_data *p;
 
-	if( id == 0 || (mbl = map_id2bl(id)) == NULL || mbl->type != BL_MOB )
-		return SCRIPT_CMD_SUCCESS;
-	md = (TBL_MOB *)mbl;
-	md->bg_id = bg_id;
+	party_id = script_getnum(st, 2);
+	if (!party_id || (p = party_search(party_id)) == NULL) return 0;
 
-	mob_stop_attack(md);
-	mob_stop_walking(md, 0);
-	md->target_id = md->attacked_id = 0;
-	clif_name_area(&md->bl);
+	q_id = script_getnum(st, 3);
+	if (!bg_queue_search(q_id)) return 0;
 
-	return SCRIPT_CMD_SUCCESS;
+	for (i = 0; i < MAX_PARTY; i++)
+	{
+		if ((sd = p->data[i].sd) == NULL)
+			continue;
+		bg_queue_join(sd, q_id);
+	}
+
+	return 0;
 }
 
-BUILDIN_FUNC(bg_leave)
+// Leaves a Queue
+// bg_queue_leave queue_id;
+BUILDIN_FUNC(bg_queue_leave)
 {
-	struct map_session_data *sd = NULL;
-	bool deserter = false;
-
-	if( !script_charid2sd(2,sd) || !sd->bg_id )
+	int q_id;
+	struct map_session_data *sd;
+	if( !script_rid2sd(sd) )
 		return SCRIPT_CMD_SUCCESS;
 
-	if (!strcmp(script_getfuncname(st), "bg_desert"))
-		deserter = true;
-
-	bg_team_leave(sd, false, deserter);
-	return SCRIPT_CMD_SUCCESS;
+	q_id = script_getnum(st, 2);
+	bg_queue_leave(sd, q_id);
+	return 0;
 }
 
-BUILDIN_FUNC(bg_destroy)
+BUILDIN_FUNC(bg_queue_leaveall)
 {
-	int bg_id = script_getnum(st,2);
-	bg_team_delete(bg_id);
+	struct map_session_data *sd;
+	if( !script_rid2sd(sd) )
+		return SCRIPT_CMD_SUCCESS;
+	bg_queue_leaveall(sd);
 	return SCRIPT_CMD_SUCCESS;
 }
 
-BUILDIN_FUNC(bg_getareausers)
+BUILDIN_FUNC(bg_queue_data)
 {
-	const char *str = script_getstr(st, 3);
-	int16 m, x0, y0, x1, y1;
-	int bg_id = script_getnum(st, 2), c = 0;
-	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	struct queue_data *qd;
+	int q_id = script_getnum(st, 2),
+		type = script_getnum(st, 3);
 
-	if (!bg || (m = map_mapname2mapid(str)) < 0) {
-		script_pushint(st,0);
+	if ((qd = bg_queue_search(q_id)) == NULL)
+	{
+		script_pushint(st, 0);
+		return 0;
+	}
+
+	switch (type)
+	{
+	case 0: script_pushint(st, qd->users); break;
+	case 1: // User List
+	{
+		int j = 0;
+		struct map_session_data *sd;
+		struct queue_member *head;
+		head = qd->first;
+		while (head)
+		{
+			if ((sd = head->sd) != NULL)
+			{
+				mapreg_setregstr(reference_uid(add_str("$@qmembers$"), j), sd->status.name);
+				j++;
+			}
+			head = head->next;
+		}
+		script_pushint(st, j);
+	}
+	break;
+	default:
+		ShowError("script:bg_queue_data: unknown data identifier %d\n", type);
+		break;
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(bg_queue2team)
+{
+	struct queue_data *qd;
+	struct queue_member *qm;
+	const char *map_name, *ev = "", *dev = "";
+	int q_id, max, x, y, i, mapindex = 0, guild_index, bg_id;
+
+	q_id = script_getnum(st, 2);
+	if ((qd = bg_queue_search(q_id)) == NULL)
+	{
+		script_pushint(st, 0);
+		return 0;
+	}
+
+	max = script_getnum(st, 3);
+	map_name = script_getstr(st, 4);
+
+	if (strcmp(map_name, "-") != 0 && (mapindex = mapindex_name2id(map_name)) == 0)
+	{
+		script_pushint(st, 0);
+		return 0;
+	}
+
+	x = script_getnum(st, 5);
+	y = script_getnum(st, 6);
+	guild_index = script_getnum(st, 7);
+	ev = script_getstr(st, 8); // Logout Event
+	dev = script_getstr(st, 9); // Die Event
+
+	guild_index = cap_value(guild_index, 0, 12);
+	if ((bg_id = bg_create(mapindex, x, y, guild_index, ev, dev)) == 0)
+	{ // Creation failed
+		script_pushint(st, 0);
+		return 0;
+	}
+
+	i = 0; // Counter
+	while ((qm = qd->first) != NULL && i < max && i < MAX_BG_MEMBERS)
+	{
+		if (qm->sd && bg_team_join(bg_id, qm->sd))
+		{
+			mapreg_setreg(reference_uid(add_str("$@arenamembers"), i), qm->sd->bl.id);
+			bg_queue_member_remove(qd, qm->sd->bl.id);
+			i++;
+		}
+		else break; // Failed? Should not. Anyway, to avoid a infinite loop
+	}
+
+	mapreg_setreg(add_str("$@arenamembersnum"), i);
+	script_pushint(st, bg_id);
+	return 0;
+}
+
+// Joins the first player from the queue to the given team and warp him.
+// bg_queue2team_single queue_id,bg_id,"mapname",x,y;
+
+BUILDIN_FUNC(bg_queue2team_single)
+{
+	const char* map_name;
+	struct queue_data *qd;
+	struct map_session_data *sd;
+	int x, y, mapindex, bg_id, q_id;
+
+	q_id = script_getnum(st, 2);
+	if ((qd = bg_queue_search(q_id)) == NULL || !qd->first || !qd->first->sd)
+		return 0;
+
+	bg_id = script_getnum(st, 3);
+	map_name = script_getstr(st, 4);
+	if ((mapindex = mapindex_name2id(map_name)) == 0)
+		return 0; // Invalid Map
+	x = script_getnum(st, 5);
+	y = script_getnum(st, 6);
+	sd = qd->first->sd;
+
+	if (bg_team_join(bg_id, sd))
+	{
+		bg_queue_member_remove(qd, sd->bl.id);
+		pc_setpos(sd, mapindex, x, y, CLR_TELEPORT);
+	}
+
+	return 0;
+}
+
+// Build BG Teams from one Queue
+// bg_queue2teams queue_id,maxplayersperteam,type,teamID1,teamID2...;
+
+BUILDIN_FUNC(bg_queue2teams)
+{ // Send Users from Queue to Teams. Requires previously created teams.
+	struct queue_data *qd;
+	int i, j = 0, bg_id = 0, c = 0, q_id, min2, max, type, limit = 0;
+	struct map_session_data *sd;
+
+	q_id = script_getnum(st, 2); // Queue ID
+	if ((qd = bg_queue_search(q_id)) == NULL)
+	{
+		ShowError("script:bg_queue2teams: Non existant queue id received %d.\n", q_id);
+		return 0;
+	}
+
+	min2 = script_getnum(st, 3); // Min Members per Team
+	max = script_getnum(st, 4); // Max Members per Team
+	type = script_getnum(st, 5); // Team Building Method
+
+	i = 6; // Team ID's to build
+	while (script_hasdata(st, i))
+	{
+		bg_id = script_getnum(st, i);
+		if (bg_team_search(bg_id) == NULL)
+		{
+			ShowError("script:bg_queue2teams: Non existant team id received %d.\n", bg_id);
+			return 0;
+		}
+		i++;
+	}
+	c = i - 6;
+
+	if (c < 2)
+	{
+		ShowError("script:bg_queue2teams: Less than 2 teams received to build members.\n");
+		return 0;
+	}
+
+	if (type < 3)
+	{
+		limit = min(max * c, qd->users); // How many players are we going to take from the Queue
+		if (battle_config.bg_queue2team_balanced)
+		{
+			limit -= limit % c; // Remove the remaining difference to balance teams
+			max = limit / c;
+		}
+		else
+		{
+			max = (limit - (limit % c)) / c;
+			if (limit % c > 0) max++; // Extra slot per team to add the remaining members
+		}
+	}
+
+	switch (type)
+	{
+	case 0: // Lineal - Maybe to keep party together
+		for (i = 0; i < limit; i++)
+		{
+			if (i % max == 0)
+			{ // Switch Team
+				bg_id = script_getnum(st, j + 6);
+				if (++j >= c) j = 0;
+			}
+
+			if (!qd->first || (sd = qd->first->sd) == NULL)
+				break; // No more people to join Teams
+
+			bg_team_join(bg_id, sd);
+			bg_queue_member_remove(qd, sd->bl.id);
+		}
+		break;
+	case 1: // Random
+	{
+		int pos;
+		struct queue_member *qm;
+
+		for (i = 0; i < limit; i++)
+		{
+			if (i % max == 0)
+			{ // Switch Team
+				bg_id = script_getnum(st, j + 6);
+				if (++j >= c) j = 0;
+			}
+
+			pos = 1 + rand() % (limit - i);
+			if ((qm = bg_queue_member_get(qd, pos)) == NULL || (sd = qm->sd) == NULL)
+				break;
+
+			bg_team_join(bg_id, sd);
+			bg_queue_member_remove(qd, sd->bl.id);
+		}
+	}
+	break;
+	case 2: // Job Balance
+	{
+		struct queue_member *qm, *head, *previous, *first = NULL;
+		int s_class, t_class;
+
+		// Building a Temporal Sorted by Class Queue
+		i = 0;
+		while (i < limit && (qm = qd->first) != NULL && (sd = qm->sd) != NULL)
+		{
+			qd->first = qd->first->next; // Move the queue head to the next pos
+			qd->users--; // Reduces the amount of members on queue
+			if (qm->next == NULL) qd->last = NULL;
+			qm->next = NULL;
+			sd->qd = NULL;
+
+			// Plug qm into the temporal Queue
+			head = first;
+			previous = NULL;
+			s_class = sd->class_&MAPID_UPPERMASK; // Current Member's Upper Class
+
+			while (head && head->sd && (s_class > (t_class = (head->sd->class_&MAPID_UPPERMASK)) || (s_class == t_class && sd->class_ > head->sd->class_)))
+			{ // Search for Insert Position
+				previous = head;
+				head = head->next;
+			}
+
+			qm->next = head;
+			if (previous)
+				previous->next = qm;
+			else
+				first = qm;
+		}
+
+		// Update the Queue new positions
+		i = 0;
+		head = qd->first;
+		while (head)
+		{
+			head->position = ++i;
+			head = head->next;
+		}
+
+		// Player distribution into Teams
+		while ((head = first) != NULL && (sd = head->sd) != NULL)
+		{
+			bg_id = script_getnum(st, j + 6);
+			if (++j >= c) j = 0;
+			bg_team_join(bg_id, sd);
+
+			first = first->next;
+			aFree(head);
+		}
+	}
+	break;
+	case 4: // BG Team Mode
+	{
+		bool team[3];
+		int count[3], teams = 0, k;
+		struct queue_member *qm = qd->first;
+		struct battleground_data *bgd;
+
+		memset(count, 0, sizeof(count));
+		memset(team, 0, sizeof(team));
+
+		while (qm && (sd = qm->sd) != NULL)
+		{ // Search the First Teams to Build Teams
+			i = sd->bg_team;
+			count[i]++;
+
+			if (count[i] == min2 && !team[i] && teams < c)
+			{
+				team[i] = true; // Tag this Team.
+				teams++;
+			}
+
+			qm = qm->next;
+		}
+
+		if (teams < c) break; // Should not happen if you use first bg_queue_checkstart
+
+		if (battle_config.bg_queue2team_balanced)
+		{
+			for (i = 0; i < 3; i++)
+			{ // Set the Max per Team to be taken from the Queue
+				if (!team[i]) continue; // Ignore this Team.
+				max = min(count[i], max);
+			}
+		}
+
+		for (i = 0; i < 3; i++)
+		{
+			if (!team[i]) continue; // Ignore this Team.
+
+			k = 0;
+			bg_id = script_getnum(st, j + 6);
+			if ((bgd = bg_team_search(bg_id)) != NULL)
+			{
+				bgd->pf_id = i; // Team ID stored for Balancing
+				bgd->g = &bg_guild[(!i ? 2 : i - 1)];
+				bgd->color = bg_colors[(!i ? 2 : i - 1)];
+			}
+			j++;
+
+			qm = qd->first;
+			while (qm && (sd = qm->sd) != NULL && k < max)
+			{
+				qm = qm->next;
+				if (sd->bg_team != i) continue; // Not from this Team
+				bg_queue_member_remove(qd, sd->bl.id);
+				bg_team_join(bg_id, sd);
+				k++;
+			}
+		}
+	}
+	break;
+	}
+
+	return 0;
+}
+
+// Fill teams with members from the given Queue
+// bg_balance_teams queue_id,maxplayersperteam,TeamID1,TeamID2,...;
+
+BUILDIN_FUNC(bg_balance_teams)
+{
+	struct queue_data *qd;
+	struct queue_member *head;
+	struct battleground_data *bgd, *p_bg;
+	int i, c, q_id, bg_id, m_bg_id = 0, max, min, type;
+	struct map_session_data *sd;
+	bool balanced;
+
+	q_id = script_getnum(st, 2);
+	if ((qd = bg_queue_search(q_id)) == NULL || qd->users <= 0)
+		return 0;
+
+	max = script_getnum(st, 3);
+	if (max > MAX_BG_MEMBERS) max = MAX_BG_MEMBERS;
+	min = MAX_BG_MEMBERS + 1;
+	type = script_getnum(st, 4);
+
+	i = 5; // Team ID's to build
+
+	while (script_hasdata(st, i))
+	{
+		bg_id = script_getnum(st, i);
+		if ((bgd = bg_team_search(bg_id)) == NULL)
+		{
+			ShowError("script:bg_balance_teams: Non existant team id received %d.\n", bg_id);
+			return 0;
+		}
+
+		if (bgd->count < min) min = bgd->count;
+		i++;
+	}
+
+	c = i - 5; // Teams Found
+	if (c < 2 || min >= max) return 0; // No Balance Required
+
+	if (type < 3)
+	{
+		while ((head = qd->first) != NULL && (sd = head->sd) != NULL)
+		{
+			p_bg = NULL;
+			balanced = true;
+			min = MAX_BG_MEMBERS + 1;
+
+			// Search the Current Minimum and Balance status
+			for (i = 0; i < c; i++)
+			{
+				bg_id = script_getnum(st, i + 5);
+				if ((bgd = bg_team_search(bg_id)) == NULL)
+					break; // Should not happen. Teams already check
+				if (p_bg && p_bg->count != bgd->count)
+					balanced = false; // Teams still with different member count
+				if (bgd->count < min)
+				{
+					m_bg_id = bg_id;
+					min = bgd->count;
+				}
+				p_bg = bgd;
+			}
+
+			if (min >= max) break; // Balance completed
+
+			if (battle_config.bg_queue2team_balanced && balanced && qd->users < c)
+				break; // No required users on queue to keep balance
+
+			bg_team_join(m_bg_id, sd);
+			bg_queue_member_remove(qd, sd->bl.id);
+			if ((bgd = bg_team_search(m_bg_id)) != NULL && bgd->mapindex)
+				pc_setpos(sd, bgd->mapindex, bgd->x, bgd->y, CLR_OUTSIGHT); // Joins and Warps
+		}
+	}
+	else if (type == 4)
+	{
+		int td_count[3], j;
+		memset(td_count, 0, sizeof(td_count));
+
+		head = qd->first;
+		while (head && (sd = head->sd) != NULL)
+		{
+			td_count[sd->bg_team]++;
+			head = head->next;
+		}
+
+		min = MAX_BG_MEMBERS + 1;
+
+		// Fill Teams
+		for (i = 0; i < c; i++)
+		{
+			bg_id = script_getnum(st, i + 5);
+			if ((bgd = bg_team_search(bg_id)) == NULL || td_count[bgd->pf_id] <= 0)
+				continue; // Nothing to Add here
+
+			j = 0;
+			head = qd->first;
+			while (head && (sd = head->sd) != NULL && j < td_count[bgd->pf_id])
+			{
+				head = head->next;
+				if (sd->bg_team != bgd->pf_id) continue;
+				bg_queue_member_remove(qd, sd->bl.id);
+				bg_team_join(bg_id, sd);
+				j++;
+			}
+		}
+	}
+
+	return 0;
+}
+
+BUILDIN_FUNC(bg_team_reveal)
+{
+	struct battleground_data *bgd;
+	int bg_id;
+
+	bg_id = script_getnum(st, 2);
+	if ((bgd = bg_team_search(bg_id)) == NULL)
+		return 0;
+
+	bgd->reveal_pos = true; // Reveal Position Mode
+	return 0;
+}
+
+BUILDIN_FUNC(bg_team_setquest)
+{
+	struct battleground_data *bgd;
+	struct map_session_data *sd;
+	int i, bg_id, quest;
+
+	bg_id = script_getnum(st, 2);
+	quest = script_getnum(st, 3);
+
+	if (bg_id == 0 || (bgd = bg_team_search(bg_id)) == NULL)
+		return 0;
+
+	for (i = 0; i < MAX_BG_MEMBERS; i++)
+	{
+		if ((sd = bgd->members[i].sd) == NULL)
+			continue;
+		clif_quest_add(sd, &sd->quest_log[i]);
+	}
+	return 0;
+}
+
+BUILDIN_FUNC(bg_monster_reveal)
+{
+	struct mob_data *md;
+	struct block_list *mbl;
+	int id = script_getnum(st, 2),
+		flag = script_getnum(st, 3),
+		color = script_getnum(st, 4);
+
+	if (id == 0 || (mbl = map_id2bl(id)) == NULL || mbl->type != BL_MOB)
+		return 0;
+	md = (TBL_MOB *)mbl;
+	map_foreachinmap(viewpointmap_sub, mbl->m, BL_PC, st->oid, flag, mbl->x, mbl->y, mbl->id, color);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_cleanmap)
+{
+	const char* map_name;
+	int m;
+
+	map_name = script_getstr(st, 3);
+	m = map_mapname2mapid(map_name);
+
+	map_foreachinmap(bg_cleanmap_sub, m, BL_ITEM);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_getitem)
+{
+	int bg_id, nameid, amount;
+
+	bg_id = script_getnum(st, 2);
+	nameid = script_getnum(st, 3);
+	amount = script_getnum(st, 4);
+
+	bg_team_getitem(bg_id, nameid, amount);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_getkafrapoints)
+{
+	int bg_id, amount;
+
+	bg_id = script_getnum(st, 2);
+	amount = script_getnum(st, 3);
+
+	bg_team_get_kafrapoints(bg_id, amount);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_reward)
+{
+	int bg_id, nameid, amount, kafrapoints, quest_id, add_value, bg_arena, bg_result;
+	const char *var;
+
+	bg_id = script_getnum(st, 2);
+	nameid = script_getnum(st, 3);
+	amount = script_getnum(st, 4);
+	kafrapoints = script_getnum(st, 5);
+	quest_id = script_getnum(st, 6);
+	var = script_getstr(st, 7);
+	add_value = script_getnum(st, 8);
+	bg_arena = script_getnum(st, 9);
+	bg_result = script_getnum(st, 10);
+
+	bg_team_rewards(bg_id, nameid, amount, kafrapoints, quest_id, var, add_value, bg_arena, bg_result);
+	return 0;
+}
+
+BUILDIN_FUNC(bg_team_setxy)
+{
+	struct battleground_data *bg;
+	int bg_id;
+
+	bg_id = script_getnum(st,2);
+	if( (bg = bg_team_search(bg_id)) == NULL )
+		return SCRIPT_CMD_SUCCESS;
+
+	bg->x = script_getnum(st,3);
+	bg->y = script_getnum(st,4);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_warp)
+{
+	int x, y, mapindex, bg_id;
+	const char* map_name;
+
+	bg_id = script_getnum(st,2);
+	map_name = script_getstr(st,3);
+	if( !strcmp(map_name,"RespawnPoint") )
+		mapindex = 0;
+	else if( !strcmp(map_name,"EntryPoint") )
+		mapindex = 2000;
+	else if( (mapindex = mapindex_name2id(map_name)) == 0 )
+		return SCRIPT_CMD_SUCCESS; // Invalid Map
+	x = script_getnum(st,4);
+	y = script_getnum(st,5);
+	bg_team_warp(bg_id, mapindex, x, y);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_monster)
+{
+	int class_ = 0, x = 0, y = 0, bg_id = 0;
+	const char *str,*mapname, *evt="";
+
+	bg_id  = script_getnum(st,2);
+	mapname    = script_getstr(st,3);
+	x      = script_getnum(st,4);
+	y      = script_getnum(st,5);
+	str    = script_getstr(st,6);
+	class_ = script_getnum(st,7);
+	if( script_hasdata(st,8) ) evt = script_getstr(st,8);
+	check_event(st, evt);
+	script_pushint(st, mob_spawn_bg(mapname,x,y,str,class_,evt,bg_id));
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_monster_set_team)
+{
+	struct mob_data *md;
+	struct block_list *mbl;
+	int id = script_getnum(st,2),
+		bg_id = script_getnum(st,3);
+
+	if( id == 0 || (mbl = map_id2bl(id)) == NULL || mbl->type != BL_MOB )
+		return SCRIPT_CMD_SUCCESS;
+	md = (TBL_MOB *)mbl;
+	md->bg_id = bg_id;
+
+	mob_stop_attack(md);
+	mob_stop_walking(md, 0);
+	md->target_id = md->attacked_id = 0;
+	clif_name_area(&md->bl);
+
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_leave)
+{
+	struct map_session_data *sd = NULL;
+
+	if( !script_charid2sd(2,sd) || !sd->bg_id )
+		return SCRIPT_CMD_SUCCESS;
+
+	bg_team_leave(sd,0);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_destroy)
+{
+	int bg_id = script_getnum(st,2);
+	bg_team_clean(bg_id, true);
+	return SCRIPT_CMD_SUCCESS;
+}
+
+BUILDIN_FUNC(bg_getareausers)
+{
+	const char *str;
+	int16 m, x0, y0, x1, y1;
+	int bg_id;
+	int i = 0, c = 0;
+	struct battleground_data *bg = NULL;
+
+	bg_id = script_getnum(st,2);
+	str = script_getstr(st,3);
+
+	if( (bg = bg_team_search(bg_id)) == NULL || (m = map_mapname2mapid(str)) < 0 )
+	{
+		script_pushint(st,0);
 		return SCRIPT_CMD_SUCCESS;
 	}
 
@@ -20283,8 +21260,11 @@
 	x1 = script_getnum(st,6);
 	y1 = script_getnum(st,7);
 
-	for (const auto &member : bg->members) {
-		if( member.sd->bl.m != m || member.sd->bl.x < x0 || member.sd->bl.y < y0 || member.sd->bl.x > x1 || member.sd->bl.y > y1 )
+	for( i = 0; i < MAX_BG_MEMBERS; i++ ){
+		struct map_session_data *sd;
+		if( (sd = bg->members[i].sd) == NULL )
+			continue;
+		if( sd->bl.m != m || sd->bl.x < x0 || sd->bl.y < y0 || sd->bl.x > x1 || sd->bl.y > y1 )
 			continue;
 		c++;
 	}
@@ -20313,105 +21293,119 @@
 
 BUILDIN_FUNC(bg_get_data)
 {
-	int bg_id = script_getnum(st,2), type = script_getnum(st,3), i = 0;
-	std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, bg_id);
+	struct battleground_data *bg = bg_team_search( script_getnum(st, 2) );
 
-	if (bg) {
-		switch (type) {
-		case 0:
-			script_pushint(st, bg->members.size());
-			break;
-		case 1:
-			for (const auto &member : bg->members)
-				mapreg_setreg(reference_uid(add_str("$@arenamembers"), i++), member.sd->bl.id);
-			mapreg_setreg(add_str("$@arenamemberscount"), i);
-			script_pushint(st, i);
-			break;
-		default:
-			ShowError("script:bg_get_data: unknown data identifier %d\n", type);
-			break;
-		}
-	} else
+	if (bg == NULL) {
 		script_pushint(st, 0);
+		return SCRIPT_CMD_SUCCESS;
+	}
+	
+	int i, j, type = script_getnum(st, 3);
+	
+	switch( type ) {
+	case 0:
+		script_pushint(st, bg->count);
+		break;
+	case 1:
+		for (i = 0, j = 0; i < ARRAYLENGTH(bg->members); i++) {
+			if (bg->members[i].sd != NULL)
+				mapreg_setreg(reference_uid(add_str("$@arenamembers"), j++), bg->members[i].sd->bl.id);
+		}
+		mapreg_setreg(add_str("$@arenamemberscount"), j);
+		script_pushint(st, j);
+		break;
+	case 2:
+		script_pushconststr(st, bg->g ? bg->g->name : "null");
+		break;
+	case 3:
+		script_pushconststr(st, bg->g ? bg->g->master : "null");
+		break;
+	case 4:
+		script_pushint(st, bg->color);
+		break;
+	default:
+		ShowError("script:bg_get_data: unknown data identifier %d\n", type);
+		break;
+	}
 
 	return SCRIPT_CMD_SUCCESS;
 }
 
-/**
- * Reserves a slot for the given Battleground.
- * bg_reserve("<battleground_map_name>"{,<ended>});
- */
-BUILDIN_FUNC(bg_reserve)
+BUILDIN_FUNC(bg_logincount)
 {
-	const char *str = script_getstr(st, 2);
-	bool ended = script_hasdata(st, 3) ? script_getnum(st, 3) != 0 : false;
+	TBL_PC *sd;
+	if (!script_rid2sd(sd)) {
+		script_pushint(st, 0);
+		return SCRIPT_CMD_FAILURE;
+	}
 
-	if (!bg_queue_reserve(str, ended))
-		ShowWarning("buildin_bg_reserve: Could not reserve battleground with name %s\n", str);
+	int i = 0;
+ 
+	if (sd)
+		i = bg_countlogin(sd, true);
+	script_pushint(st, i);
+	
 	return SCRIPT_CMD_SUCCESS;
 }
 
-/**
- * Removes a spot for the given Battleground.
- * bg_unbook("<battleground_map_name>");
- */
-BUILDIN_FUNC(bg_unbook)
+/*==========================================
+ * Reset battle rank
+ * type :
+ *	1 : Battleground Rank
+ *	2 : War of Emperium Rank
+ * flag:
+ *  0 : No Reward
+ *  1 : Reward
+ *------------------------------------------*/
+BUILDIN_FUNC(battle_rank_reset)
 {
-	const char *str = script_getstr(st, 2);
+	int type = script_getnum(st,2);
+	bool flag;
+
+	if (type < 1 && type > 2)
+		return SCRIPT_CMD_FAILURE;
 
-	if (!bg_queue_unbook(str))
-		ShowWarning("buildin_bg_unbook: Could not unreserve battleground with name %s\n", str);
+	if( script_hasdata(st,3) ){
+		flag = script_getnum(st,3) != 0;
+	}else{
+		flag = true;
+	}
+
+	if (type == 1)
+		type = RANK_BG;
+	else
+		type = RANK_WOE;
+
+	pc_rank_reset(type,flag);
 	return SCRIPT_CMD_SUCCESS;
 }
 
-/**
- * Gets battleground database information.
- * bg_info("<battleground name>", <type>);
- */
-BUILDIN_FUNC(bg_info)
+/*==========================================
+ * Return fame rank position
+ * return by @num :
+ *	0 : Battleground Rank
+ *	1 : War of Emperium Rank
+ *------------------------------------------*/
+BUILDIN_FUNC(getcharrank)
 {
-	std::shared_ptr<s_battleground_type> bg = bg_search_name(script_getstr(st, 2));
-
-	if (!bg) {
-		ShowError("bg_info: Invalid Battleground name %s.\n", script_getstr(st, 2));
-		return SCRIPT_CMD_FAILURE;
-	}
-
-	int type = script_getnum(st, 3);
+	int num;
+	TBL_PC *sd;
 
-	switch (type) {
-		case BG_INFO_ID:
-			script_pushint(st, bg->id);
-			break;
-		case BG_INFO_REQUIRED_PLAYERS:
-			script_pushint(st, bg->required_players);
-			break;
-		case BG_INFO_MAX_PLAYERS:
-			script_pushint(st, bg->max_players);
-			break;
-		case BG_INFO_MIN_LEVEL:
-			script_pushint(st, bg->min_lvl);
-			break;
-		case BG_INFO_MAX_LEVEL:
-			script_pushint(st, bg->max_lvl);
-			break;
-		case BG_INFO_MAPS: {
-			size_t i;
+	num = script_getnum(st,2);
 
-			for (i = 0; i < bg->maps.size(); i++)
-				setd_sub_str(st, nullptr, ".@bgmaps$", i, mapindex_id2name(bg->maps[i].mapindex), nullptr);
-			setd_sub_num(st, nullptr, ".@bgmapscount", 0, i, nullptr);
-			script_pushint(st, i);
-			break;
-		}
-		case BG_INFO_DESERTER_TIME:
-			script_pushint(st, bg->deserter_time);
-			break;
-		default:
-			ShowError("bg_info: Unknown battleground info type %d given.\n", type);
-			return SCRIPT_CMD_FAILURE;
+	if( !script_charid2sd(3,sd) ){
+		script_pushint(st,-1); //return 0, according docs
+		return SCRIPT_CMD_SUCCESS;
 	}
 
+	switch( num ) {
+	case 0: script_pushint(st,pc_famerank(sd->status.char_id, -1)); break;
+	case 1: script_pushint(st,pc_famerank(sd->status.char_id, -2)); break;
+	default:
+		ShowError("buildin_getcharrank: invalid parameter (%d).\n", num);
+		script_pushint(st,0);
+		break;
+	}
 	return SCRIPT_CMD_SUCCESS;
 }
 
@@ -25498,17 +26492,46 @@
 	BUILDIN_DEF(bg_monster,"isiisi?"),
 	BUILDIN_DEF(bg_monster_set_team,"ii"),
 	BUILDIN_DEF(bg_leave,"?"),
-	BUILDIN_DEF2(bg_leave,"bg_desert","?"),
-	BUILDIN_DEF(bg_destroy,"i"),
 	BUILDIN_DEF(areapercentheal,"siiiiii"),
 	BUILDIN_DEF(bg_get_data,"ii"),
 	BUILDIN_DEF(bg_getareausers,"isiiii"),
 	BUILDIN_DEF(bg_updatescore,"sii"),
 	BUILDIN_DEF(bg_join,"i????"),
-	BUILDIN_DEF(bg_create,"sii??"),
-	BUILDIN_DEF(bg_reserve,"s?"),
-	BUILDIN_DEF(bg_unbook,"s"),
-	BUILDIN_DEF(bg_info,"si"),
+	// Battleground eAmod
+	BUILDIN_DEF(bg_create,"siiiss"),
+	BUILDIN_DEF(bg_logincount, ""),
+	BUILDIN_DEF(bg_monster_immunity, "ii"),
+	BUILDIN_DEF(bg_queue_create, "ss?"),
+	BUILDIN_DEF(bg_queue_event, "is"),
+	BUILDIN_DEF(bg_queue_join, "i"),
+	BUILDIN_DEF(bg_queue_partyjoin, "ii"),
+	BUILDIN_DEF(bg_queue_leave, "i"),
+	BUILDIN_DEF(bg_queue_leaveall, ""),
+	BUILDIN_DEF(bg_queue_data, "ii"),
+	BUILDIN_DEF(bg_queue2team, "iisiiiss"),
+	BUILDIN_DEF(bg_queue2team_single, "iisii"),
+	BUILDIN_DEF(bg_queue2teams, "iiiiii*"),
+	BUILDIN_DEF(bg_queue_checkstart, "iiii"),
+	BUILDIN_DEF(bg_balance_teams, "iiiii*"),
+	BUILDIN_DEF(bg_team_updatescore, "ii"),
+	BUILDIN_DEF(bg_team_guildid, "i"),
+	BUILDIN_DEF(bg_team_reveal,"i"),
+	BUILDIN_DEF(bg_team_setquest,"ii"),
+	BUILDIN_DEF(bg_getitem, "iii"),
+	BUILDIN_DEF(bg_getkafrapoints, "ii"),
+	BUILDIN_DEF(bg_reward, "iiiiisiii"),
+	BUILDIN_DEF(bgannounce, "s?????"),
+	BUILDIN_DEF(viewpointmap, "siiiii"),
+	BUILDIN_DEF(bg_monster_reveal,"iii"),
+	BUILDIN_DEF(donpceventall,"s"),
+	BUILDIN_DEF2(flagemblem, "flagemblembg", "ii"),
+	BUILDIN_DEF(flagemblembg, "i?"),
+	// Extended Features BG
+	BUILDIN_DEF(bg_rankpoints,"sii?"),
+	BUILDIN_DEF(bg_rankpoints_area,"isiiiisii"),
+	BUILDIN_DEF(battle_rank_reset,"ii"),
+	BUILDIN_DEF(getcharrank,"i?"),
+	BUILDIN_DEF(bg_destroy,"i"),
 
 	// Instancing
 	BUILDIN_DEF(instance_create,"s??"),
Index: src/map/script_constants.hpp
===================================================================
diff --git a/src/map/script_constants.hpp b/src/map/script_constants.hpp
--- a/src/map/script_constants.hpp	04ad3b7cc0e
+++ b/src/map/script_constants.hpp	a8152683f87
@@ -478,6 +478,11 @@
 	export_constant(MF_PRIVATEAIRSHIP_SOURCE);
 	export_constant(MF_PRIVATEAIRSHIP_DESTINATION);
 	export_constant(MF_SKILL_DURATION);
+	// Battleground eAmod
+	export_constant(MF_NOECALL);
+	export_constant(MF_BG_CONSUME);
+	export_constant(MF_WOE_CONSUME);
+	export_constant(MF_BG_TOPSCORE);
 
 	/* setcell types */
 	export_constant(CELL_WALKABLE);
@@ -1563,7 +1568,6 @@
 	export_constant(SC_EARTHSHAKER);
 	export_constant(SC_WEAPONBLOCK_ON);
 	export_constant(SC_ENTRY_QUEUE_APPLY_DELAY);
-	export_constant(SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT);
 	export_constant(SC_ADAPTATION);
 	export_constant(SC_BASILICA_CELL);
 	export_constant(SC_LIGHTOFMOON);
@@ -5233,7 +5237,19 @@
 	export_constant(AG_ENCHANT_SUCCESS);
 	export_constant(AG_SPEND_ZENY);
 	export_constant(AG_TAMING);
-
+	// Extended Features
+	export_constant2("AG_BG_WIN",AG_BG_WIN);
+	export_constant2("AG_BG_LOSE",AG_BG_LOSE);
+	export_constant2("AG_BG_TIE",AG_BG_TIE);
+	export_constant2("AG_BG_KILL",AG_BG_KILL);
+	export_constant2("AG_BG_DIE",AG_BG_DIE);
+	export_constant2("AG_BG_DAMAGE",AG_BG_DAMAGE);
+	export_constant2("AG_BG_HEAL",AG_BG_HEAL);
+	export_constant2("AG_WOE_KILL",AG_WOE_KILL);
+	export_constant2("AG_WOE_DIE",AG_WOE_DIE);
+	export_constant2("AG_WOE_DAMAGE",AG_WOE_DAMAGE);
+	export_constant2("AG_WOE_HEAL",AG_WOE_HEAL);
+	
 	/* achievement info */
 	export_constant(ACHIEVEINFO_COUNT1);
 	export_constant(ACHIEVEINFO_COUNT2);
@@ -8030,15 +8046,6 @@
 	export_constant(UNT_GD_SOULCOLD);
 	export_constant(UNT_GD_HAWKEYES);
 
-	/* battleground info types */
-	export_constant(BG_INFO_ID);
-	export_constant(BG_INFO_REQUIRED_PLAYERS);
-	export_constant(BG_INFO_MAX_PLAYERS);
-	export_constant(BG_INFO_MIN_LEVEL);
-	export_constant(BG_INFO_MAX_LEVEL);
-	export_constant(BG_INFO_MAPS);
-	export_constant(BG_INFO_DESERTER_TIME);
-
 	/* item job classes */
 	export_constant(ITEMJ_NORMAL);
 	export_constant(ITEMJ_UPPER);
Index: src/map/skill.cpp
===================================================================
diff --git a/src/map/skill.cpp b/src/map/skill.cpp
--- a/src/map/skill.cpp	c94adffaf65
+++ b/src/map/skill.cpp	35177f36f14
@@ -828,6 +828,8 @@
 	}
 
 	if (skill_blockpc_get(sd, skill_id) != -1){
+		if (skill_id >= 10010 && skill_id <= 10013)
+			clif_displaymessage(sd->fd,"[Guild Skill] Cannot use the skill due to cooldown delay"); 
 		clif_skill_fail(sd,skill_id,USESKILL_FAIL_SKILLINTERVAL,0);
 		return true;
 	}
@@ -919,10 +921,14 @@
 			break;
 		case GD_EMERGENCYCALL:
 		case GD_ITEMEMERGENCYCALL:
+			if (mapdata->flag[MF_NOECALL]) {
+				clif_displaymessage(sd->fd,"Cannot use Emergency Call in this map.");
+				return true;
+			}
 			if (
-				!(battle_config.emergency_call&((is_agit_start())?2:1)) ||
+				!mapdata->flag[MF_BATTLEGROUND] && (!(battle_config.emergency_call&((is_agit_start())?2:1)) ||
 				!(battle_config.emergency_call&(mapdata_flag_gvg2(mapdata)?8:4)) ||
-				(battle_config.emergency_call&16 && mapdata->flag[MF_NOWARPTO] && !(mapdata->flag[MF_GVG_CASTLE] || mapdata->flag[MF_GVG_TE_CASTLE]))
+				(battle_config.emergency_call&16 && mapdata->flag[MF_NOWARPTO] && !(mapdata->flag[MF_GVG_CASTLE] || mapdata->flag[MF_GVG_TE_CASTLE])))
 			)	{
 				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
 				return true;
@@ -2030,7 +2036,6 @@
 					case SC_WEDDING:		case SC_XMAS:			case SC_SUMMER:
 					case SC_DRESSUP:		case SC_HANBOK:			case SC_OKTOBERFEST:
 					case SC_LHZ_DUN_N1:		case SC_LHZ_DUN_N2:			case SC_LHZ_DUN_N3:			case SC_LHZ_DUN_N4:
-					case SC_ENTRY_QUEUE_APPLY_DELAY:	case SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT:
 					case SC_REUSE_LIMIT_LUXANIMA:	case SC_LUXANIMA:	case SC_SOULENERGY:
 					case SC_EP16_2_BUFF_SS:		case SC_EP16_2_BUFF_SC:	case SC_EP16_2_BUFF_AC:
 					case SC_EMERGENCY_MOVE:		case SC_MADOGEAR:
@@ -6594,6 +6599,24 @@
 				heal = ~heal + 1;
 			heal_get_jobexp = status_heal(bl,heal,0,0);
 
+			// Extended Features BG 
+			if (sd) {
+				if (map_getmapflag(src->m, MF_BATTLEGROUND) && sd->bg_id && dstsd->bg_id) {
+					if (sd->bg_id == dstsd->bg_id) {
+						achievement_update_objective(sd, AG_BG_HEAL, 1, heal_get_jobexp);
+						add2limit(sd->status.bgstats.healing_done, heal_get_jobexp, UINT_MAX);
+					} else
+						add2limit(sd->status.bgstats.wrong_healing_done, heal_get_jobexp, UINT_MAX);
+				}
+				else if (map_flag_gvg2(src->m) && sd->guild && dstsd->guild) {
+					if (sd->guild == dstsd->guild) {
+						achievement_update_objective(sd, AG_WOE_HEAL, 1, heal_get_jobexp);
+						add2limit(sd->status.wstats.healing_done, heal_get_jobexp, UINT_MAX);
+					} else
+						add2limit(sd->status.wstats.wrong_healing_done, heal_get_jobexp, UINT_MAX);
+				}
+			}
+			
 			if(sd && dstsd && heal > 0 && sd != dstsd && battle_config.heal_exp > 0){
 				heal_get_jobexp = heal_get_jobexp * battle_config.heal_exp / 100;
 				if (heal_get_jobexp <= 0)
@@ -7676,18 +7699,25 @@
 	case CASH_ASSUMPTIO:
 	case WM_FRIGG_SONG:
 	case NV_HELPANGEL:
-		if( sd == NULL || sd->status.party_id == 0 || (flag & 1) )
+		if( sd == NULL || (sd->status.party_id == 0 && !sd->bg_id) || (flag & 1) )
 			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id,skill_lv)));
-		else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		else if( sd ) {
+			if (battle_config.bg_party_skills && sd->bg_id)
+				map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+			else
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
 		break;
 	case MER_MAGNIFICAT:
 		if( mer != NULL )
 		{
 			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id,skill_lv)));
-			if( mer->master && mer->master->status.party_id != 0 && !(flag&1) )
-				party_foreachsamemap(skill_area_sub, mer->master, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
-			else if( mer->master && !(flag&1) )
+			if( mer->master && (mer->master->status.party_id != 0 && mer->master->bg_id != 0) && !(flag&1) ) {
+				if (battle_config.bg_party_skills && sd->bg_id)
+					map_foreachinallrange(skill_area_sub, &mer->master->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+				else
+					party_foreachsamemap(skill_area_sub, mer->master, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+			} else if( mer->master && !(flag&1) )
 				clif_skill_nodamage(src, &mer->master->bl, skill_id, skill_lv, sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id,skill_lv)));
 		}
 		break;
@@ -7696,17 +7726,20 @@
 	case BS_ADRENALINE2:
 	case BS_WEAPONPERFECT:
 	case BS_OVERTHRUST:
-		if (sd == NULL || sd->status.party_id == 0 || (flag & 1)) {
+		if (sd == NULL || (sd->status.party_id == 0 && !sd->bg_id) || (flag & 1)) {
 			int weapontype = skill_get_weapontype(skill_id);
 			if (!weapontype || !dstsd || pc_check_weapontype(dstsd, weapontype)) {
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
 					sc_start2(src, bl, type, 100, skill_lv, (src == bl) ? 1 : 0, skill_get_time(skill_id, skill_lv)));
 			}
 		} else if (sd) {
-			party_foreachsamemap(skill_area_sub,
-				sd,skill_get_splash(skill_id, skill_lv),
-				src,skill_id,skill_lv,tick, flag|BCT_PARTY|1,
-				skill_castend_nodamage_id);
+			if (battle_config.bg_party_skills && sd->bg_id)
+				map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+			else
+				party_foreachsamemap(skill_area_sub,
+			sd,skill_get_splash(skill_id, skill_lv),
+			src,skill_id,skill_lv,tick, flag|BCT_PARTY|1,
+			skill_castend_nodamage_id);
 		}
 		break;
 
@@ -8490,7 +8523,7 @@
 					case SC_SPRITEMABLE:		case SC_BITESCAR:	case SC_CRUSHSTRIKE:
 					case SC_QUEST_BUFF1:	case SC_QUEST_BUFF2:	case SC_QUEST_BUFF3:
 					case SC_ARMOR_ELEMENT_EARTH:	case SC_ARMOR_ELEMENT_FIRE:	case SC_ARMOR_ELEMENT_WIND:
-					case SC_ENTRY_QUEUE_APPLY_DELAY:	case SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT:
+					case SC_ENTRY_QUEUE_APPLY_DELAY:
 					case SC_MADOGEAR:
 					// Clans
 					case SC_CLAN_INFO:
@@ -9377,24 +9410,28 @@
 	case GD_RESTORE:
 	case GD_EMERGENCY_MOVE:
 		if(flag&1) {
-			if (status_get_guild_id(src) == status_get_guild_id(bl)) {				
+			if (status_get_guild_id(src) == status_get_guild_id(bl) || (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src) == bg_team_get_id(bl)))				
 				if( skill_id == GD_RESTORE )
 					clif_skill_nodamage(src,bl,AL_HEAL,status_percent_heal(bl,90,90),1);
 				else
 					sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id, skill_lv));
-			}
-		} else if (status_get_guild_id(src)) {
+		} else if (status_get_guild_id(src) || (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src))) {
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 			map_foreachinallrange(skill_area_sub, src,
 				skill_get_splash(skill_id, skill_lv), BL_PC,
 				src,skill_id,skill_lv,tick, flag|BCT_GUILD|1,
 				skill_castend_nodamage_id);
-			if (sd)
+			if (sd){
+				struct battleground_data *bgd = bg_team_search(sd->bg_id);
+				if (sd->bg_id)
+					bg_block_skill_start(bgd, skill_id, skill_get_time2(skill_id, skill_lv));
+				else
 #ifdef RENEWAL
 				skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
 #else
 				guild_block_skill(sd, skill_get_time2(skill_id, skill_lv));
 #endif
+			}
 		}
 		break;
 	case GD_EMERGENCYCALL:
@@ -9403,10 +9440,18 @@
 			int8 dx[9] = {-1, 1, 0, 0,-1, 1,-1, 1, 0};
 			int8 dy[9] = { 0, 0, 1,-1, 1,-1,-1, 1, 0};
 			uint8 j = 0, calls = 0, called = 0;
-			struct guild *g;
+			struct guild *g = NULL;
+			struct battleground_data *bg = NULL;
+			int max_member;
 			// i don't know if it actually summons in a circle, but oh well. ;P
-			g = sd?sd->guild:guild_search(status_get_guild_id(src));
-			if (!g)
+			if (map_getmapflag(src->m, MF_BATTLEGROUND) && bg_team_get_id(src)) {
+				bg = bg_team_search(sd->bg_id);
+				max_member = MAX_BG_MEMBERS;
+			} else {
+				g = sd?sd->guild:guild_search(status_get_guild_id(src));
+				max_member = g->max_member;
+			}
+			if (!g && !bg)
 				break;
 
 			if (skill_id == GD_ITEMEMERGENCYCALL)
@@ -9418,11 +9463,11 @@
 				}
 
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
-			for (i = 0; i < g->max_member && (!calls || (calls && called < calls)); i++, j++) {
+			for (i = 0; i < max_member && (!calls || (calls && called < calls)); i++, j++) {
 				if (j > 8)
 					j = 0;
-				if ((dstsd = g->member[i].sd) != NULL && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
-					if (map_getmapflag(dstsd->bl.m, MF_NOWARP) && !map_flag_gvg2(dstsd->bl.m))
+				if ((dstsd = bg?bg->members[i].sd:g->member[i].sd) != NULL && sd != dstsd && !dstsd->state.autotrade && !pc_isdead(dstsd)) {
+					if (map_getmapflag(dstsd->bl.m, MF_NOWARP) && !map_flag_gvg2(dstsd->bl.m) && !bg)
 						continue;
 					if (!pc_job_can_entermap((enum e_job)dstsd->status.class_, src->m, dstsd->group_level))
 						continue;
@@ -9432,12 +9477,17 @@
 						called++;
 				}
 			}
-			if (sd)
+			if (sd){
+				struct battleground_data *bgd = bg_team_search(sd->bg_id);
+				if (sd->bg_id)
+					bg_block_skill_start(bgd, skill_id, skill_get_time2(skill_id, skill_lv));
+				else
 #ifdef RENEWAL
 				skill_blockpc_start(sd, skill_id, skill_get_cooldown(skill_id, skill_lv));
 #else
 				guild_block_skill(sd, skill_get_time2(skill_id, skill_lv));
 #endif
+			}
 		}
 		break;
 	case GD_CHARGESHOUT_FLAG:
@@ -9659,11 +9709,14 @@
 		break;
 	case ALL_PARTYFLEE:
 		if( sd  && !(flag&1) ) {
-			if( !sd->status.party_id ) {
+			if( !sd->status.party_id && !sd->bg_id ) {
 				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
 				break;
 			}
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+			if (battle_config.bg_party_skills && sd->bg_id)
+				map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+			else
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
 		} else
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,sc_start(src,bl,type,100,skill_lv,skill_get_time(skill_id,skill_lv)));
 		break;
@@ -9707,6 +9760,36 @@
 		}
 		break;
 	case RK_LUXANIMA:
+		/*{
+			sc_type runes[] = { SC_MILLENNIUMSHIELD, SC_REFRESH, SC_GIANTGROWTH, SC_STONEHARDSKIN, SC_VITALITYACTIVATION, SC_ABUNDANCE };
+
+			if (sd == NULL || (sd->status.party_id == 0 && !sd->bg_id) || flag&1) {
+				if (src->id == bl->id) // Don't give it back to the RK
+					break;
+
+				sc_start(src, bl, runes[skill_area_temp[5]], 100, skill_lv, skill_get_time(skill_id, skill_lv));
+				status_change_clear_buffs(bl, SCCB_LUXANIMA); // For bonus_script
+			} else if (sd) { // Find which SC is going to be given
+				int recent = 0, result = -1;
+
+				for (i = 0; i < ARRAYLENGTH(runes); i++) {
+					if (sd->sc.data[runes[i]] && ((sd->sc.data[runes[i]]->timer * (runes[i] == SC_REFRESH? 3 : 1)) > recent || recent == 0)) {
+						recent = sd->sc.data[runes[i]]->timer;
+						result = i;
+					}
+				}
+
+				if (result != -1) {
+					skill_area_temp[5] = result;
+					status_change_end(src, runes[result], INVALID_TIMER);
+					if (battle_config.bg_party_skills && sd->bg_id)
+						map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+					else
+						party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+					clif_skill_nodamage(src, src, skill_id, skill_lv, 1);
+				}
+			}
+		}*/
 		status_change_clear_buffs(bl, SCCB_LUXANIMA); // For bonus_script
 	case RK_GIANTGROWTH:
 	case RK_STONEHARDSKIN:
@@ -9741,6 +9824,29 @@
  		break;
 
 	case RK_FIGHTINGSPIRIT: {
+			/*if( flag&1 ) {
+				if( skill_area_temp[1] == bl->id )
+					sc_start2(src,bl,type,100,70 + 7 * skill_area_temp[0],4 * ((sd) ? pc_checkskill(sd,RK_RUNEMASTERY) : skill_get_max(RK_RUNEMASTERY)),skill_area_temp[4]);
+				else
+					sc_start(src,bl,type,100,skill_area_temp[3],skill_area_temp[4]);
+			} else {
+				if( sd && (sd->status.party_id || sd->bg_id)) {
+					if (battle_config.bg_party_skills && sd->bg_id)
+						skill_area_temp[0] = map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_area_sub_count);
+					else
+						skill_area_temp[0] = party_foreachsamemap(skill_area_sub,sd,skill_get_splash(skill_id,skill_lv),src,skill_id,skill_lv,tick,BCT_PARTY,skill_area_sub_count);
+					skill_area_temp[1] = src->id;
+					skill_area_temp[3] = (70 + 7 * skill_area_temp[0]) / 2;
+					skill_area_temp[4] = skill_get_time(skill_id,skill_lv);
+					if (battle_config.bg_party_skills && sd->bg_id)
+						map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+					else
+						party_foreachsamemap(skill_area_sub,sd,skill_get_splash(skill_id,skill_lv),src,skill_id,skill_lv,tick,flag|BCT_PARTY|1,skill_castend_nodamage_id);
+				}
+				else
+					sc_start2(src,bl,type,100,77,4 * ((sd) ? pc_checkskill(sd,RK_RUNEMASTERY) : skill_get_max(RK_RUNEMASTERY)),skill_get_time(skill_id,skill_lv));
+				clif_skill_nodamage(src,bl,skill_id,1,1);
+			}*/
 			uint8 runemastery_skill_lv = (sd ? pc_checkskill(sd, RK_RUNEMASTERY) : skill_get_max(RK_RUNEMASTERY));
 
 			// val1: ATKBonus: ? // !TODO: Confirm new ATK formula
@@ -9840,29 +9946,44 @@
 		{
 			int bless_lv = ((sd) ? pc_checkskill(sd,AL_BLESSING) : skill_get_max(AL_BLESSING)) + (((sd) ? sd->status.job_level : 50) / 10);
 			int agi_lv = ((sd) ? pc_checkskill(sd,AL_INCAGI) : skill_get_max(AL_INCAGI)) + (((sd) ? sd->status.job_level : 50) / 10);
-			if( sd == NULL || sd->status.party_id == 0 || flag&1 )
+			if( sd == NULL || (sd->status.party_id == 0 && !sd->bg_id) || flag&1 )
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src,bl,type,100,
 					(skill_id == AB_CLEMENTIA)? bless_lv : (skill_id == AB_CANTO)? agi_lv : skill_lv, skill_get_time(skill_id,skill_lv)));
-			else if( sd )
-				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+			else if( sd ) {
+				if (battle_config.bg_party_skills && sd->bg_id)
+					map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+				else
+					party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+			}
 		}
 		break;
 
 	case AB_PRAEFATIO:
 	case AB_RENOVATIO:
-		if( !sd || sd->status.party_id == 0 || flag&1 ) {
-			if (skill_id == AB_PRAEFATIO)
-				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start4(src, bl, type, 100, skill_lv, 0, 0, (sd && sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 1 ), skill_get_time(skill_id, skill_lv)));
-			else
+		if( !sd || (sd->status.party_id == 0 && !sd->bg_id) || flag&1 ) {
+			if (skill_id == AB_PRAEFATIO) {
+				if (battle_config.bg_party_skills && sd && sd->bg_id)
+					clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start4(src, bl, type, 100, skill_lv, 0, 0, (bg_team_foreachsamemap(bg_team_sub_count, sd, 0)), skill_get_time(skill_id, skill_lv)));
+				else
+					clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start4(src, bl, type, 100, skill_lv, 0, 0, (sd && sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 1 ), skill_get_time(skill_id, skill_lv)));
+			} else
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		} else if( sd ) {
+			if (battle_config.bg_party_skills && sd->bg_id)
+				map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+			else
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
 		break;
 
 	case AB_CHEAL:
-		if( !sd || sd->status.party_id == 0 || flag&1 ) {
+		if( !sd || (sd->status.party_id == 0 && !sd->bg_id) || flag&1 ) {
 			if( sd && tstatus && !battle_check_undead(tstatus->race, tstatus->def_ele) && !tsc->data[SC_BERSERK] ) {
-				int partycount = (sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 0);
+				int partycount = 0;
+				if (battle_config.bg_party_skills && sd->bg_id)
+					partycount = (bg_team_foreachsamemap(bg_team_sub_count, sd, 0));
+				else
+					partycount = (sd->status.party_id ? party_foreachsamemap(party_sub_count, sd, 0) : 0);
 
 				i = skill_calc_heal(src, bl, AL_HEAL, pc_checkskill(sd, AL_HEAL), true);
 
@@ -9876,8 +9997,12 @@
 					i = ~i + 1;
 				status_heal(bl, i, 0, 0);
 			}
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		} else if( sd ) {
+			if (battle_config.bg_party_skills && sd->bg_id)
+				map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+			else
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
 		break;
 
 	case AB_ORATIO:
@@ -9891,7 +10016,7 @@
 		break;
 
 	case AB_LAUDAAGNUS:
-		if( flag&1 || !sd || !sd->status.party_id ) {
+		if( flag&1 || !sd || (!sd->status.party_id && !sd->bg_id)) {
 			if( tsc && (tsc->data[SC_FREEZE] || tsc->data[SC_STONE] || tsc->data[SC_BLIND] ||
 				tsc->data[SC_BURNING] || tsc->data[SC_FREEZING] || tsc->data[SC_CRYSTALIZE])) {
 				// Success Chance: (60 + 10 * Skill Level) %
@@ -9905,13 +10030,17 @@
 			} else //Success rate only applies to the curing effect and not stat bonus. Bonus status only applies to non infected targets
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
 					sc_start(src,bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv),
-				src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		} else if( sd ) {
+			if (battle_config.bg_party_skills && sd->bg_id)
+				map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+			else
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv),
+					src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
 		break;
 
 	case AB_LAUDARAMUS:
-		if( flag&1 || !sd || !sd->status.party_id ) {
+		if( flag&1 || !sd || (!sd->status.party_id && !sd->bg_id)) {
 			if( tsc && (tsc->data[SC_SLEEP] || tsc->data[SC_STUN] || tsc->data[SC_MANDRAGORA] || tsc->data[SC_SILENCE] || tsc->data[SC_DEEPSLEEP]) ){
 				// Success Chance: (60 + 10 * Skill Level) %
 				if( rnd()%100 > 60+10*skill_lv )  break;
@@ -9923,9 +10052,13 @@
 			} else // Success rate only applies to the curing effect and not stat bonus. Bonus status only applies to non infected targets
 				clif_skill_nodamage(bl, bl, skill_id, skill_lv,
 					sc_start(src,bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv)));
-		} else if( sd )
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv),
-				src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		} else if( sd ) {
+			if (battle_config.bg_party_skills && sd->bg_id)
+				map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+			else
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv),
+					src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
 		break;
 
 	case AB_CLEARANCE:
@@ -10032,7 +10165,7 @@
 					case SC_WEDDING:		case SC_XMAS:			case SC_SUMMER:
 					case SC_DRESSUP:		case SC_HANBOK:			case SC_OKTOBERFEST:
 					case SC_LHZ_DUN_N1:		case SC_LHZ_DUN_N2:			case SC_LHZ_DUN_N3:			case SC_LHZ_DUN_N4:
-					case SC_ENTRY_QUEUE_APPLY_DELAY:	case SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT:
+					case SC_ENTRY_QUEUE_APPLY_DELAY:
 					case SC_REUSE_LIMIT_LUXANIMA:		case SC_LUXANIMA:	case SC_SOULENERGY:
 					case SC_EP16_2_BUFF_SS:		case SC_EP16_2_BUFF_SC:	case SC_EP16_2_BUFF_AC:
 					case SC_EMERGENCY_MOVE:		case SC_MADOGEAR:
@@ -10679,11 +10812,14 @@
 	case WA_SYMPHONY_OF_LOVER:
 	case MI_RUSH_WINDMILL:
 	case MI_ECHOSONG:
-		if( !sd || !sd->status.party_id || (flag & 1) ) {
+		if( !sd || (!sd->status.party_id && !sd->bg_id) || (flag & 1) ) {
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 			sc_start2(src,bl,type,100,skill_lv,((sd) ? pc_checkskill(sd,WM_LESSON) : skill_get_max(WM_LESSON)),skill_get_time(skill_id,skill_lv));
 		} else if( sd ) {
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+			if (battle_config.bg_party_skills && sd->bg_id)
+				map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+			else
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
 			sc_start2(src,bl,type,100,skill_lv,((sd) ? pc_checkskill(sd,WM_LESSON) : skill_get_max(WM_LESSON)),skill_get_time(skill_id,skill_lv));
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 		}
@@ -10758,8 +10894,12 @@
 				sc_start2(src,bl,type,100,skill_lv,pc_checkskill(sd, WM_LESSON),skill_get_time(skill_id,skill_lv));
 			}
 		} else if( sd ) {
-			if( sc_start2(src,bl,type,100,skill_lv,pc_checkskill(sd, WM_LESSON),skill_get_time(skill_id,skill_lv)) )
-				party_foreachsamemap(skill_area_sub,sd,skill_get_splash(skill_id,skill_lv),src,skill_id,skill_lv,tick,flag|BCT_PARTY|1,skill_castend_nodamage_id);
+			if( sc_start2(src,bl,type,100,skill_lv,battle_calc_chorusbonus(sd),skill_get_time(skill_id,skill_lv)) ) {
+				if (battle_config.bg_party_skills && sd->bg_id)
+					map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+				else
+					party_foreachsamemap(skill_area_sub,sd,skill_get_splash(skill_id,skill_lv),src,skill_id,skill_lv,tick,flag|BCT_PARTY|1,skill_castend_nodamage_id);
+			}
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 		}
 		break;
@@ -11483,7 +11623,7 @@
 		break;
 
 	case SO_ELEMENTAL_SHIELD:
-		if (!sd || sd->status.party_id == 0 || flag&1) {
+		if (!sd || (sd->status.party_id == 0 && !sd->bg_id) || flag&1) {
 			if (sd && sd->status.party_id == 0) {
 				clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 				if (sd->ed && skill_get_state(skill_id) == ST_ELEMENTALSPIRIT2)
@@ -11496,7 +11636,10 @@
 			clif_skill_nodamage(src,bl,skill_id,skill_lv,1);
 			if (sd->ed && skill_get_state(skill_id) == ST_ELEMENTALSPIRIT2)
 				elemental_delete(sd->ed);
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id,skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+			if (battle_config.bg_party_skills && sd->bg_id)
+				map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+			else
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id,skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
 		}
 		break;
 
@@ -11550,26 +11693,33 @@
 	case SU_HISS:
 	case SU_PURRING:
 	case SU_MEOWMEOW:
-		if (sd == NULL || sd->status.party_id == 0 || flag&1) {
+		if (sd == NULL || (sd->status.party_id == 0 && !sd->bg_id) || flag&1) {
 			int duration = skill_get_time(skill_id, skill_lv);
 
 			if (skill_id == SU_BUNCHOFSHRIMP && pc_checkskill(sd, SU_SPIRITOFSEA))
 				duration += skill_get_time2(SU_BUNCHOFSHRIMP, skill_lv);
 			clif_skill_nodamage(bl, bl, skill_id, skill_lv, sc_start(src, bl, type, 100, skill_lv, duration));
 		} else if (sd) {
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+			if (battle_config.bg_party_skills && sd->bg_id)
+				map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+			else
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
 		}
 		break;
 
 	case SU_SHRIMPARTY:
-		if (sd == NULL || sd->status.party_id == 0 || flag&1) {
+		if (sd == NULL || (sd->status.party_id == 0 && sd->bg_id) || flag&1) {
 			sc_start(src, bl, type, 100, skill_lv, skill_get_time(skill_id, skill_lv));
 			if (sd && (i = pc_checkskill(sd, SU_FRESHSHRIMP)) > 0) {
 				clif_skill_nodamage(bl, bl, SU_FRESHSHRIMP, i, 1);
 				sc_start(src, bl, SC_FRESHSHRIMP, 100, i, skill_get_time(SU_FRESHSHRIMP, i));
 			}
-		} else if (sd)
-			party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		} else if (sd) {
+			if (battle_config.bg_party_skills && sd->bg_id)
+				map_foreachinallrange(skill_area_sub, &sd->bl, skill_get_splash(skill_id, skill_lv), BL_PC, src, skill_id, skill_lv, tick, flag|BCT_NOENEMY|1, skill_castend_nodamage_id);
+			else
+				party_foreachsamemap(skill_area_sub, sd, skill_get_splash(skill_id, skill_lv), src, skill_id, skill_lv, tick, flag|BCT_PARTY|1, skill_castend_nodamage_id);
+		}
 		break;
 
 	case SU_POWEROFFLOCK:
@@ -11654,6 +11804,20 @@
 			status_change_end(src,SC_CURSEDCIRCLE_ATKER,INVALID_TIMER);
 	}
 
+	if (skill_get_inf(skill_id)&INF_SUPPORT_SKILL && sd && dstsd && sd != dstsd) {
+		if (map_getmapflag(src->m, MF_BATTLEGROUND) && sd->bg_id && dstsd->bg_id) {
+			if( sd->bg_id == dstsd->bg_id )
+				add2limit(sd->status.bgstats.support_skills_used, 1, UINT_MAX);
+			else
+				add2limit(sd->status.bgstats.wrong_support_skills_used, 1, UINT_MAX);
+		} else if (map_flag_gvg2(src->m) && sd->guild && dstsd->guild) {
+			if( sd->guild == dstsd->guild )
+				add2limit(sd->status.wstats.support_skills_used, 1, UINT_MAX);
+			else
+				add2limit(sd->status.wstats.wrong_support_skills_used, 1, UINT_MAX);
+		}
+	}
+	
 	if (dstmd) { //Mob skill event for no damage skills (damage ones are handled in battle_calc_damage) [Skotlex]
 		mob_log_damage(dstmd, src, 0); //Log interaction (counts as 'attacker' for the exp bonus)
 		mobskill_event(dstmd, src, tick, MSC_SKILLUSED|(skill_id<<16));
@@ -15970,14 +16134,17 @@
 		case GD_CHARGESHOUT_FLAG:
 		case GD_CHARGESHOUT_BEATING:
 		case GD_EMERGENCY_MOVE:
-			if (!map_flag_gvg2(sd->bl.m)) {
+			if (!(map_flag_gvg2(sd->bl.m) || map_getmapflag(sd->bl.m, MF_BATTLEGROUND))) {
 				clif_skill_fail(sd,skill_id,USESKILL_FAIL_LEVEL,0);
 				return false;
 			}
 		case GD_EMERGENCYCALL:
 		case GD_ITEMEMERGENCYCALL:
 			// other checks were already done in skill_isNotOk()
-			if (!sd->status.guild_id || (sd->state.gmaster_flag == 0 && skill_id != GD_CHARGESHOUT_BEATING))
+			if (map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
+				if( !sd->bg_id || !sd->bmaster_flag )
+					return false; // Not Team Leader on Battleground
+			} else if (!sd->status.guild_id || (sd->state.gmaster_flag == 0 && skill_id != GD_CHARGESHOUT_BEATING))
 				return false;
 			break;
 
@@ -16742,7 +16909,13 @@
 		if( !require.itemid[i] )
 			continue;
 		index[i] = pc_search_inventory(sd,require.itemid[i]);
-		if( index[i] < 0 || sd->inventory.u.items_inventory[index[i]].amount < require.amount[i] ) {
+		if( index[i] < 0 || sd->inventory.u.items_inventory[index[i]].amount < require.amount[i] ||
+			sd->inventory.u.items_inventory[index[i]].card[0] == CARD0_CREATE && 
+			((MakeDWord(sd->inventory.u.items_inventory[index[i]].card[2], sd->inventory.u.items_inventory[index[i]].card[3]) == 
+			battle_config.bg_reserved_char_id && !map_getmapflag(sd->bl.m, MF_BG_CONSUME)) ||
+			(MakeDWord(sd->inventory.u.items_inventory[index[i]].card[2], sd->inventory.u.items_inventory[index[i]].card[3]) == 
+			battle_config.woe_reserved_char_id && !map_getmapflag(sd->bl.m, MF_WOE_CONSUME)))
+		) {
 			if( require.itemid[i] == ITEMID_HOLY_WATER )
 				clif_skill_fail(sd,skill_id,USESKILL_FAIL_HOLYWATER,0); //Holy water is required.
 			else if( require.itemid[i] == ITEMID_RED_GEMSTONE )
@@ -16808,6 +16981,12 @@
 		if(require.hp || require.sp)
 			status_zap(&sd->bl, require.hp, require.sp);
 
+		//Extended Features BG
+		if (require.sp && sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND))
+			add2limit(sd->status.bgstats.sp_used, require.sp, UINT_MAX);
+		else if (require.sp && map_flag_gvg2(sd->bl.m))
+			add2limit(sd->status.wstats.sp_used, require.sp, UINT_MAX);
+		
 		if(require.spiritball > 0) { // Skills that require certain types of spheres to use
 			switch (skill_id) { // Skills that require soul spheres.
 				case SP_SOULGOLEM:
@@ -16836,6 +17015,11 @@
 			pc_delspiritball(sd,sd->spiritball,0);
 		}
 
+		if(require.spiritball && sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND))
+			add2limit(sd->status.bgstats.spiritb_used, require.spiritball, UINT_MAX);
+		else if(require.spiritball && map_flag_gvg2(sd->bl.m))
+			add2limit(sd->status.wstats.spiritb_used, require.spiritball, UINT_MAX);
+		
 		if(require.zeny > 0)
 		{
 			if( skill_id == NJ_ZENYNAGE )
@@ -16843,6 +17027,10 @@
 			if( sd->status.zeny < require.zeny )
 				require.zeny = sd->status.zeny;
 			pc_payzeny(sd,require.zeny,LOG_TYPE_CONSUME,NULL);
+			if (sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND))
+				add2limit(sd->status.bgstats.zeny_used, require.zeny, UINT_MAX);
+			else if (map_flag_gvg2(sd->bl.m))
+				add2limit(sd->status.wstats.zeny_used, require.zeny, UINT_MAX);
 		}
 	}
 
@@ -16885,6 +17073,37 @@
 
 			if( (n = pc_search_inventory(sd,require.itemid[i])) >= 0 )
 				pc_delitem(sd,n,require.amount[i],0,1,LOG_TYPE_CONSUME);
+			if (sd->bg_id && map_getmapflag(sd->bl.m, MF_BATTLEGROUND)) {
+				switch( require.itemid[i] ) {
+				case ITEMID_POISON_BOTTLE: 
+					add2limit(sd->status.bgstats.poison_bottles, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_YELLOW_GEMSTONE:
+					add2limit(sd->status.bgstats.yellow_gemstones, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_RED_GEMSTONE:
+					add2limit(sd->status.bgstats.red_gemstones, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_BLUE_GEMSTONE:
+					add2limit(sd->status.bgstats.blue_gemstones, require.amount[i], UINT_MAX);
+					break;
+				}
+			} else if (map_flag_gvg2(sd->bl.m)) {
+				switch( require.itemid[i] ) {
+				case ITEMID_POISON_BOTTLE: 
+					add2limit(sd->status.wstats.poison_bottles, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_YELLOW_GEMSTONE:
+					add2limit(sd->status.wstats.yellow_gemstones, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_RED_GEMSTONE:
+					add2limit(sd->status.wstats.red_gemstones, require.amount[i], UINT_MAX);
+					break;
+				case ITEMID_BLUE_GEMSTONE:
+					add2limit(sd->status.wstats.blue_gemstones, require.amount[i], UINT_MAX);
+					break;
+				}
+			}
 		}
 	}
 }
@@ -18205,8 +18424,15 @@
  	nullpo_ret(sd);
 
 	int range = skill_get_splash(LG_BANDING, 1);
-	uint8 count = party_foreachsamemap(party_sub_count_banding, sd, range, 0);
-	unsigned int group_hp = party_foreachsamemap(party_sub_count_banding, sd, range, 1);
+	uint8 count = 0;
+	unsigned int group_hp = 0;
+	if (battle_config.bg_party_skills && sd->bg_id) {
+		count = bg_team_foreachsamemap(party_sub_count_banding, sd, range, 0);
+		group_hp = bg_team_foreachsamemap(party_sub_count_banding, sd, range, 1);
+	} else {
+		count = party_foreachsamemap(party_sub_count_banding, sd, range, 0);
+		group_hp = party_foreachsamemap(party_sub_count_banding, sd, range, 1);
+	}
 
  	// HP is set to the average HP of the Banding group
 	if (count > 1)
Index: src/map/skill.hpp
===================================================================
diff --git a/src/map/skill.hpp b/src/map/skill.hpp
--- a/src/map/skill.hpp	9dcda4a0cf1
+++ b/src/map/skill.hpp	9b50963491d
@@ -1454,6 +1454,10 @@
 	NPC_DAMAGE_HEAL,
 	NPC_IMMUNE_PROPERTY,
 	NPC_MOVE_COORDINATE,
+	
+	CS_EQUIPMENT = 780,
+	CS_BG,
+	CS_WOE,
 
 	KN_CHARGEATK = 1001,
 	CR_SHRINK,
Index: src/map/status.cpp
===================================================================
diff --git a/src/map/status.cpp b/src/map/status.cpp
--- a/src/map/status.cpp	ed7b42f8da1
+++ b/src/map/status.cpp	c9e385964e8
@@ -1394,7 +1394,6 @@
 
 	// Battleground Queue
 	StatusIconChangeTable[SC_ENTRY_QUEUE_APPLY_DELAY] = EFST_ENTRY_QUEUE_APPLY_DELAY;
-	StatusIconChangeTable[SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT] = EFST_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT;
 
 	// Soul Reaper
 	StatusIconChangeTable[SC_SOULENERGY] = EFST_SOULENERGY;
@@ -1570,7 +1569,6 @@
 
 	// Battleground Queue
 	StatusChangeFlagTable[SC_ENTRY_QUEUE_APPLY_DELAY] |= SCB_NONE;
-	StatusChangeFlagTable[SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT] |= SCB_NONE;
 
 	// Summoner
 	StatusChangeFlagTable[SC_DORAM_WALKSPEED] |= SCB_SPEED;
@@ -2047,6 +2045,8 @@
 		case BL_MER: mercenary_heal((TBL_MER*)target,hp,sp); break;
 		case BL_ELEM: elemental_heal((TBL_ELEM*)target,hp,sp); break;
 	}
+	
+	pc_record_damage(src,target,hp);
 
 	if( src && target->type == BL_PC && ((TBL_PC*)target)->disguise ) { // Stop walking when attacked in disguise to prevent walk-delay bug
 		unit_stop_walking( target, 1 );
@@ -2141,10 +2141,9 @@
 	if(target->type == BL_PC) {
 		TBL_PC *sd = BL_CAST(BL_PC,target);
 		if( sd->bg_id ) {
-			std::shared_ptr<s_battleground_data> bg = util::umap_find(bg_team_db, sd->bg_id);
-
-			if( bg && !(bg->die_event.empty()) )
-				npc_event(sd, bg->die_event.c_str(), 0);
+			struct battleground_data *bg;
+			if( (bg = bg_team_search(sd->bg_id)) != NULL && bg->die_event[0] )
+				npc_event(sd, bg->die_event, 0);
 		}
 
 		npc_script_event(sd,NPCE_DIE);
@@ -10165,6 +10164,7 @@
 			case SC_LHZ_DUN_N4:
 			case SC_FLASHKICK:
 			case SC_SOULUNITY:
+			case SC_ENTRY_QUEUE_APPLY_DELAY:
 				break;
 			case SC_GOSPEL:
 				 // Must not override a casting gospel char.
@@ -12903,7 +12903,6 @@
 			case SC_LHZ_DUN_N3:
 			case SC_LHZ_DUN_N4:
 			case SC_ENTRY_QUEUE_APPLY_DELAY:
-			case SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT:
 			case SC_REUSE_LIMIT_LUXANIMA:
 			case SC_SOULENERGY:
 			case SC_MADOGEAR:
@@ -12942,7 +12941,6 @@
 			case SC_ALL_RIDING:
 			case SC_STYLE_CHANGE:
 			case SC_ENTRY_QUEUE_APPLY_DELAY:
-			case SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT:
 			case SC_MADOGEAR:
 			// Costumes
 			case SC_MOONSTAR:
Index: src/map/status.hpp
===================================================================
diff --git a/src/map/status.hpp b/src/map/status.hpp
--- a/src/map/status.hpp	3ba6fd14968
+++ b/src/map/status.hpp	1c40a33f74c
@@ -883,8 +883,6 @@
 	SC_BASILICA_CELL, // Used in renewal mode for cell_basilica only
 
 	SC_ENTRY_QUEUE_APPLY_DELAY,
-	SC_ENTRY_QUEUE_NOTIFY_ADMISSION_TIME_OUT,
-
 	// Star Emperor
 	SC_LIGHTOFMOON,
 	SC_LIGHTOFSUN,
Index: src/map/storage.cpp
===================================================================
diff --git a/src/map/storage.cpp b/src/map/storage.cpp
--- a/src/map/storage.cpp	13222219645
+++ b/src/map/storage.cpp	96c4b7a53c5
@@ -13,6 +13,7 @@
 #include "../common/nullpo.hpp"
 #include "../common/showmsg.hpp"
 #include "../common/utilities.hpp"
+#include "../common/utils.hpp"
 
 #include "battle.hpp"
 #include "chrif.hpp"
@@ -785,6 +786,13 @@
 		return false;
 	}
 
+	//Brian Bg Items - updated by [AnubisK]
+	if( item_data->card[0]==CARD0_CREATE && (MakeDWord(item_data->card[2],item_data->card[3]) == (battle_config.bg_reserved_char_id || battle_config.woe_reserved_char_id)  && !battle_config.bg_can_trade))
+	{	// "Battleground's Items"
+		clif_displaymessage (sd->fd, msg_txt(sd,264));
+		return 1;
+	}
+	
 	if(itemdb_isstackable2(id)) { //Stackable
 		for(i = 0; i < stor->max_amount; i++) {
 			if(compare_item(&stor->u.items_guild[i], item_data)) {
Index: src/map/trade.cpp
===================================================================
diff --git a/src/map/trade.cpp b/src/map/trade.cpp
--- a/src/map/trade.cpp	7a3efa82628
+++ b/src/map/trade.cpp	8fc9c93669f
@@ -8,6 +8,7 @@
 
 #include "../common/nullpo.hpp"
 #include "../common/socket.hpp"
+#include "../common/utils.hpp"
 
 #include "atcommand.hpp"
 #include "battle.hpp"
@@ -394,6 +395,13 @@
 		return;
 	}
 
+	if( item->card[0]==CARD0_CREATE && (MakeDWord(item->card[2],item->card[3])== (battle_config.bg_reserved_char_id || battle_config.woe_reserved_char_id )&& !battle_config.bg_can_trade) )
+	{	// "Battleground's Items"
+		clif_displaymessage (sd->fd, msg_txt(sd,260));
+		clif_tradeitemok(sd, index+2, 1);
+		return;
+	}
+	
 	if( ((item->bound == BOUND_ACCOUNT || item->bound > BOUND_GUILD) || (item->bound == BOUND_GUILD && sd->status.guild_id != target_sd->status.guild_id)) && !pc_can_give_bounded_items(sd) ) { // Item Bound
 		clif_displaymessage(sd->fd, msg_txt(sd,293));
 		clif_tradeitemok(sd, index+2, 1);
Index: src/map/unit.cpp
===================================================================
diff --git a/src/map/unit.cpp b/src/map/unit.cpp
--- a/src/map/unit.cpp	75e1465299a
+++ b/src/map/unit.cpp	364da3b7f9d
@@ -1278,7 +1278,7 @@
 
 	switch (bl->type) {
 		case BL_MOB:
-			if (map_getmapflag(bl->m, MF_MONSTER_NOTELEPORT) && ((TBL_MOB*)bl)->master_id == 0)
+			if (map_getmapflag(bl->m, MF_MONSTER_NOTELEPORT) && ((TBL_MOB*)bl)->master_id == 0 && !map_getmapflag(bl->m, MF_BATTLEGROUND))
 				return 1;
 
 			if (m != bl->m && map_getmapflag(m, MF_NOBRANCH) && battle_config.mob_warp&4 && !(((TBL_MOB *)bl)->master_id))
@@ -3373,6 +3373,7 @@
 			pc_inventory_rental_clear(sd);
 			pc_delspiritball(sd, sd->spiritball, 1);
 			pc_delspiritcharm(sd, sd->spiritcharm, sd->spiritcharm_type);
+			if (sd->qd) bg_queue_leaveall(sd);
 
 			if( sd->st && sd->st->state != RUN ) {// free attached scripts that are waiting
 				script_free_state(sd->st);
Index: src/map/vending.cpp
===================================================================
diff --git a/src/map/vending.cpp b/src/map/vending.cpp
--- a/src/map/vending.cpp	bdc4400940b
+++ b/src/map/vending.cpp	221149f98eb
@@ -10,6 +10,7 @@
 #include "../common/showmsg.hpp" // ShowInfo
 #include "../common/strlib.hpp"
 #include "../common/timer.hpp"  // DIFF_TICK
+#include "../common/utils.hpp"
 
 #include "achievement.hpp"
 #include "atcommand.hpp"
@@ -341,6 +342,9 @@
 		||  sd->cart.u.items_cart[index].attribute == 1 // broken item
 		||  sd->cart.u.items_cart[index].expire_time // It should not be in the cart but just in case
 		||  (sd->cart.u.items_cart[index].bound && !pc_can_give_bounded_items(sd)) // can't trade account bound items and has no permission
+		||  (sd->cart.u.items_cart[index].card[0]==CARD0_CREATE && (MakeDWord(sd->cart.u.items_cart[index].card[2],sd->cart.u.items_cart[index].card[3]) == 
+		(battle_config.bg_reserved_char_id || battle_config.woe_reserved_char_id) && !battle_config.bg_can_trade))
+		// end Brian Bg Items
 		||  !itemdb_cantrade(&sd->cart.u.items_cart[index], pc_get_group_level(sd), pc_get_group_level(sd)) ) // untradeable item
 			continue;
 
